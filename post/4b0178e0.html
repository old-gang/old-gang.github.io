<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构与算法 | Mr.储</title><meta name="keywords" content="web前端"><meta name="author" content="Mr.储"><meta name="copyright" content="Mr.储"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaScript数据结构和算法(一) 邂逅数据结构与算法1. 编程尽头、数据结构1.1 为什么需要学习数据结构与算法？ 1.2 编程的真相 – 数据的处理 在前面的课程中我不断的强调一个编程的真相：对数据的操作和处理 编程的最终目的只有一个：对数据进行操作和处理 评判编程能力、水平的高低，要看你是否可以更好的操作和处理数据 在之前的很多课程中，我经常和同学们强调一个事实：所以的编程（无论是前端">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="https://old-gang.github.io/post/4b0178e0.html">
<meta property="og:site_name" content="Mr.储">
<meta property="og:description" content="JavaScript数据结构和算法(一) 邂逅数据结构与算法1. 编程尽头、数据结构1.1 为什么需要学习数据结构与算法？ 1.2 编程的真相 – 数据的处理 在前面的课程中我不断的强调一个编程的真相：对数据的操作和处理 编程的最终目的只有一个：对数据进行操作和处理 评判编程能力、水平的高低，要看你是否可以更好的操作和处理数据 在之前的很多课程中，我经常和同学们强调一个事实：所以的编程（无论是前端">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-08-17T07:17:14.000Z">
<meta property="article:modified_time" content="2025-10-29T03:27:41.039Z">
<meta property="article:author" content="Mr.储">
<meta property="article:tag" content="web前端">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://old-gang.github.io/post/4b0178e0"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-10-29 11:27:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Mr.储</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">更新于</span><time datetime="2025-10-29T03:27:41.039Z" title="更新于 2025-10-29 11:27:41">2025-10-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JavaScript数据结构和算法"><a href="#JavaScript数据结构和算法" class="headerlink" title="JavaScript数据结构和算法"></a>JavaScript数据结构和算法</h1><h2 id="一-邂逅数据结构与算法"><a href="#一-邂逅数据结构与算法" class="headerlink" title="(一) 邂逅数据结构与算法"></a>(一) 邂逅数据结构与算法</h2><h3 id="1-编程尽头、数据结构"><a href="#1-编程尽头、数据结构" class="headerlink" title="1. 编程尽头、数据结构"></a>1. 编程尽头、数据结构</h3><h4 id="1-1-为什么需要学习数据结构与算法？"><a href="#1-1-为什么需要学习数据结构与算法？" class="headerlink" title="1.1 为什么需要学习数据结构与算法？"></a>1.1 为什么需要学习数据结构与算法？</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743317096967.png" alt="74331709696"></p>
<h4 id="1-2-编程的真相-–-数据的处理"><a href="#1-2-编程的真相-–-数据的处理" class="headerlink" title="1.2 编程的真相 – 数据的处理"></a>1.2 编程的真相 – 数据的处理</h4><ul>
<li>在前面的课程中我不断的强调一个编程的真相：对数据的操作和处理</li>
<li>编程的最终目的只有一个：对数据进行操作和处理<ul>
<li>评判编程能力、水平的高低，要看你<code>是否可以更好的操作和处理数据</code></li>
<li>在之前的很多课程中，我经常和同学们强调一个事实：所以的编程（无论是前端、后端、算法、人工智能、区块链，也不论是什么语言JavaScript、Java、C++等等）最终的目的都是为了处理数据</li>
</ul>
</li>
<li>当你拿到这些数据时，以什么样的方式存储和处理会更加方便、高效，也是评判一个开发人员能力的重要指标（甚至是唯一的指标）<ul>
<li>虽然目前很多的系统、框架已经给我们提供了足够多好用的API，对于大多数时候我们只需要调用这些API即可</li>
<li>但是<code>如何更好的组织数据和代码</code>，以及<code>当数据变得复杂</code>时，<code>以什么方式处理这些数据</code>依然非常重要</li>
<li>只有可以更好的处理数据，你才是一个<code>真正的开发工程师</code>，而不只是一个API调用程序员</li>
</ul>
</li>
<li>以前端、后端为例：<ul>
<li>前端从后端获取数据，对数据进行处理、展示</li>
<li>和用户进行交互产生新的数据，传递给后端，后端进行处理、保存到数据库，以便后续读取、操作、展示等等</li>
</ul>
</li>
</ul>
<h4 id="1-3-数据结构与算法的本质"><a href="#1-3-数据结构与算法的本质" class="headerlink" title="1.3 数据结构与算法的本质"></a>1.3 数据结构与算法的本质</h4><blockquote>
<p>数据结构与算法的本质就是一门专门研究数据如何组织、存储和操作的科目</p>
</blockquote>
<ul>
<li>甚至Pascal之父——尼古拉斯赵四说过：<ul>
<li><code>Nicklaus Wirth</code>凭借一个<code>公式获得图灵奖</code></li>
<li><code>算法 + 数据结构 = 程序（Algorithm+Data Structures=Programs）</code></li>
</ul>
</li>
<li>所以数据结构与算法事实上是程序的核心，是我们编写的所有程序的灵魂</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743317827918.png" alt="74331782791"></p>
<ul>
<li>勿在浮沙筑高台<ul>
<li>只有掌握了扎实的数据结构与算法，我们才能更好的理解编程，编写扎实、高效的程序</li>
<li>包括对于程序的理解不再停留于表面，甚至在学习其他的系统或者编程语言时，也可以做到高屋建瓴、势如破竹</li>
</ul>
</li>
</ul>
<h3 id="2-数据结构与算法的应用"><a href="#2-数据结构与算法的应用" class="headerlink" title="2.  数据结构与算法的应用"></a>2.  数据结构与算法的应用</h3><h4 id="2-1-学习数据结构与算法到底有什么实际应用？"><a href="#2-1-学习数据结构与算法到底有什么实际应用？" class="headerlink" title="2.1 学习数据结构与算法到底有什么实际应用？"></a>2.1 学习数据结构与算法到底有什么实际应用？</h4><ul>
<li>只要是已经接触或者即将接触编程的人，都会或多或少的听说过数据结构与算法，也有很多人可以直接说出几种耳熟能详的数据结构<ul>
<li>很多计算机专业的同学，在大学也是学习过《数据结构》这门课程的</li>
<li>但是对于很多同学来说，平时学习或者工作来说，好像很少直接用到或者直接接触到数据结构与算法</li>
<li>事实上数据结构与算法是无处不在的</li>
</ul>
</li>
<li>系统、语言、框架源码随处可见数据结构与算法：<ul>
<li>无论是操作系统（Windows、Mac OS）本身，还是我们所使用的编程语言（JavaScript、Java、C++、Python等等），还是我们在平时应用程序中用到的框架（Vue、React、Spring、Flask等等），它们的底层实现到处都是数据结构与算法，所以你要想学习一些底层的知识或者某一个框架的源码（比如Vue、React的源码）是必须要掌握数据结构与算法的</li>
<li>以前端为例：框架中大量<code>使用到了栈结构、队列结构</code>等来解决问题（比如之前看框架源码时经常看到这些数据结构，Vue源码、React源码、Webpack源码中可以看到队列、栈结构、树结构等等，Webpack中还可以看到很多Graph图结构）</li>
<li><code>实现语言或者引擎本身也需要大量的数据结构</code>：哈希表结构、队列结构（微任务队列、宏任务队列），前端无处不在的数据结构：DOM Tree（树结构）、AST（抽象语法树）</li>
</ul>
</li>
</ul>
<h4 id="2-2-Vue源码中的数据结构"><a href="#2-2-Vue源码中的数据结构" class="headerlink" title="2.2 Vue源码中的数据结构"></a>2.2 Vue源码中的数据结构</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743318277535.png" alt="74331827753"></p>
<h4 id="2-3-React、Webpack源码中的数据结构"><a href="#2-3-React、Webpack源码中的数据结构" class="headerlink" title="2.3 React、Webpack源码中的数据结构"></a>2.3 React、Webpack源码中的数据结构</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743318402405.png" alt="74331840240"></p>
<h4 id="2-4-Homebrew作者被Google拒绝"><a href="#2-4-Homebrew作者被Google拒绝" class="headerlink" title="2.4 Homebrew作者被Google拒绝"></a>2.4 Homebrew作者被Google拒绝</h4><ul>
<li>互联网大厂、高级岗位面试都会要求<code>必须要掌握一定的数据结构与算法</code></li>
<li>Mac上非常知名的工具homebrew的作者Max Howell曾经去Google面试，Google要求它写一个《反转二叉树》的算法（课堂会讲到），但是因为没有写出所以被拒绝了<ul>
<li>当然这件事本身可能会让我们唏嘘：一些人才因为对于数据结构与算法的掌握不够被埋没</li>
<li>但是从侧面也能反应对于很多互联网大厂（无论是国内外的大厂）对于数据结构与算法的重视程度</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743318727749.png" alt="74331872774"></p>
<h4 id="2-5-互联网大厂、高级岗位面试"><a href="#2-5-互联网大厂、高级岗位面试" class="headerlink" title="2.5 互联网大厂、高级岗位面试"></a>2.5 互联网大厂、高级岗位面试</h4><ul>
<li>因为对于很多企业来说，想要短时间考察一个人的能力以及未来的潜力，数据结构与算法是非常重要指标，也会成为它们的硬性条件<ul>
<li>对于可以将数据结构与算法掌握很好的开发人员来说，通常对于业务的把握肯定是没有问题的</li>
<li>并且对于系统的设计也会更加合理，可以写出更加高效的代码</li>
</ul>
</li>
<li>对于想要进入大厂的同学，经常会<code>刷leetcode</code><ul>
<li>但是对于大多数同学来说，leetcode上的题目晦涩难懂，代码无从下手，不会解题</li>
<li>只有系统的掌握了数据结构与算法，才能将这些题目融会贯通，面试遇到相关的题目就可以对答如流</li>
</ul>
</li>
<li>逻辑思维、代码能力提升离不开对于数据的处理<ul>
<li>我们已经强调了所有的编程最终的目的都是<code>为了处理数据</code></li>
<li>而数据结构与算法就是一门专为讲解数据应该<code>如何存储、组织、操作的课程</code></li>
<li>所以学习数据结构与算法可以更好的<code>锻炼我们的逻辑思维能力和代码编程能力</code>，帮助我们平时在处理一些复杂数据时，可以更好的编写代码，写出更高效的程序</li>
</ul>
</li>
<li>并且掌握数据结构与算法后，如果想要转向其他的领域（比如从前端转到后端、算法工程师等）也会更加容易<ul>
<li>因为所有的编程思想都是想通的，只是<code>换了一种语言来处理数据</code>而已</li>
<li>对于未来更多的领域，比如<code>人工智能、区块链，数据结构与算法也是它们的基石</code>，是必须要掌握的一门课程</li>
</ul>
</li>
</ul>
<h3 id="3-如何学习数据结构算法？"><a href="#3-如何学习数据结构算法？" class="headerlink" title="3. 如何学习数据结构算法？"></a>3. 如何学习数据结构算法？</h3><ul>
<li>数据结构与算法通常被认为 晦涩难懂、复杂抽象，对于大多数人来说学习起来是比较困难的</li>
<li>那么通常学习数据结构与算法有哪些方式呢？</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743319524199.png" alt="74331952419"></p>
<h3 id="4-到底什么是数据结构？"><a href="#4-到底什么是数据结构？" class="headerlink" title="4. 到底什么是数据结构？"></a>4. 到底什么是数据结构？</h3><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743321130519.png" alt="74332113051"></p>
<ul>
<li><p>非官方较为标准的定义</p>
<ul>
<li>数据结构是数据对象，以及存在于该对象的实例和 组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。 — 《数据结构、算法与应用》</li>
<li>数据结构是ADT（抽象数据类型 Abstract Data Type）的物理实现。 — 《数据结构与算法分析》</li>
<li>数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以 带来最优效率的算法。 —  中文维基百科</li>
</ul>
</li>
<li><p>我们还是从 自己的角度 来认识数据结构吧</p>
<ul>
<li>数据结构就是 在计算机中，存储和组织数据的方式</li>
<li>我们知道，计算机中数据量非常庞大，如何以高效的方式组织和存储呢？</li>
<li>这就好比一个庞大的图书馆中存放了大量的书籍，我们不仅仅要把书放进入，还应该在合适的时候能够取出来</li>
</ul>
</li>
<li><p>我们从摆放图书说起：</p>
<ul>
<li><p>如果是自己的书相对较少，我们可以这样摆放</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743320967269.png" alt="74332096726"></p>
</li>
<li><p>如果你有一家书店，书的数量相对较多，我们可以这样摆放</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743321033832.png" alt="74332103383"></p>
</li>
<li><p>如果我们开了一个图书馆，书的数量相当庞大，我们可以这样摆放</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743321069382.png" alt="74332106938"></p>
</li>
<li><p>图书摆放规则</p>
<ol>
<li>图书摆放要使得两个 相关操作 方便实现：<ul>
<li>操作1：新书怎么插入？</li>
<li>操作2：怎么找到某本指定的书？</li>
</ul>
</li>
<li>方法1：随便放<ul>
<li>插入操作：哪里有空放哪里，一步到位！</li>
<li>查找操作：找某本书，累死。。。</li>
</ul>
</li>
<li>方法2：按照书名的拼音字母顺序排放<ul>
<li>插入操作：新进一本《阿Q正传》《理想国》，按照字母顺序找到位置，插入</li>
<li>查找操作：二分查找法</li>
</ul>
</li>
<li>方法3：把书架划分成几块区域，按照类别存放，类别中按照字母顺序<ul>
<li>插入操作：先定类别，二分查找确定位置，移出空位</li>
<li>查找操作：先定类别，再二分查找</li>
</ul>
</li>
</ol>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743321288682.png" alt="74332128868"></p>
</li>
</ul>
</li>
</ul>
<h4 id="4-1-常见的数据结构"><a href="#4-1-常见的数据结构" class="headerlink" title="4.1 常见的数据结构"></a>4.1 常见的数据结构</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743321347254.png" alt="74332134725"></p>
<ul>
<li>那么在计算机中对于数据的组织和存储结构也会影响我们的效率</li>
<li>常见的数据结构较多<ul>
<li>每一种都有其对应的应用场景，<code>不同的数据结构</code>的<code>不同操作</code>性能是不同的</li>
<li>有的<code>查询性能很</code>快，有的<code>插入速度很快</code>，有的是<code>插入头和尾速度很快</code></li>
<li>有的<code>做范围查找很快</code>，有的<code>允许元素重复</code>，有的<code>不允许重复</code>等等</li>
<li>在开发中如何选择，要根据具体的需求来选择</li>
</ul>
</li>
<li>注意：数据结构和语言无关，常见的编程语言都有<code>直接或者间接</code>的使用上述常见的数据结构</li>
<li>为什么之前学习JavaScript没有接触过数据结构呢？ 好像只见过数组<ul>
<li>这是因为很多数据结构是需要再进行高阶开发（比如设计框架源码）时才会用到的</li>
<li>设置某些数据结构在JavaScript中本身是没有的，我们需要从零去实现的</li>
</ul>
</li>
<li>你可能会想：老师，我觉得不多呀，赶紧给我们讲讲怎么用的就行了<ul>
<li>我们不是要讲这些数据结构如何用，用是API程序员的思考方式，我们要讲的是这些数据结构如何实现，再如何使用</li>
<li>了解真相，你才能获得真正的自由</li>
</ul>
</li>
</ul>
<h3 id="5-到底什么是算法？"><a href="#5-到底什么是算法？" class="headerlink" title="5. 到底什么是算法？"></a>5. 到底什么是算法？</h3><h4 id="5-1-什么是算法？"><a href="#5-1-什么是算法？" class="headerlink" title="5.1 什么是算法？"></a>5.1 什么是算法？</h4><ul>
<li><p>算法(Algorithm)的认识</p>
<ul>
<li>在之前的学习中，我们可能学习过几种排序算法，并且知道不同的算法，执行效率是不一样的</li>
<li>也就是说<code>解决问题</code>的过程中，不仅仅<code>数据的存储方式会影响效率，算法的优劣也会影响着效率</code></li>
<li>那么到底什么是算法呢？</li>
</ul>
</li>
<li><p>算法的定义：</p>
<ul>
<li>一个有限指令集，每条指令的描述不依赖于语言</li>
<li>接受一些输入（有些情况下不需要输入）</li>
<li>产生输出</li>
<li>一定在有限步骤之后终止</li>
</ul>
</li>
<li><p>算法通俗理解：</p>
<ul>
<li><code>Algorithm</code>这个单词本意就是<code>解决问题的办法/步骤逻辑</code></li>
<li><code>数据结构的实现，离不开算法</code></li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743321890500.png" alt="74332189050"></p>
<h4 id="5-2-生活中的数据结构与算法"><a href="#5-2-生活中的数据结构与算法" class="headerlink" title="5.2 生活中的数据结构与算法"></a>5.2 生活中的数据结构与算法</h4><ul>
<li>前面我们提了一下生活中的数据结构和算法：<code>图书的摆放</code><ul>
<li>为了更加方便的插入和搜索书籍，需要合理的组织数据，并且通过更加高效的算法插入和查询数据</li>
<li>除了这些，生活中还有很多案例</li>
</ul>
</li>
<li>快递员的快递<ul>
<li>大家平时都有收到过快递</li>
<li>现在很多的快递通常情况不是送到家里的</li>
<li>通常快递会放在某个固定的地方，让大家自己去拿</li>
<li>当你跑到固定的地方拿快递，还有两种情况：一种自己去海量的快递中找，另一种快递员让你报出名字，它帮你找</li>
<li>自己寻找相当于线性查找，一个个挨着看吧<ul>
<li>当然我们人类眼睛处理数据的能力非常快，眼观六路耳听八方，可能很快也能找到</li>
</ul>
</li>
<li>但是比较好的方式，应该是快递员帮我们找<ul>
<li>如果这个快递员动动脑筋的话，最好的方式是对快递进行分类，比如按照名字分类</li>
</ul>
</li>
<li>这个时候，只要你报出名字，它会根据姓氏立马锁定到某一个区域的快递中，再根据名字马上帮你找到</li>
<li>这就体现了合理的组织数据，对于我们获取数据效率的重要性至关重要</li>
</ul>
</li>
</ul>
<h3 id="6-生活中数据结构与算法"><a href="#6-生活中数据结构与算法" class="headerlink" title="6. 生活中数据结构与算法"></a>6. 生活中数据结构与算法</h3><ul>
<li><p>找出线缆出问题的地方：</p>
<ul>
<li>假如上海和杭州之间有一条高架线，高架线长度是1000000米，有一天高架线中有其中一米出现了故障</li>
<li>请你想出一种算法，可以快速定位到处问题的地方</li>
</ul>
</li>
<li><p>线性查找：</p>
<ul>
<li>从上海的起点开始一米一米的排查，最终一定能找到出问题的线段</li>
<li>但是如果线段在另一头，我们需要排查1000000次，这是最坏的情况。平均需要500000次</li>
</ul>
</li>
<li><p>二分查找：</p>
<ul>
<li>从中间位置开始排查，看一下问题出在上海到中间位置，还是中间到杭州的位置</li>
<li>查找对应的问题后，再从中间位置分开，重新锁定一半的路程</li>
<li>最坏的情况，需要多少次可以排查完呢？ 最坏的情况是20次就可以找到出问题的地方</li>
<li>怎么计算出来的呢？log(1000000，2)，以2位底，1000000的对数 ≈ 20</li>
</ul>
</li>
<li><p>结论：</p>
<ul>
<li>你会发现，解决问题的办法有很多。但是好的算法对比于差的算法，效率天壤之别</li>
</ul>
</li>
<li><p>后续我们还会讲解大O表示法来评定算法的效率（这里暂时不讲）</p>
</li>
</ul>
<h2 id="二-线性结构-–-数组"><a href="#二-线性结构-–-数组" class="headerlink" title="(二) 线性结构 – 数组"></a>(二) 线性结构 – 数组</h2><h3 id="1-线性结构（Linear-List）"><a href="#1-线性结构（Linear-List）" class="headerlink" title="1. 线性结构（Linear List）"></a>1. 线性结构（Linear List）</h3><ul>
<li>线性结构（英語：Linear List）是由n（n≥0）个数据元素（结点）a[0]，a[1]，a[2]…，a[n-1]组成的有限序列</li>
<li>其中：<ul>
<li>数据元素的个数n定义为表的长度 &#x3D; “list”.length() （“list”.length() &#x3D; 0（表里没有一个元素）时称为空表）</li>
<li>将非空的线性表（n&gt;&#x3D;1）记作：（a[0]，a[1]，a[2]，…，a[n-1]）</li>
<li>数据元素a[i]（0≤i≤n-1）只是个抽象符号，其具体含义在不同情况下可以不同</li>
</ul>
</li>
<li>上面是维基百科对于线性结构的定义，有一点点抽象，其实我们只需要记住几个常见的线性结构即可<ul>
<li>数组&#x2F;链表 是一种线性结构</li>
<li>栈&#x2F;队列 是一种受限的线性结构</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743324849239.png" alt="74332484923"></p>
<h3 id="2-数组（Array）结构"><a href="#2-数组（Array）结构" class="headerlink" title="2. 数组（Array）结构"></a>2. 数组（Array）结构</h3><blockquote>
<p>这里我们不再详细讲解TypeScript中数组的各种用法，和JavaScript是一致的</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a></p>
</blockquote>
<ul>
<li>数组（Array）结构是一种重要的数据结构<ul>
<li>几乎是每种编程语言都会提供的一种<code>原生数据结构（语言自带的）</code></li>
<li>并且我们<code>可以借助于数组结构来实现其他的数据结构</code>，比如栈（Stack）、队列（Queue）、堆（Heap）</li>
</ul>
</li>
<li>通常数组的<code>内存是连续的</code>，所以数组在知道下标值的情况下，访问效率是非常高的；链表是在插入和删除数据的时候效率比较高</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743324942516.png" alt="74332494251"></p>
<ul>
<li>后续我们在讨论数组和链表的关系区别时，还会通过大O表示法来分析数组操作元素的时间复杂度问题</li>
<li>面试题：约瑟夫环问题  –&gt;  使用数组(队列)、链表实现</li>
</ul>
<h2 id="三-栈结构（Stack）"><a href="#三-栈结构（Stack）" class="headerlink" title="(三) 栈结构（Stack）"></a>(三) 栈结构（Stack）</h2><h3 id="1-认识栈结构和特性"><a href="#1-认识栈结构和特性" class="headerlink" title="1. 认识栈结构和特性"></a>1. 认识栈结构和特性</h3><blockquote>
<p> 栈也是一种非常常见的数据结构， 并且在程序中的应用非常广泛</p>
</blockquote>
<ul>
<li>数组<ul>
<li>我们知道数组是一种<code>线性结构</code>， 并且可以在数组的<code>任意位置</code>插入和删除数据</li>
<li>但是有时候， 我们为了实现某些功能， 必须对这种<code>任意性</code>加以<code>限制</code></li>
<li>而<code>栈和队列</code>就是比较常见的<code>受限的线性结构</code>， 我们先来学习栈结构</li>
</ul>
</li>
<li>栈结构示意图</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743326455375.png" alt="74332645537"></p>
<ul>
<li>栈（stack），它是一种受限的线性结构，<code>后进先出(LIFO)处理</code><ul>
<li>其限制是仅允许在<code>表的一端</code>进行插入和删除运算。这一端被称为<code>栈顶</code>，相对地，把另一端称为<code>栈底</code></li>
<li>LIFO(last in first out)表示就是后进入的元素， 第一个弹出栈空间。 类似于自动餐托盘， 最后放上的托盘， 往往先把拿出去使用</li>
<li>向一个栈插入新元素又称作<code>进栈、入栈</code>或<code>压栈</code>，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素</li>
<li>从一个栈删除元素又称作<code>出栈或退栈</code>，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素</li>
</ul>
</li>
<li>生活中类似于栈的<ul>
<li>自助餐的托盘， 最新放上去的， 最先被客人拿走使用</li>
<li>收到很多的邮件(实体的)， 从上往下依次处理这些邮件。 (最新到的邮件， 最先处理)</li>
<li>注意: 不允许改变邮件的次序， 比如从最小开始， 或者处于最紧急的邮件， 否则就不再是栈结构了。 而是队列或者优先级队列结构</li>
</ul>
</li>
</ul>
<h3 id="2-栈结构特性-面试题"><a href="#2-栈结构特性-面试题" class="headerlink" title="2. 栈结构特性-面试题"></a>2. 栈结构特性-面试题</h3><p><strong>练习题：有六个元素6,5,4,3,2,1 的顺序进栈，问下列哪一个不是合法的出栈顺序？（ C ）</strong></p>
<p>A：5 4 3 6 1 2              B：4 5 3 2 1 6               C：3 4 6 5 2 1              D：2 3 4 1 5 6</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1743334791589.png" alt="74333479158"></p>
<h3 id="3-实现栈结构的封装"><a href="#3-实现栈结构的封装" class="headerlink" title="3. 实现栈结构的封装"></a>3. 实现栈结构的封装</h3><h4 id="3-1-栈结构的实现"><a href="#3-1-栈结构的实现" class="headerlink" title="3.1 栈结构的实现"></a>3.1 栈结构的实现</h4><ul>
<li>实现栈结构有两种比较常见的方式<ul>
<li>基于<code>数组</code>实现（这种方法更好）</li>
<li>基于<code>链表</code>实现</li>
</ul>
</li>
<li>什么是链表?<ul>
<li>也是一种数据结构，目前我们还没有学习，并且<code>JavaScript中并没有自带链表结构</code></li>
<li>后续，我们会自己来实现链表结构，并且对比数组和链表的区别</li>
</ul>
</li>
</ul>
<h4 id="3-2-创建栈的类"><a href="#3-2-创建栈的类" class="headerlink" title="3.2 创建栈的类"></a>3.2 创建栈的类</h4><ul>
<li><p>我们先来创建一个栈的类，用于封装栈相关的操作</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用ts代码，使用ts-node插件编译代码：查看ts-node版本 (ts-node --version)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">data</span>: T[] = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码解析</p>
<ul>
<li>我们创建了一个ArrayStack，用户创建栈的类，可以定义一个泛型类</li>
<li>在构造函数中，定义了一个变量，这个变量可以用于保存当前栈对象中所有的元素</li>
<li>这个变量是一个数组类型</li>
<li>我们之后无论是压栈操作还是出栈操作，都是从数组中添加和删除元素</li>
<li>栈有一些相关的操作方法，通常无论是什么语言，操作都是比较类似的</li>
</ul>
</li>
</ul>
<h3 id="4-栈结构常见的方法-完整封装"><a href="#4-栈结构常见的方法-完整封装" class="headerlink" title="4. 栈结构常见的方法 (完整封装)"></a>4. 栈结构常见的方法 (完整封装)</h3><ul>
<li><p>栈常见有哪些操作：</p>
<ul>
<li><code>push(element)</code>: 添加一个新元素到栈顶位置</li>
<li><code>pop()</code>：移除栈顶的元素，同时返回被移除的元素</li>
<li><code>peek()</code>：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）</li>
<li><code>isEmpty()</code>：如果栈里没有任何元素就返回true，否则返回false</li>
<li><code>size()</code>：返回栈里的元素个数。这个方法和数组的length属性很类似</li>
</ul>
</li>
<li><p>现在，我们可以在类中一一实现这些方法</p>
</li>
<li><p>基于<code>数组</code>实现</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 02.实现栈结构(重构).ts</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口继承接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IStack</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">IList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">push</span>(<span class="attr">element</span>: T): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">pop</span>(): T | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">IStack</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">data</span>: T[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push方法：将一个元素压入栈中</span></span><br><span class="line">  <span class="title function_">push</span>(<span class="attr">element</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pop方法：移除栈顶的元素，同时返回被移除的元素</span></span><br><span class="line">  <span class="title function_">pop</span>(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// peek方法：返回栈顶的元素，不对栈做任何修改</span></span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isEmpty方法：判断栈是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size方法：返回栈里的元素个数</span></span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack1 = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">stack1.<span class="title function_">push</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">stack1.<span class="title function_">push</span>(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">stack1.<span class="title function_">push</span>(<span class="string">&quot;ccc&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-栈面试题-–-十进制转二进制"><a href="#5-栈面试题-–-十进制转二进制" class="headerlink" title="5. 栈面试题 – 十进制转二进制"></a>5. 栈面试题 – 十进制转二进制</h3><ul>
<li><p>我们已经学会了如何使用Stack类，现在就用它解决一些计算机科学中的问题</p>
</li>
<li><p>为什么需要十进制转二进制？</p>
<ul>
<li>现实生活中，我们主要使用<code>十进制</code></li>
<li>但在计算科学中，<code>二进制非常重要</code>，因为<code>计算机里的所有内容都是用二进制数字表示的（0和1）</code></li>
<li>没有十进制和二进制相互转化的能力，与计算机交流就很困难</li>
<li><code>转换二进制是计算机科学和编程领域中经常使用的算法</code></li>
</ul>
</li>
<li><p>如何实现十进制转二进制？</p>
<ul>
<li>要<code>把十进制转化成二进制</code>，我们可以将该<code>十进制数字和2整除</code>（二进制是满二进一），直到结果是0为止</li>
<li>举个例子，把十进制的数字10转化成二进制的数字，过程大概是这样</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1744292298734.png" alt="74429229873"></p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ArrayStack</span> <span class="keyword">from</span> <span class="string">&quot;./02.实现栈结构(重构)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decimalToBinary</span>(<span class="params">decimal: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// 1.创建一个栈，用于存放余数</span></span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.使用循环</span></span><br><span class="line">  <span class="comment">// while：不确定循环次数，只知道循环结束条件while循环</span></span><br><span class="line">  <span class="comment">// for：知道循环次数使用for循环</span></span><br><span class="line">  <span class="keyword">while</span> (decimal &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = decimal % <span class="number">2</span>;</span><br><span class="line">    stack.<span class="title function_">push</span>(result);</span><br><span class="line">    decimal = <span class="title class_">Math</span>.<span class="title function_">floor</span>(decimal / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.所有的余数都放在stack中，依次取出即可</span></span><br><span class="line">  <span class="keyword">let</span> binary = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (!stack.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    binary += stack.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> binary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">decimalToBinary</span>(<span class="number">35</span>));  <span class="comment">// 100011</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">decimalToBinary</span>(<span class="number">100</span>)); <span class="comment">// 1100100</span></span><br></pre></td></tr></table></figure>

<h3 id="6-栈面试题-–-有效的括号"><a href="#6-栈面试题-–-有效的括号" class="headerlink" title="6. 栈面试题 – 有效的括号"></a>6. 栈面试题 – 有效的括号</h3><blockquote>
<p>面试题：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效</p>
<p>Leetcode 20：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/description">https://leetcode.cn/problems/valid-parentheses/description</a></p>
</blockquote>
<ul>
<li><p>国内字节、华为、京东都考过的面试题</p>
</li>
<li><p>有效字符串需满足：</p>
<ul>
<li>相同类型的括号一定要对应    “() [] {} ({[ ]})”    —&gt;    true</li>
<li>左括号必须用相同类型的右括号闭合</li>
<li>左括号必须以正确的顺序闭合</li>
<li>每个右括号都有一个对应的相同类型的左括号</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1744292759864.png" alt="74429275986"></p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ArrayStack</span> <span class="keyword">from</span> <span class="string">&quot;./02.实现栈结构(重构)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isValid</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="comment">// 1.创建栈结构</span></span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.遍历s中的所有的括号</span></span><br><span class="line">  <span class="comment">// 碰到左括号，将右括号放入栈里面；碰到右括号，与栈顶元素进行比对</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> c = s[i];</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;(&quot;</span>:</span><br><span class="line">        stack.<span class="title function_">push</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;[&quot;</span>:</span><br><span class="line">        stack.<span class="title function_">push</span>(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">        stack.<span class="title function_">push</span>(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (c !== stack.<span class="title function_">pop</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.栈最后必须为空</span></span><br><span class="line">  <span class="keyword">return</span> stack.<span class="title function_">isEmpty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isValid</span>(<span class="string">&quot;()&quot;</span>));                <span class="comment">// true     </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isValid</span>(<span class="string">&quot;()[]&#123;&#125;&quot;</span>));            <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isValid</span>(<span class="string">&quot;(]&quot;</span>));                <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isValid</span>(<span class="string">&quot;()[]&#123;&#125;(&#123;[]&#125;)&quot;</span>));      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="四-队列结构（Queue）"><a href="#四-队列结构（Queue）" class="headerlink" title="(四) 队列结构（Queue）"></a>(四) 队列结构（Queue）</h2><h3 id="1-认识队列以及特性"><a href="#1-认识队列以及特性" class="headerlink" title="1. 认识队列以及特性"></a>1. 认识队列以及特性</h3><h4 id="1-1-认识队列"><a href="#1-1-认识队列" class="headerlink" title="1.1 认识队列"></a>1.1 认识队列</h4><ul>
<li>受限的线性结构：<ul>
<li>我们已经学习了一种<code>受限的线性结构</code>：栈结构</li>
<li>并且已经知道这种受限的数据结构对于解决某些<code>特定问题</code>，会有<code>特别的效果</code></li>
<li>下面，我们再来学习另外一个受限的数据结构：<code>队列</code></li>
</ul>
</li>
<li>队列(Queue)，它是一种受限的线性表，<code>先进先出</code>(FIFO First In First Out)<ul>
<li>受限之处在于它只允许在队列的<code>前端</code>（front）进行删除操作</li>
<li>而在队列的<code>后端</code>（rear）进行插入操作</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1744545764725.png" alt="74454576472"></p>
<h4 id="1-2-生活中的队列"><a href="#1-2-生活中的队列" class="headerlink" title="1.2 生活中的队列"></a>1.2 生活中的队列</h4><ul>
<li>生活中类似的队列结构<ul>
<li>生活中类似队列的场景就是非常多了</li>
<li>比如在<code>电影院</code>，<code>商场</code>，甚至是<code>厕所</code>排队</li>
<li>优先排队的人，优先处理（买票，结账，WC）</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1744545819504.png" alt="74454581950"></p>
<h4 id="1-3-开发中队列的应用"><a href="#1-3-开发中队列的应用" class="headerlink" title="1.3 开发中队列的应用"></a>1.3 开发中队列的应用</h4><ul>
<li>打印队列<ul>
<li>有五份文档需要打印，这些文档会<code>按照次序放入</code>到<code>打印队列</code>中</li>
<li>打印机会依次从队列中取出文档，<code>优先放入的文档</code>，<code>优先被取出</code>，并且对该文档进行打印</li>
<li>以此类推，直到队列中不再有新的文档</li>
</ul>
</li>
<li>线程队列<ul>
<li>在开发中，为了让任务可以并行处理，通常会<code>开启多个线程</code></li>
<li>但是，我们不能让大量的线程同时运行处理任务（占用过多的资源）</li>
<li>这个时候，如果有需要开启线程处理任务的情况，我们就会使用<code>线程队列</code></li>
<li>线程队列会<code>依照次序</code>来启动线程，并且处理对应的任务</li>
</ul>
</li>
<li>当然队列还有很多其他应用，我们后续的很多算法中也会用到队列（比如二叉树的层序遍历）</li>
<li>队列如何实现呢?<ul>
<li>我们一起来研究一下队列的实现</li>
</ul>
</li>
</ul>
<h3 id="2-实现队列结构封装"><a href="#2-实现队列结构封装" class="headerlink" title="2. 实现队列结构封装"></a>2. 实现队列结构封装</h3><ul>
<li><p>队列的实现和栈一样，有两种方案</p>
<ul>
<li>基于<code>数组</code>实现</li>
<li>基于<code>链表</code>实现（这种方法更好）</li>
</ul>
</li>
<li><p>我们需要创建自己的类，来表示一个队列</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用ts代码，使用ts-node插件编译代码：查看ts-node版本 (ts-node --version)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">data</span>: T[] = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码解析</p>
<ul>
<li>我们创建了一个ArrayQueue的类，用户创建队列的类，并且是一个<code>泛型类</code></li>
<li>在类中，定义了一个变量，这个变量可以用于<code>保存当前队列对象中所有的元素</code>。 (和创建栈非常相似)</li>
<li>这个变量是一个数组类型<ul>
<li>我们之后在队列中添加元素或者删除元素，都是在这个数组中完成的</li>
</ul>
</li>
<li>队列和栈一样，有一些相关的操作方法，通常无论是什么语言，操作都是比较类似的</li>
</ul>
</li>
</ul>
<h3 id="3-队列结构常见方法-完整封装"><a href="#3-队列结构常见方法-完整封装" class="headerlink" title="3. 队列结构常见方法 (完整封装)"></a>3. 队列结构常见方法 (完整封装)</h3><ul>
<li><p>队列有哪些常见的操作呢?</p>
<ul>
<li><code>enqueue(element) </code>：向队列尾部添加一个（或多个）新的项</li>
<li><code>dequeue()</code>：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素</li>
<li><code>front/peek()</code>：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与Stack类的peek方法非常类似）</li>
<li><code>isEmpty()</code>：如果队列中不包含任何元素，返回true，否则返回false</li>
<li><code>size()</code>：返回队列包含的元素个数，与数组的length属性类似</li>
</ul>
</li>
<li><p>现在，我们来实现这些方法</p>
</li>
<li><p>基于<code>数组</code>实现</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01.实现队列结构.ts</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口继承接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IQueue</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">IList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="attr">element</span>: T): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">dequeue</span>(): T | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">IQueue</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">data</span>: T[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enqueue方法：向队列尾部添加一个（或多个）新的项</span></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="attr">element</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dequeue方法：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素</span></span><br><span class="line">  <span class="title function_">dequeue</span>(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// peek方法：返回队列队列的第一的元素，不对队列做任何修改</span></span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isEmpty方法：判断队列是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size方法：返回队列里的元素个数</span></span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-队列面试题-–-击鼓传花"><a href="#4-队列面试题-–-击鼓传花" class="headerlink" title="4. 队列面试题 – 击鼓传花"></a>4. 队列面试题 – 击鼓传花</h3><ul>
<li><code>击鼓传花</code>是一个常见的面试算法题： 使用队列可以非常方便的实现最终的结果</li>
<li><code>原游戏</code>规则：<ul>
<li>班级中玩一个游戏，所有学生围成一圈，从某位同学手里开始向旁边的同学传一束花</li>
<li>这个时候某个人(比如班长)，在击鼓，鼓声停下的一颗，花落在谁手里，谁就出来表演节目</li>
</ul>
</li>
<li><code>修改游戏</code>规则：<ul>
<li>我们来修改一下这个游戏规则</li>
<li>几个朋友一起玩一个游戏，<code>围成一圈</code>，<code>开始数数</code>，<code>数到某个数字</code>的人自动淘汰</li>
<li>最后<code>剩下的这个人</code>会获得胜利，请问最后剩下的是<code>原来在哪一个位置上</code>的人?</li>
</ul>
</li>
<li>封装一个基于队列的函数<ul>
<li>参数：所有参与人的姓名，基于的数字</li>
<li>结果：最终剩下的一人的姓名</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1744549544845.png" alt="74454954484"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ArrayQueue</span> <span class="keyword">from</span> <span class="string">&quot;./01.实现队列结构&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hotPotato</span>(<span class="params">names: <span class="built_in">string</span>[], num: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// 1.创建队列结构</span></span><br><span class="line">  <span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.将所有names加入队列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> names) &#123;</span><br><span class="line">    queue.<span class="title function_">enqueue</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.淘汰规则</span></span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="title function_">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> name = queue.<span class="title function_">dequeue</span>();</span><br><span class="line">      <span class="keyword">if</span> (name) queue.<span class="title function_">enqueue</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 淘汰</span></span><br><span class="line">    queue.<span class="title function_">dequeue</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> queue.<span class="title function_">dequeue</span>()!;  <span class="comment">// !感叹号是类型非空断言</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Camila&quot;</span>, <span class="string">&quot;Ingrid&quot;</span>, <span class="string">&quot;Carl&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hotPotato</span>(names, <span class="number">8</span>));   <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<h3 id="5-队列面试题-约瑟夫环"><a href="#5-队列面试题-约瑟夫环" class="headerlink" title="5. 队列面试题 - 约瑟夫环"></a>5. 队列面试题 - 约瑟夫环</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof">https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof</a></p>
</blockquote>
<h4 id="5-1-什么是约瑟夫环问题（历史）"><a href="#5-1-什么是约瑟夫环问题（历史）" class="headerlink" title="5.1 什么是约瑟夫环问题（历史）"></a>5.1 什么是约瑟夫环问题（历史）</h4><ul>
<li>阿桥问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环<ul>
<li>人们站在一个等待被处决的圈子里</li>
<li>计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行</li>
<li>在跳过指定数量的人之后，处刑下一个人</li>
<li>对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放</li>
<li>在给定数量的情况下，站在第几个位置可以避免被处决？</li>
</ul>
</li>
<li>这个问题是以<code>弗拉维奥·约瑟夫</code>命名的，他是1世纪的一名犹太历史学家<ul>
<li>他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中</li>
<li>他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁</li>
</ul>
</li>
</ul>
<h4 id="5-2-约瑟夫环问题-–-字节、阿里、谷歌等面试题"><a href="#5-2-约瑟夫环问题-–-字节、阿里、谷歌等面试题" class="headerlink" title="5.2 约瑟夫环问题 – 字节、阿里、谷歌等面试题"></a>5.2 约瑟夫环问题 – 字节、阿里、谷歌等面试题</h4><ul>
<li>击鼓传花和约瑟夫环其实是同一类问题，这种问题还会有其他解法（后续讲解）同样的题目在Leetcode上也有<ul>
<li>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数），求出这个圆圈里剩下的最后一个数字</li>
<li>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1744546592932.png" alt="74454659293"></p>
<ul>
<li><p>基于<code>队列</code>实现</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ArrayQueue</span> <span class="keyword">from</span> <span class="string">&quot;./01.实现队列结构&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lastRemaining</span>(<span class="params">n: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="comment">// 1.创建队列结构</span></span><br><span class="line">  <span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    queue.<span class="title function_">enqueue</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.开始淘汰</span></span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="title function_">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">      queue.<span class="title function_">enqueue</span>(queue.<span class="title function_">dequeue</span>()!);</span><br><span class="line">    &#125;</span><br><span class="line">    queue.<span class="title function_">dequeue</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> queue.<span class="title function_">dequeue</span>()!;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lastRemaining</span>(<span class="number">5</span>, <span class="number">3</span>));    <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lastRemaining</span>(<span class="number">10</span>, <span class="number">17</span>));  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基于<code>动态规划</code>实现</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lastRemaining</span>(<span class="params">n: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    position = (position + m) % i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lastRemaining</span>(<span class="number">5</span>, <span class="number">3</span>));    <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lastRemaining</span>(<span class="number">10</span>, <span class="number">17</span>));  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="五-链表结构（LinkedList）"><a href="#五-链表结构（LinkedList）" class="headerlink" title="(五) 链表结构（LinkedList）"></a>(五) 链表结构（LinkedList）</h2><h3 id="1-认识链表以及特性"><a href="#1-认识链表以及特性" class="headerlink" title="1. 认识链表以及特性"></a>1. 认识链表以及特性</h3><h4 id="1-1-链表以及数组的缺点"><a href="#1-1-链表以及数组的缺点" class="headerlink" title="1.1 链表以及数组的缺点"></a>1.1 链表以及数组的缺点</h4><ul>
<li>链表和数组一样，可以用于<code>存储一系列的元素</code>，但是链表和数组的<code>实现机制完全不同</code></li>
<li>这一章中，我们就来学习一下另外一种非常常见的用于存储数据的线性结构：<code>链表</code></li>
<li>数组<ul>
<li>要存储多个元素，数组（或选择链表）可能是<code>最常用</code>的数据结构</li>
<li>我们之前说过，几乎每一种编程语言都有默认实现<code>数组结构</code></li>
</ul>
</li>
<li>但是数组也有很多缺点<ul>
<li>数组的创建通常需要申请一段<code>连续的内存空间</code>(一整块的内存)，并且大小是固定的(大多数编程语言数组都是固定的)，所以当当前数组<code>不能满足容量需求</code>时，需要<code>扩容</code> (一般情况下是申请一个更大的数组，比如2倍。 然后将原数组中的元素复制过去)</li>
<li>而且在<code>数组开头或中间位置插入数据的成本很高</code>，需要<code>进行大量元素的位移</code></li>
<li>尽管JavaScript的Array底层可以帮我们做这些事，但背后的原理依然是这样</li>
</ul>
</li>
</ul>
<h4 id="1-2-链表的优势"><a href="#1-2-链表的优势" class="headerlink" title="1.2 链表的优势"></a>1.2 链表的优势</h4><ul>
<li>要存储多个元素，另外一个选择就是<code>链表</code></li>
<li>但不同于数组，链表中的元素在内存中<code>不必是连续的空间</code><ul>
<li>链表的每个元素由一个存储<code>元素本身的节点</code>和一个<code>指向下一个元素的引用</code>(有些语言称为指针或者链接)组成</li>
</ul>
</li>
<li>相对于数组，链表有一些优点：<ul>
<li><code>内存空间不是必须连续的，</code>可以充分利用计算机的内存，实现灵活的<code>内存动态管理</code></li>
<li>链表不必在创建时就<code>确定大小</code>，并且大小可以<code>无限的延伸</code>下去</li>
<li>链表在<code>插入和删除</code>数据时，<code>时间复杂度</code>可以达到O(1)，相对数组效率高很多</li>
</ul>
</li>
<li>相对于数组，链表有一些缺点：<ul>
<li>链表访问任何一个位置的元素时，都需要<code>从头开始访问 </code>（无法跳过第一个元素访问任何一个元素）</li>
<li><code>无法通过下标直接访问元素</code>，需要从头一个个访问，直到找到对应的元素</li>
</ul>
</li>
</ul>
<h4 id="1-3-链表到底是什么"><a href="#1-3-链表到底是什么" class="headerlink" title="1.3 链表到底是什么?"></a>1.3 链表到底是什么?</h4><ul>
<li>什么是<code>链表</code>呢?<ul>
<li>其实上面我们已经简单的提过了链表的结构，我们这里更加详细的分析一下</li>
<li><code>链表类似于火车</code>：有一个火车头，火车头会连接一个节点，节点上有乘客(类似于数据)，并且这个节点会连接下一个节点，以此类推。</li>
</ul>
</li>
<li>链表的火车结构</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1744552725460.png" alt="74455272546"></p>
<h3 id="2-封装链表的类结构"><a href="#2-封装链表的类结构" class="headerlink" title="2. 封装链表的类结构"></a>2. 封装链表的类结构</h3><ul>
<li><p>我们先来创建一个链表类</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建Node类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建LinkedList类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">head</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">size</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">length</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 封装私有方法</span></span><br><span class="line">  <span class="comment">// 根据position获取到当前的节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getNode</span>(<span class="params">position: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在此处封装链表相关方法</span></span><br><span class="line">  <span class="title function_">append</span>(<span class="params">value</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">traverse</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">position，value</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">position</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">indexOf</span>(<span class="params">value</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params">position，value</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">removeAt</span>(<span class="params">position</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">value</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(linkedList.<span class="property">head</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放入一个模块里面，不然在node环境里面，写class Node会有冲突的</span></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码解析</p>
<ul>
<li>封装一个<code>Node类</code>，用于封装每一个节点上的信息（包括值和指向下一个节点的引用），它是一个泛型类</li>
<li>封装一个<code>LinkedList类</code>，用于表示我们的链表结构。 (和Java中的链表同名，不同Java中的这个类是一个双向链表，在第二阶段中我们也会实现双向链表结构)</li>
<li>链表中我们保存两个属性，一个是<code>链表的长度</code>，一个是<code>链表中第一个节点</code></li>
<li>当然，还有很多链表的操作方法。 我们放在下一节中学习</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1744633123292.png" alt="74463312329"></p>
<h3 id="3-封装链表相关方法"><a href="#3-封装链表相关方法" class="headerlink" title="3. 封装链表相关方法"></a>3. 封装链表相关方法</h3><ul>
<li>我们先来认识一下，链表中应该有哪些<code>常见的操作</code><ul>
<li><code>append(value)</code>：向链表尾部添加一个新的项</li>
<li><code>insert(position，value)</code>：向链表的特定位置插入一个新的项</li>
<li><code>get(position) </code>：获取对应位置的元素</li>
<li><code>indexOf(value)</code>：返回元素在链表中的索引。如果链表中没有该元素则返回-1</li>
<li><code>update(position，value)</code> ：修改某个位置的元素</li>
<li><code>removeAt(position)</code>：从链表的特定位置移除一项</li>
<li><code>remove(value)</code>：从链表中移除一项</li>
<li><code>isEmpty()</code>：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false</li>
<li><code>size()</code>：返回链表包含的元素个数。与数组的length属性类似</li>
</ul>
</li>
<li>整体你会发现操作方法和数组非常类似，因为链表本身就是一种可以代替数组的结构</li>
</ul>
<h4 id="3-1-append方法"><a href="#3-1-append方法" class="headerlink" title="3.1 append方法"></a>3.1 append方法</h4><ul>
<li><p>向链表尾部追加数据可能有两种情况</p>
<ul>
<li><code>链表本身为空</code>，新添加的数据是唯一的节点</li>
<li><code>链表不为空</code>，需要向其他节点后面追加节点</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 追加节点</span></span><br><span class="line"><span class="title function_">append</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.根据value创建一个新节点</span></span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.判断this.head是否为null</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">head</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">while</span> (current.<span class="property">next</span>) &#123;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// current肯定是指向最后一个节点的</span></span><br><span class="line">    current.<span class="property">next</span> = newNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链表的遍历方法（traverse）</p>
<ul>
<li>为了可以方便的看到链表上的每一个元素，我们实现一个遍历链表每一个元素的方法<ul>
<li>这个方法首先将当前结点设置为链表的头结点</li>
<li>然后，在while循环中，我们遍历链表并打印当前结点的数据</li>
<li>在每次迭代中，我们将当前结点设置为其下一个结点，直到遍历完整个链表</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="title function_">traverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">values</span>: T[] = [];</span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    values.<span class="title function_">push</span>(current.<span class="property">value</span>);</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(values.<span class="title function_">join</span>(<span class="string">&quot; -&gt; &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-2-insert方法"><a href="#3-2-insert方法" class="headerlink" title="3.2 insert方法"></a>3.2 insert方法</h4><ul>
<li><p>接下来实现另外一个添加数据的方法：在任意位置插入数据</p>
</li>
<li><p>添加到第一个位置</p>
<ul>
<li>添加到第一个位置，表示新添加的节点是头，就需要将原来的头节点，作为新节点的next</li>
<li>另外这个时候的head应该指向新节点</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1744637407642.png" alt="74463740764"></p>
</li>
<li><p>添加到其他位置</p>
<ul>
<li>如果是添加到其他位置，就需要先找到这个节点位置了</li>
<li>我们通过while循环，一点点向下找。 并且在这个过程中保存上一个节点和下一个节点</li>
<li>找到正确的位置后，将新节点的next指向下一个节点，将上一个节点的next指向新的节点</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1744637425719.png" alt="74463742571"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据位置插入节点：在索引 position 的前面拆入 value</span></span><br><span class="line"><span class="title function_">insert</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="comment">// 1.越界判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.根据value创建新节点</span></span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.判断是否需要插入头部</span></span><br><span class="line">  <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">    newNode.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>; <span class="comment">// current是后一个节点</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">previous</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">// 前一个节点</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">      previous = current;</span><br><span class="line">      current = current!.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// index === position</span></span><br><span class="line">    newNode.<span class="property">next</span> = current;</span><br><span class="line">    previous!.<span class="property">next</span> = newNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历结点的操作重构----------------------------------------</span></span><br><span class="line"><span class="title function_">insert</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="comment">// 1.越界判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.根据value创建新节点</span></span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.判断是否需要插入头部</span></span><br><span class="line">  <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">    newNode.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> previous = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position - <span class="number">1</span>);</span><br><span class="line">    newNode.<span class="property">next</span> = previous!.<span class="property">next</span>;</span><br><span class="line">    previous!.<span class="property">next</span> = newNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-removeAt方法"><a href="#3-3-removeAt方法" class="headerlink" title="3.3 removeAt方法"></a>3.3 removeAt方法</h4><ul>
<li><p>移除数据有两种常见的方式</p>
<ul>
<li>根据位置移除对应的数据</li>
<li>根据数据，先找到对应的位置，再移除数据</li>
</ul>
</li>
<li><p>移除第一项的信息</p>
<ul>
<li>移除第一项时，直接让head指向第二项信息就可以啦</li>
<li>那么第一项信息没有引用指向，就在链表中不再有效，后面会被回收掉</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1744637979143.png" alt="74463797914"></p>
</li>
<li><p>移除其他项的信息</p>
<ul>
<li>移除其他项的信息操作方式是相同的</li>
<li>首先，我们需要通过while循环，找到正确的位置</li>
<li>找到正确位置后，就可以直接将上一项的next指向current项的next，这样中间的项就没有引用指向它，也就不再存在于链表后，会面会被回收掉</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1744637994853.png" alt="74463799485"></p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据位置删除节点</span></span><br><span class="line"><span class="title function_">removeAt</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 1.越界判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.定义变量</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">previous</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.判断是否删除第一个节点</span></span><br><span class="line">  <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = current?.<span class="property">next</span> || <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">      previous = current;</span><br><span class="line">      current = current!.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    previous!.<span class="property">next</span> = current?.<span class="property">next</span> || <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">  <span class="keyword">return</span> current!.<span class="property">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 遍历结点的操作重构----------------------------------------</span></span><br><span class="line"><span class="title function_">removeAt</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 1.越界判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.定义变量</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">current</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.判断是否删除第一个节点</span></span><br><span class="line">  <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = current?.<span class="property">next</span> || <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> previous = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position - <span class="number">1</span>);</span><br><span class="line">    current = previous!.<span class="property">next</span>;</span><br><span class="line">    previous!.<span class="property">next</span> = previous?.<span class="property">next</span>?.<span class="property">next</span> ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">  <span class="keyword">return</span> current?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-get方法"><a href="#3-4-get方法" class="headerlink" title="3.4 get方法"></a>3.4 get方法</h4><ul>
<li>获取对应位置的元素</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对应位置的元素</span></span><br><span class="line"><span class="title function_">get</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 1.越界判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.查找元素</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">    current = current!.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> current!.<span class="property">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历结点的操作重构----------------------------------------</span></span><br><span class="line"><span class="title function_">get</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 1.越界判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.查找元素</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position)?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-遍历结点的操作重构"><a href="#3-5-遍历结点的操作重构" class="headerlink" title="3.5 遍历结点的操作重构"></a>3.5 遍历结点的操作重构</h4><ul>
<li><p>因为遍历结点的操作我们需要经常来做，所以可以进行如下的重构</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装私有方法</span></span><br><span class="line"><span class="comment">// 根据position获取到当前的节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">getNode</span>(<span class="attr">position</span>: <span class="built_in">number</span>): <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">while</span> (index++ &lt; position &amp;&amp; current) &#123;</span><br><span class="line">    current = current?.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-6-update方法"><a href="#3-6-update方法" class="headerlink" title="3.6 update方法"></a>3.6 update方法</h4><ul>
<li>修改某个位置的元素</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改某个位置的元素</span></span><br><span class="line"><span class="title function_">update</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="comment">// 1.越界判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.修改元素</span></span><br><span class="line">  <span class="keyword">const</span> currentNode = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position);</span><br><span class="line">  currentNode!.<span class="property">value</span> = value;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-indexOf方法"><a href="#3-7-indexOf方法" class="headerlink" title="3.7 indexOf方法"></a>3.7 indexOf方法</h4><ul>
<li>我们来完成另一个功能：根据元素获取它在链表中的位置</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据元素获取它在链表中的位置</span></span><br><span class="line"><span class="title function_">indexOf</span>(<span class="attr">value</span>: T): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="comment">// 从第一个节点开始遍历</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">value</span> === value) &#123;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-8-remove方法"><a href="#3-8-remove方法" class="headerlink" title="3.8 remove方法"></a>3.8 remove方法</h4><ul>
<li>有了上面的indexOf方法，我们可以非常方便实现根据元素来删除信息</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据值删除元素</span></span><br><span class="line"><span class="title function_">remove</span>(<span class="attr">value</span>: T): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-9-isEmpty方法"><a href="#3-9-isEmpty方法" class="headerlink" title="3.9 isEmpty方法"></a>3.9 isEmpty方法</h4><ul>
<li>判断链表是否为空</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-链表完整封装代码"><a href="#4-链表完整封装代码" class="headerlink" title="4. 链表完整封装代码"></a>4. 链表完整封装代码</h3><ul>
<li>单向链表（有接口设计）</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ILinkedList</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">IList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">append</span>(<span class="attr">value</span>: T): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">traverse</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">insert</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">removeAt</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">get</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">update</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">indexOf</span>(<span class="attr">value</span>: T): <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">remove</span>(<span class="attr">value</span>: T): T | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建Node类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建LinkedList类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">ILinkedList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">head</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">length</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取链表长度</span></span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回链表第一个元素</span></span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">head</span>?.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装私有方法</span></span><br><span class="line">  <span class="comment">// 根据position获取到当前的节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getNode</span>(<span class="attr">position</span>: <span class="built_in">number</span>): <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position &amp;&amp; current) &#123;</span><br><span class="line">      current = current?.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 追加节点</span></span><br><span class="line">  <span class="title function_">append</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.根据value创建一个新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断this.head是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">head</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="keyword">while</span> (current.<span class="property">next</span>) &#123;</span><br><span class="line">        current = current.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// current肯定是指向最后一个节点的</span></span><br><span class="line">      current.<span class="property">next</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历链表</span></span><br><span class="line">  <span class="title function_">traverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">values</span>: T[] = [];</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      values.<span class="title function_">push</span>(current.<span class="property">value</span>);</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(values.<span class="title function_">join</span>(<span class="string">&quot; -&gt; &quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据位置插入节点</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 1.越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.根据value创建新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.判断是否需要插入头部</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      newNode.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position - <span class="number">1</span>);</span><br><span class="line">      newNode.<span class="property">next</span> = previous!.<span class="property">next</span>;</span><br><span class="line">      previous!.<span class="property">next</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据位置删除节点</span></span><br><span class="line">  <span class="title function_">removeAt</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// 1.越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.定义变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">current</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.判断是否删除第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = current?.<span class="property">next</span> || <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position - <span class="number">1</span>);</span><br><span class="line">      current = previous!.<span class="property">next</span>;</span><br><span class="line">      previous!.<span class="property">next</span> = previous?.<span class="property">next</span>?.<span class="property">next</span> ?? <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line">    <span class="keyword">return</span> current?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取对应位置的元素</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// 1.越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.查找元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position)?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改某个位置的元素</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 1.越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.修改元素</span></span><br><span class="line">    <span class="keyword">const</span> currentNode = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position);</span><br><span class="line">    currentNode!.<span class="property">value</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据元素获取它在链表中的位置</span></span><br><span class="line">  <span class="title function_">indexOf</span>(<span class="attr">value</span>: T): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// 从第一个节点开始遍历</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">value</span> === value) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据值删除元素</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="attr">value</span>: T): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断链表是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放入一个模块里面，不然在node环境里面，写class Node会有冲突的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LinkedList</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-链表常见的面试题"><a href="#5-链表常见的面试题" class="headerlink" title="5. 链表常见的面试题"></a>5. 链表常见的面试题</h3><h4 id="5-1-设计链表-字节、腾讯等公司面试题"><a href="#5-1-设计链表-字节、腾讯等公司面试题" class="headerlink" title="5.1 设计链表 -字节、腾讯等公司面试题"></a>5.1 设计链表 -字节、腾讯等公司面试题</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/</a></p>
</blockquote>
<ul>
<li>设计链表的实现<ul>
<li>您可以选择使用单链表或双链表</li>
<li>单链表中的节点应该具有两个属性：<code>val</code> 和<code>next</code>。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用</li>
<li>如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的</li>
</ul>
</li>
<li>在链表类中实现这些功能 (上面已经实现了)<ul>
<li><code>get(index)</code>：获取链表中第 index 个节点的值。如果索引无效，则返回-1</li>
<li><code>addAtHead(val)</code>：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点</li>
<li><code>addAtTail(val)</code>：将值为 val 的节点追加到链表的最后一个元素</li>
<li><code>addAtIndex(index,val)</code>：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点</li>
<li><code>deleteAtIndex(index)</code>：如果索引 index 有效，则删除链表中的第 index 个节点</li>
</ul>
</li>
</ul>
<h4 id="5-2-删除链表中的节点-–-字节、阿里等公司面试题"><a href="#5-2-删除链表中的节点-–-字节、阿里等公司面试题" class="headerlink" title="5.2 删除链表中的节点 – 字节、阿里等公司面试题"></a>5.2 删除链表中的节点 – 字节、阿里等公司面试题</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-linked-list/description/">https://leetcode.cn/problems/delete-node-in-a-linked-list/description/</a></p>
</blockquote>
<ul>
<li>有一个单链表的 head，我们想删除它其中的一个节点 node<ul>
<li>给你一个需要删除的节点 node</li>
<li>你将 无法访问 第一个节点 head</li>
</ul>
</li>
<li>链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点</li>
<li>删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是<ul>
<li>给定节点的值不应该存在于链表中</li>
<li>链表中的节点数应该减少 1</li>
<li>node 前面的所有值顺序相同</li>
<li>node 后面的所有值顺序相同</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745029038853.png" alt="74502903885"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leetcode 给定的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">ListNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, next?: ListNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next === <span class="literal">undefined</span> ? <span class="literal">null</span> : next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteNode</span>(<span class="params">node: ListNode | <span class="literal">null</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  node!.<span class="property">val</span> = node!.<span class="property">next</span>!.<span class="property">val</span>;</span><br><span class="line">  node!.<span class="property">next</span> = node!.<span class="property">next</span>!.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-反转链表-–-字节、谷歌等面试题"><a href="#5-3-反转链表-–-字节、谷歌等面试题" class="headerlink" title="5.3 反转链表 – 字节、谷歌等面试题"></a>5.3 反转链表 – 字节、谷歌等面试题</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>
</blockquote>
<ul>
<li>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745029888505.png" alt="74502988850"></p>
<ul>
<li><p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
</li>
<li><p>反转链表（栈方式）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leetcode 给定的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">ListNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, next?: ListNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next === <span class="literal">undefined</span> ? <span class="literal">null</span> : next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseList</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 什么情况下链表不需要处理？</span></span><br><span class="line">  <span class="comment">// 1.head本身为null的情况下</span></span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.head本身只有一个节点</span></span><br><span class="line">  <span class="keyword">if</span> (head.<span class="property">next</span> === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组模拟栈结构</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">stack</span>: <span class="title class_">ListNode</span>[] = [];</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">current</span>: <span class="title class_">ListNode</span> | <span class="literal">null</span> = head;</span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    stack.<span class="title function_">push</span>(current);</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依次从栈结构中取出元素，放到一个新的链表中</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">newHead</span>: <span class="title class_">ListNode</span> = stack.<span class="title function_">pop</span>()!;</span><br><span class="line">  <span class="keyword">let</span> newHeadCurrent = newHead;</span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = stack.<span class="title function_">pop</span>()!;</span><br><span class="line">    newHeadCurrent.<span class="property">next</span> = node;</span><br><span class="line">    newHeadCurrent = newHeadCurrent.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 防止循环引用的问题</span></span><br><span class="line">  newHeadCurrent.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反转链表（循环方式）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leetcode 给定的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">ListNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, next?: ListNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next === <span class="literal">undefined</span> ? <span class="literal">null</span> : next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseList</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反转链表结构</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">newHead</span>: <span class="title class_">ListNode</span> | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (head) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">current</span>: <span class="title class_">ListNode</span> | <span class="literal">null</span> = head.<span class="property">next</span>;</span><br><span class="line">    head.<span class="property">next</span> = newHead;</span><br><span class="line">    newHead = head;</span><br><span class="line">    head = current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反转链表（递归方式）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leetcode 给定的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">ListNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, next?: ListNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next === <span class="literal">undefined</span> ? <span class="literal">null</span> : next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseList</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归必有有结束条件</span></span><br><span class="line">  <span class="keyword">const</span> newHead = <span class="title function_">reverseList</span>(head.<span class="property">next</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 让剩下的head节点的next节点的next节点指向head</span></span><br><span class="line">  head.<span class="property">next</span>.<span class="property">next</span> = head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// head本身的next指向null</span></span><br><span class="line">  head.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-算法的复杂度分析"><a href="#6-算法的复杂度分析" class="headerlink" title="6. 算法的复杂度分析"></a>6. 算法的复杂度分析</h3><h4 id="6-1-什么是算法复杂度（现实案例）"><a href="#6-1-什么是算法复杂度（现实案例）" class="headerlink" title="6.1 什么是算法复杂度（现实案例）"></a>6.1 什么是算法复杂度（现实案例）</h4><ul>
<li><p>前面我们已经解释了什么是算法？其实就是解决问题的一系列步骤操作、逻辑</p>
</li>
<li><p>对于同一个问题，我们往往其实有多种解决它的思路和方法，也就是可以采用不同的算法</p>
<ul>
<li>但是<code>不同的算法</code>，其实<code>效率是不一样</code>的</li>
</ul>
</li>
<li><p>举个例子（现实的例子）：在一个庞大的图书馆中，我们需要找一本书</p>
<ul>
<li>在图书已经按照某种方式摆好的情况下（数据结构是固定的）</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745496967069.png" alt="74549696706"></p>
</li>
<li><p>方式一：顺序查找</p>
<ul>
<li>一本本找，直到找到想要的书（累死）</li>
</ul>
</li>
<li><p>方式二：先找分类，分类中找这本书</p>
<ul>
<li>先找到分类，在分类中再顺序或者某种方式查找</li>
</ul>
</li>
<li><p>方式三：找到一台电脑，查找书的位置，直接找到</p>
<ul>
<li>图书馆通常有自己的图书管理系统</li>
<li>利用图书管理系统先找到书的位置，再直接过去找到</li>
</ul>
</li>
</ul>
<h4 id="6-2-什么是算法复杂度（程序案例）"><a href="#6-2-什么是算法复杂度（程序案例）" class="headerlink" title="6.2 什么是算法复杂度（程序案例）"></a>6.2 什么是算法复杂度（程序案例）</h4><ul>
<li><p>我们再具一个程序中的案例：让我们来比较两种不同算法在查找数组中（<code>数组有序</code>）给定元素的时间复杂度</p>
</li>
<li><p>方式一：顺序查找</p>
<ul>
<li>这种算法从头到尾遍历整个数组，依次比较每个元素和给定元素的值</li>
<li>如果找到相等的元素，则返回下标；如果遍历完整个数组都没找到，则返回-1</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sequentSearch</span>(<span class="params">array: <span class="built_in">number</span>[], num: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = array[i];</span><br><span class="line">    <span class="keyword">if</span> (item === num) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sequentSearch</span>(arr, <span class="number">4</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：二分查找</p>
<ul>
<li>这种算法假设数组是有序的，每次选择数组中间的元素与给定元素进行比较</li>
<li>如果相等，则返回下标；如果给定元素比中间元素小，则在数组的左半部分继续查找</li>
<li>如果给定元素比中间元素大，则在数组的右半部分继续查找</li>
<li>这样每次查找都会将查找范围减半，直到找到相等的元素或者查找范围为空</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745497764809.png" alt="74549776480"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">array: <span class="built_in">number</span>[], num: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 1.定义左边索引</span></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.定义右边索引</span></span><br><span class="line">  <span class="keyword">let</span> right = array.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.开始查找</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> midNum = array[mid];</span><br><span class="line">    <span class="keyword">if</span> (midNum === num) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midNum &lt; num) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">binarySearch</span>(arr, <span class="number">4</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-3-顺序查找和二分查找的测试"><a href="#6-3-顺序查找和二分查找的测试" class="headerlink" title="6.3 顺序查找和二分查找的测试"></a>6.3 顺序查找和二分查找的测试</h4><ul>
<li><p>顺序查找：顺序查找算法的时间复杂度是： <code>O(n)</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sequentSearch <span class="keyword">from</span> <span class="string">&quot;./01.查找算法-顺序查找&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_LENGTH</span> = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="variable constant_">MAX_LENGTH</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">_, index</span>) =&gt;</span> index);</span><br><span class="line"><span class="keyword">const</span> num = <span class="variable constant_">MAX_LENGTH</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> startTime = performance.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">const</span> index = <span class="title function_">sequentSearch</span>(nums, num);</span><br><span class="line"><span class="keyword">const</span> endTime = performance.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标元素的索引是：5000000</span></span><br><span class="line"><span class="comment">// 顺序查找消耗的时间：5.1935000000000855ms</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`目标元素的索引是：<span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`顺序查找消耗的时间：<span class="subst">$&#123;endTime - startTime&#125;</span>ms`</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>二分查找：二分查找算法的时间复杂度是： <code>O(log n)</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binarySearch <span class="keyword">from</span> <span class="string">&quot;./02.查找算法-二分查找&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_LENGTH</span> = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="variable constant_">MAX_LENGTH</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">_, index</span>) =&gt;</span> index);</span><br><span class="line"><span class="keyword">const</span> num = <span class="variable constant_">MAX_LENGTH</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> startTime = performance.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">const</span> index = <span class="title function_">binarySearch</span>(nums, num);</span><br><span class="line"><span class="keyword">const</span> endTime = performance.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标元素的索引是：5000000</span></span><br><span class="line"><span class="comment">// 顺序查找消耗的时间：0.15049999999996544ms</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`目标元素的索引是：<span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`顺序查找消耗的时间：<span class="subst">$&#123;endTime - startTime&#125;</span>ms`</span>);</span><br></pre></td></tr></table></figure>

</li>
<li><p>coderwhy老师自己封装的库测试：<code>npm install hy-algokit</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; testOrderSearchEfficiency &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> sequentSearch <span class="keyword">from</span> <span class="string">&quot;./01.查找算法-顺序查找&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> binarySearch <span class="keyword">from</span> <span class="string">&quot;./02.查找算法-二分查找&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_LENGTH</span> = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="variable constant_">MAX_LENGTH</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">_, index</span>) =&gt;</span> index);</span><br><span class="line"><span class="keyword">const</span> num = <span class="variable constant_">MAX_LENGTH</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">testOrderSearchEfficiency</span>(sequentSearch, nums, num);</span><br><span class="line"><span class="title function_">testOrderSearchEfficiency</span>(binarySearch, nums, num);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745500417797.png" alt="74550041779"></p>
<h4 id="6-4-大O表示法（Big-O-notation）"><a href="#6-4-大O表示法（Big-O-notation）" class="headerlink" title="6.4 大O表示法（Big O notation）"></a>6.4 大O表示法（Big O notation）</h4><ul>
<li><p>大O表示法（Big O notation）英文翻译为大O符号（维基百科翻译），中文通常翻译为大O表示法（标记法）</p>
<ul>
<li>这个记号则是在<code>德国数论学家</code>爱德蒙·兰道的著作中才推广的，因此它有时又称为<code>兰道符号（Landau symbols）</code></li>
<li>代表“<code>order of ...”（……阶）</code>的<code>大O</code>，最初是<code>一个大写希腊字母“Ο”（omicron）</code>，现今用的是<code>大写拉丁字母“O”</code></li>
</ul>
</li>
<li><p>大O符号在分析<code>算法效率的时候非常有用</code></p>
<ul>
<li><p>举个例子，解决<code>一个规模为n的问题所花费的时间（或者所需步骤的数目）可以表示为</code>：</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745501143442.png" alt="74550114344"></p>
<ul>
<li>当<code>n增大</code>时，<code>n²项</code>开始<code>占据主导地位，其他各项可以被忽略</code></li>
</ul>
</li>
<li><p>举例说明：当n&#x3D;500</p>
<ul>
<li><p><code>4n²项</code>是<code>2n项</code>的<code>1000倍大</code>，因此在大多数场合下，<code>省略后者对表达式的值的影响将是可以忽略不计</code>的</p>
</li>
<li><p>进一步看，如果我们与任一其他级的表达式比较，<code>n²的系数也是无关紧要</code>的</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745501249482.png" alt="74550124948"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>我们就说该算法<code>具有n²阶（平方阶）的时间复杂度，表示为O(n²)</code></p>
</li>
</ul>
<h4 id="6-5-大O表示法-常见的对数结"><a href="#6-5-大O表示法-常见的对数结" class="headerlink" title="6.5 大O表示法 - 常见的对数结"></a>6.5 大O表示法 - 常见的对数结</h4><ul>
<li>常用的函数阶</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745501428534.png" alt="74550142853"></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1748845724374.png" alt="74884572437"></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745501547807.png" alt="74550154780"></p>
<h4 id="6-6-空间复杂度"><a href="#6-6-空间复杂度" class="headerlink" title="6.6 空间复杂度"></a>6.6 空间复杂度</h4><ul>
<li><p>空间复杂度指的是程序运行过程中所需要的额外存储空间</p>
<ul>
<li>空间复杂度<code>也可以用大O表示法</code>来表示</li>
<li><code>空间复杂度的计算方法与时间复杂度类似</code>，通常需要分析程序中<code>需要额外分配的内存空间，如数组、变量、对象、递归调用</code>等</li>
</ul>
</li>
<li><p>举个栗子?</p>
<ul>
<li>对于一个简单的<code>递归算法</code>来说，每次调用都<code>会在内存中分配新的栈帧，这些栈帧占用了额外的空间</code><ul>
<li>因此，该算法的空间复杂度是O(n)，其中n是递归深度</li>
</ul>
</li>
<li>而对于<code>迭代算法来</code>说，在<code>每次迭代中不需要分配额外的空间</code>，因此<code>其空间复杂度为O(1)</code></li>
</ul>
</li>
<li><p>当空间复杂度很大时，可能会导致内存不足，程序崩溃</p>
</li>
<li><p>在平时进行算法优化时，我们通常会进行如下的考虑：</p>
<ul>
<li>使用尽量少的空间（优化空间复杂度）</li>
<li>使用尽量少的时间（优化时间复杂度）</li>
<li>特定情况下：使用<code>空间换时间</code>或使用<code>时间换空间</code></li>
</ul>
</li>
</ul>
<h3 id="7-数组和链表的对比"><a href="#7-数组和链表的对比" class="headerlink" title="7. 数组和链表的对比"></a>7. 数组和链表的对比</h3><ul>
<li>接下来，我们使用大O表示法来对比一下数组和链表的时间复杂度</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745501593138.png" alt="74550159313"></p>
<ul>
<li><code>数组</code>是一种连续的存储结构，通过下标可以直接访问数组中的任意元素<ul>
<li><code>时间复杂度</code>：对于数组，随机访问时间复杂度为O(1)，插入和删除操作时间复杂度为O(n)</li>
<li><code>空间复杂度</code>：数组需要连续的存储空间，空间复杂度为O(n)</li>
</ul>
</li>
<li><code>链表</code>是一种链式存储结构，通过指针链接起来的节点组成，访问链表中元素需要从头结点开始遍历<ul>
<li><code>时间复杂度</code>：对于链表，随机访问时间复杂度为O(n)，插入和删除操作时间复杂度为O(1)</li>
<li><code>空间复杂度</code>：链表需要为每个节点分配存储空间，空间复杂度为O(n)</li>
</ul>
</li>
<li>在实际开发中，选择使用数组还是链表需要根据具体应用场景来决定<ul>
<li>如果数据量不大，且需要频繁随机访问元素，使用数组可能会更好</li>
<li>如果数据量大，或者需要频繁插入和删除元素，使用链表可能会更好</li>
</ul>
</li>
</ul>
<h2 id="六-哈希表（HashTable）"><a href="#六-哈希表（HashTable）" class="headerlink" title="(六) 哈希表（HashTable）"></a>(六) 哈希表（HashTable）</h2><h3 id="1-哈希表介绍和特性"><a href="#1-哈希表介绍和特性" class="headerlink" title="1. 哈希表介绍和特性"></a>1. 哈希表介绍和特性</h3><h4 id="1-1-哈希表的介绍"><a href="#1-1-哈希表的介绍" class="headerlink" title="1.1 哈希表的介绍"></a>1.1 哈希表的介绍</h4><ul>
<li>哈希表是一种非常重要的数据结构，但是<code>很多学习编程的人</code>一直搞不懂哈希表到底是如何实现的<ul>
<li>在这一章节中，我们就一点点来实现一个自己的哈希表</li>
<li>通过实现来理解哈希表<code>背后的原理</code>和<code>它的优势</code></li>
</ul>
</li>
<li>几乎所有的编程语言都有<code>直接或者间接</code>的应用这种数据结构</li>
<li>哈希表通常是基于<code>数组</code>进行实现的，但是相对于数组，它也很多的优势<ul>
<li>它可以提供非常快速的<code>插入-删除-查找操作</code></li>
<li>无论多少数据，插入和删除值都接近常量的时间：即O(1)的时间复杂度。实际上，只需要<code>几个机器指令</code>即可完成</li>
<li>哈希表的速度比<code>树还要快</code>，基本可以瞬间查找到想要的元素</li>
<li>哈希表相对于树来说编码要容易很多</li>
</ul>
</li>
<li>哈希表相对于数组的一些<code>不足</code><ul>
<li>哈希表中的数据是<code>没有顺序</code>的，所以不能以一种固定的方式(比如从小到大)来遍历其中的元素（没有特殊处理情况下）</li>
<li>通常情况下，哈希表中的key是<code>不允许重复</code>的，不能放置相同的key，用于保存不同的元素</li>
</ul>
</li>
</ul>
<h4 id="1-2-哈希表到底是什么呢？"><a href="#1-2-哈希表到底是什么呢？" class="headerlink" title="1.2 哈希表到底是什么呢？"></a>1.2 哈希表到底是什么呢？</h4><ul>
<li><p>那么，哈希表到底是什么呢？</p>
<ul>
<li>我们只是说了一下它的优势，似乎还是没有说它到底长什么样子？</li>
<li>这也是哈希表不好理解的地方，不像数组和链表，甚至是树，直接画出你就知道它的结构，甚至是原理</li>
<li><code>它的结构就是数组</code>，但是它神奇的地方在于对数组<code>下标值的一种变换</code>，这种<code>变换</code>我们可以使用<code>哈希函数</code>，通过哈希函数可以获取到<code>HashCode</code></li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745590601946.png" alt="74559060194"></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745590764586.png" alt="74559076458"></p>
<ul>
<li>不着急，我们慢慢来认识它到底是什么</li>
</ul>
</li>
<li><p>我们通过二个案例，案例需要你挑选某种数据结构，而你会发现最好的选择就是哈希表</p>
<ul>
<li>案例一：公司使用一种数据结构来保存所有员工</li>
<li>案例二：使用一种数据结构存储单词信息，比如有50000个单词。找到单词后每个单词有自己的翻译&amp;读音&amp;应用等等</li>
</ul>
</li>
</ul>
<h4 id="1-3-案例一：公司员工存储"><a href="#1-3-案例一：公司员工存储" class="headerlink" title="1.3 案例一：公司员工存储"></a>1.3 案例一：公司员工存储</h4><ul>
<li>案例介绍：<ul>
<li>假如一家公司有1000个员工，现在我们需要将这些员工的信息使用某种数据结构来保存起来</li>
<li>你会采用什么数据结构呢？</li>
</ul>
</li>
<li>方案一：数组<ul>
<li>一种方案是按照顺序将所有的员工依次存入一个<code>长度为1000的数组</code>中</li>
<li><code>每个员工的信息都保存在数组的某个位置上</code></li>
<li>但是我们要<code>查看某个具体员工的信息怎么办</code>呢？<code>一个个找吗？不太好找</code></li>
<li><code>数组最大的优势是什么</code>？通过<code>下标值去获取信息</code></li>
<li>所以为了可以通过数组快速定位到某个员工，最好给员工信息中添加一个<code>员工编号(工号)</code>，而编号对应的就是<code>员工的下标值</code></li>
<li>当查找某个员工的信息时，通过员工编号可以快速定位到员工的信息位置</li>
</ul>
</li>
<li>方案二：链表<ul>
<li>链表对应插入和删除数据有一定的优势</li>
<li>但是对于获取员工的信息，每次都必须从头遍历到尾，这种方式显然不是特别适合我们这里</li>
</ul>
</li>
<li>最终方案：<ul>
<li>这样看<code>最终方案似乎就是数组</code>了。但是数组还是有缺点，什么缺点呢？</li>
<li>但是如果我们<code>只知道员工的姓名</code>，比如why，但是<code>不知道why的员工编号</code>，你怎么办呢？</li>
</ul>
</li>
<li>只能线性查找？效率非常的低<ul>
<li>能不能有一种办法，让<code>why的名字和它的员工编号</code>产生直接的关系呢？</li>
<li>也就是通过why这个名字，我们就能<code>获取到它的索引值</code>，而再通过索引值我就能获取到why的信息呢？</li>
<li>这样的方案已经存在了，就是使用哈希函数，让<code>某个key的信息</code>和<code>索引值对应起来</code></li>
</ul>
</li>
</ul>
<h4 id="1-4-案例二：50000个单词的存储"><a href="#1-4-案例二：50000个单词的存储" class="headerlink" title="1.4 案例二：50000个单词的存储"></a>1.4 案例二：50000个单词的存储</h4><ul>
<li>案例介绍：<ul>
<li>使用<code>一种数据结构存储单词信息</code>，比如有<code>50000个单词</code></li>
<li>找到单词后<code>每个单词有自己的翻译&amp;读音&amp;应用</code>等等</li>
</ul>
</li>
<li>方案一：数组？<ul>
<li>这个案例<code>更加明显能感受到数组的缺陷</code></li>
<li>我拿到一个单词 <code>Iridescent</code>，我想知道这个单词的<code>翻译/读音/应用</code></li>
<li>怎么可以<code>从数组中查到这个单词的位置</code>呢？</li>
<li>线性查找？50000次比较？</li>
<li>如果你使用数组来实现这个功能，效率会非常非常低，而且你一定没有学习过数据结构</li>
</ul>
</li>
<li>方案二：链表？<ul>
<li>不需要考虑了吧？</li>
</ul>
</li>
<li>方案三：有没有一种方案，可以<code>将单词转成数组的下标值</code>呢？<ul>
<li>如果单词转成数组的下标，以后我们要查找某个单词的信息，直接<code>按照下标值一步即可访问到想要的元素</code></li>
</ul>
</li>
</ul>
<h3 id="2-数据的哈希化过程"><a href="#2-数据的哈希化过程" class="headerlink" title="2. 数据的哈希化过程"></a>2. 数据的哈希化过程</h3><h4 id="2-1-字母转数字的方案一"><a href="#2-1-字母转数字的方案一" class="headerlink" title="2.1 字母转数字的方案一"></a>2.1 字母转数字的方案一</h4><ul>
<li>似乎所有的案例都指向了一目标：<code>将字符串转成下标值</code></li>
<li>但是，怎样才能将一个字符串转成数组的下标值呢？<ul>
<li><code>单词/字符串</code>转<code>下标值</code>，其实就是<code>字母/文字</code>转<code>数字</code></li>
<li>怎么转？</li>
</ul>
</li>
<li>现在我们需要设计一种方案，可以将<code>单词</code>转成<code>适当的下标值</code><ul>
<li>其实计算机中有<code>很多的编码方案</code>就是用数字代替单词的字符。就是字符编码。(常见的<code>字符编码</code>？)</li>
<li>比如<code>ASCII编码</code>：a是97，b是98，依次类推122代表z</li>
<li>我们也可以设计一个<code>自己的编码系统</code>，比如<code>a是1，b是2，c是3，依次类推，z是26</code></li>
<li>当然我们可以加上<code>空格用0代替</code>，就是<code>27个字符</code>(不考虑大写问题)</li>
<li>但是，有了编码系统后，一个单词如何转成数字呢？</li>
</ul>
</li>
<li>方案一：数字相加<ul>
<li>一种转换单词的<code>简单方案</code>就是把单词每个字符的编码求和</li>
<li>例如单词<code>cats转成数字</code>：3 + 1 + 20 + 19 &#x3D; 43，那么43就作为cats单词的下标存在数组中</li>
</ul>
</li>
<li>问题：按照这种方案有一个很明显的问题就是<code>很多单词</code>最终的下标可能<code>都是43</code><ul>
<li>比如was&#x2F;tin&#x2F;give&#x2F;tend&#x2F;moan&#x2F;tick等等</li>
<li>我们知道数组中<code>一个下标值</code>位置<code>只能存储一个数据</code></li>
<li>如果存入后来的数据，必然会造成<code>数据的覆盖</code></li>
<li>一个下标存储这么多单词显然是<code>不合理</code>的</li>
<li>虽然后面的方案也会出现，但是要尽量避免</li>
</ul>
</li>
</ul>
<h4 id="2-2-字母转数字的方案二"><a href="#2-2-字母转数字的方案二" class="headerlink" title="2.2 字母转数字的方案二"></a>2.2 字母转数字的方案二</h4><ul>
<li><p>方案二：幂的连乘</p>
<ul>
<li>现在，我们想通过一种算法，让cats转成数字后<code>不那么普通</code></li>
<li><code>数字相加</code>的方案就有些<code>过于普通</code>了</li>
<li>有一种方案就是使用<code>幂的连乘</code>，什么是幂的连乘呢？</li>
<li>其实我们平时使用的<code>大于10的数字</code>，可以用一种<code>幂的连乘来表示</code>它的唯一性，比如：7654 &#x3D; 7*10³ + 6*10² + 5*10 + 4</li>
<li>我们的单词也可以使用这种方案来表示：比如cats &#x3D; 3*27³ + 1*27² + 20*27 + 19&#x3D; 60337</li>
<li>这样得到的数字可以<code>基本</code>保证它的<code>唯一性</code>，不会和别的单词重复</li>
</ul>
</li>
<li><p>问题：如果一个单词是zzzzzzzzzz(一般英文单词不会超过10个字符)。那么得到的数字超过7000000000000</p>
<ul>
<li>数组可以表示<code>这么大的下标值</code>吗？</li>
<li>而且就算能创建这么大的数组，事实上有很多是无效的单词</li>
<li><code>创建这么大的数组是没有意义</code>的，会造成很多空间的浪费</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745637088216.png" alt="74563708821"></p>
</li>
<li><p>两种方案总结：</p>
<ul>
<li>第一种方案(把数字相加求和)产生的<code>数组下标太少</code></li>
<li>第二种方案(与27的幂相乘求和)产生的<code>数组下标又太多</code></li>
</ul>
</li>
</ul>
<h4 id="2-3-下标的压缩算法"><a href="#2-3-下标的压缩算法" class="headerlink" title="2.3 下标的压缩算法"></a>2.3 下标的压缩算法</h4><ul>
<li>现在需要一种<code>压缩方法</code>，把幂的连乘方案系统中得到的<code>巨大整数范围</code>压缩到<code>可接受的数组范围</code>中</li>
<li>对于英文词典，多大的数组才合适呢？<ul>
<li>如果只有<code>50000个单词</code>，可能<code>会定义一个长度为50000的数组</code></li>
<li>但是实际情况中，往往需要<code>更大的空间</code>来存储这些单词。因为我们<code>不能保证单词会映射到每一个位置</code></li>
<li>比如<code>两倍的大小：100000</code></li>
</ul>
</li>
<li>如何压缩呢？<ul>
<li>现在，就找一种方法，把0到超过7000000000000的范围，<code>压缩</code>为从0到100000</li>
<li>有一种简单的方法就是使用<code>取余操作符</code>，它的作用是得到一个数被另外一个数整除后的<code>余数</code></li>
</ul>
</li>
<li>取余操作的实现：<ul>
<li>为了看到这个方法如何工作，我们先来看一个<code>小点的数字范围</code>压缩到一个<code>小点的空间</code>中</li>
<li>假设把从0~199的数字，比如使用<code>largeNumber</code>代表，压缩为从0到9的数字，比如使用<code>smallRange</code>代表</li>
<li>下标值的结果：index &#x3D; largeNumber % smallRange</li>
<li>当一个数被10整除时，余数一定在0~9之间</li>
<li>比如13%10&#x3D;3，157%10&#x3D;7</li>
<li>当然，这<code>中间还是会有重复，不过重复的数量明显变小</code>了。因为我们的数组是100000，而只有50000个单词</li>
<li>就好比，你在0~199中间选取5个数字，放在这个长度为10的数组中，也会重复，但是重复的概率非常小。(后面我们会讲到真的发生重复了应该怎么解决)</li>
</ul>
</li>
</ul>
<h4 id="2-4-哈希表的一些概念"><a href="#2-4-哈希表的一些概念" class="headerlink" title="2.4 哈希表的一些概念"></a>2.4 哈希表的一些概念</h4><ul>
<li>认识了上面的内容，相信你应该懂了哈希表的原理了，我们来看看几个概念：<ul>
<li><strong>哈希化</strong>：将<code>大数字</code>转化成<code>数组范围内下标</code>的过程，我们就称之为<code>哈希化</code></li>
<li><strong>哈希函数</strong>：通常我们会将<code>单词</code>转成<code>大数字</code>，<code>大数字</code>在进行<code>哈希化</code>的代码实现放在一个函数中，这个函数我们称为<code>哈希函数</code></li>
<li><strong>哈希表</strong>：最终将数据插入到的这个<code>数组</code>，对整个<code>结构的封装</code>，我们就称之为是一个<code>哈希表</code></li>
</ul>
</li>
<li>但是，我们还有问题需要解决：<ul>
<li>虽然，我们在一个100000的数组中，放50000个单词已经足够</li>
<li>但是通过哈希化后的下标值依然可能会重复，如何解决这种重复的问题呢？</li>
</ul>
</li>
</ul>
<h3 id="3-地址冲突解决方案"><a href="#3-地址冲突解决方案" class="headerlink" title="3. 地址冲突解决方案"></a>3. 地址冲突解决方案</h3><h4 id="3-1-什么是冲突？"><a href="#3-1-什么是冲突？" class="headerlink" title="3.1 什么是冲突？"></a>3.1 什么是冲突？</h4><ul>
<li>尽管50000个单词，我们使用了100000个位置来存储，并且通过一种相对比较好的哈希函数来完成。但是依然有<code>可能会发生冲突</code><ul>
<li>比如melioration这个单词，通过哈希函数得到它数组的下标值后，发现那个位置上已经存在一个单词demystify</li>
<li>因为它经过哈希化后和melioration得到的下标实现相同的</li>
</ul>
</li>
<li>这种情况我们成为冲突</li>
<li>虽然我们不希望这种情况发生，当然更希望每个下标对应一个数据项，但是通常这是不可能的</li>
<li>冲突<code>不可避免</code>，我们只能解决<code>冲突</code></li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745637712619.png" alt="74563771261"></p>
<ul>
<li>就像之前0~199的数字选取5个放在长度为10的单元格中<ul>
<li>如果我们随机选出来的是33，82，11，45，90，那么最终它们的位置会是3-2-1-5-0，没有发生冲突</li>
<li>但是如果其中有一个33，还有一个73呢？还是发生了冲突</li>
</ul>
</li>
<li>我们需要针对 <code>这种冲突</code> 提出一些<code>解决方案</code><ul>
<li>虽然冲突的<code>可能性比较小</code>，你依然需要<code>考虑到这种情况</code></li>
<li>以便发生的时候进行对应的<code>处理代码</code></li>
</ul>
</li>
<li>如何解决这种冲突呢？常见的情况有两种方案<ul>
<li><code>链地址法</code></li>
<li><code>开放地址法</code></li>
</ul>
</li>
</ul>
<h4 id="3-2-链地址法"><a href="#3-2-链地址法" class="headerlink" title="3.2 链地址法"></a>3.2 链地址法</h4><h5 id="3-2-1-链地址法（一定要理解）"><a href="#3-2-1-链地址法（一定要理解）" class="headerlink" title="3.2.1 链地址法（一定要理解）"></a>3.2.1 链地址法（一定要理解）</h5><ul>
<li><p>链地址法是一种比较常见的解决冲突的方案。(也称为拉链法)</p>
<ul>
<li>其实，如果你理解了为什么产生冲突，看到图后就可以立马理解链地址法是什么含义了</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745637827395.png" alt="74563782739"></p>
</li>
</ul>
<h5 id="3-2-2-链地址法解析"><a href="#3-2-2-链地址法解析" class="headerlink" title="3.2.2 链地址法解析"></a>3.2.2 链地址法解析</h5><ul>
<li>图片解析：<ul>
<li>从图片中我们可以看出，链地址法解决冲突的办法是<code>每个数组单元</code>中存储的不再是<code>单个数据</code>，而是一个<code>链条</code></li>
<li>这个链条使用什么数据结构呢？常见的是<code>数组或者链表</code></li>
<li>比如是<code>链表</code>，也就是每个数组单元中存储着一个链表。一旦发现重复，将重复的元素<code>插入</code>到链表的<code>首端或者末端</code>即可</li>
<li>当查询时，先根据哈希化后的下标值找到对应的位置，再取出链表，依次查询找寻找的数据</li>
</ul>
</li>
<li>数组还是链表呢？<ul>
<li>数组或者链表在这里其实都可以，<code>效率上也差不多</code></li>
<li>因为根据哈希化的index找出这个数组或者链表时，通常就会使用<code>线性查找</code>，这个时候数组和链表的效率是差不多的</li>
<li>当然在某些实现中，会将新插入的数据放在<code>数组或者链表的最前面</code>，因为觉得<code>新插入的数据</code>用于<code>取出的可能性更大</code></li>
<li><code>这种情况最好采用链表</code>，因为数组在首位插入数据是需要所有其他项后移的，链表就没有这样的问题</li>
<li>当然，我觉得出于这个也看<code>业务需求</code>，不见得新的数据就访问次数会更多：比如我们微信新添加的好友，可能是刚认识的，联系的频率不见得比我们的老朋友更多，甚至新加的只是聊一两句</li>
<li>所以，这里个人觉得选择<code>数组或者链表</code>都是可以的</li>
</ul>
</li>
</ul>
<h4 id="3-3-开放地址法"><a href="#3-3-开放地址法" class="headerlink" title="3.3 开放地址法"></a>3.3 开放地址法</h4><h5 id="3-3-1-开放地址法"><a href="#3-3-1-开放地址法" class="headerlink" title="3.3.1 开放地址法"></a>3.3.1 开放地址法</h5><ul>
<li>开放地址法的主要工作方式是<code>寻找空白的单元格</code>来添加重复的数据</li>
<li>我们还是通过图片来了解开放地址法的工作方式</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745638315738.png" alt="74563831573"></p>
<ul>
<li>图片解析：<ul>
<li>从图片的文字中我们可以了解到</li>
<li>开放地址法其实就是要<code>寻找空白的位置</code>来放置冲突的数据项</li>
</ul>
</li>
<li>但是探索这个位置的方式不同，有三种方法：<ul>
<li><code>线性探测</code></li>
<li><code>二次探测</code></li>
<li><code>再哈希法</code></li>
</ul>
</li>
</ul>
<h5 id="3-3-2-线性探测"><a href="#3-3-2-线性探测" class="headerlink" title="3.3.2 线性探测"></a>3.3.2 线性探测</h5><ul>
<li>线性探测非常好理解：线性的查找空白的单元</li>
<li>插入的32：<ul>
<li>经过哈希化得到的index&#x3D;2，但是在插入的时候，发现该位置已经有了82。怎么办呢？</li>
<li>线性探测就是从<code>index位置+1</code>开始一点点查找<code>合适的位置</code>来放置32，什么是合适的位置呢？</li>
<li><code>空的位置就是合适的位置</code>，在我们上面的例子中就是index&#x3D;3的位置，这个时候32就会放在该位置</li>
</ul>
</li>
<li>查询32呢？<ul>
<li>查询32和插入32比较相似</li>
<li>首先经过哈希化得到index&#x3D;2，比如2的位置结果和查询的数值是否相同，相同那么就直接返回</li>
<li>不相同呢？线性查找，从index位置+1开始查找和32一样的</li>
<li>这里有一个特别需要注意的地方：如果32的位置我们之前<code>没有插入</code>，是否将整个哈希表查询一遍来确定32存不存在吗？</li>
<li>当然不是，查询过程有一个约定，就是查询到<code>空位置</code>，<code>就停止</code></li>
<li>因为查询到这里有空位置，32之前不可能跳过空位置去其他的位置</li>
</ul>
</li>
</ul>
<p><strong>线性探测的问题：</strong></p>
<ul>
<li>删除32呢？<ul>
<li>删除操作和插入查询比较类似，但是也有一个<code>特别注意点</code></li>
<li>注意：删除操作一个数据项时，<code>不可以</code>将这个位置下标的内容<code>设置为null</code>，为什么呢？</li>
<li>因为将它设置为null可能会影响我们之后查询其他操作，所以通常<code>删除一个位置的数据项</code>时，我们可以<code>将它进行特殊处理</code>(比如设置为-1)</li>
<li>当我们之后看到-1位置的数据项时，就知道查询时要<code>继续查询</code>，但是插入时这个位置可以放置数据</li>
</ul>
</li>
<li>线性探测的问题：<ul>
<li>线性探测有一个比较严重的问题，就是聚集。什么是聚集呢？</li>
<li>比如我在没有任何数据的时候，插入的是22-23-24-25-26，那么意味着下标值：2-3-4-5-6的位置都有元素</li>
<li>这种<code>一连串填充单元</code>就叫做<code>聚集</code></li>
<li>聚集会影响哈希表的<code>性能</code>，无论是插入&#x2F;查询&#x2F;删除都会影响</li>
<li>比如我们插入一个32，会发现<code>连续的单元</code>都<code>不允许</code>我们放置数据，并且在这个过程中我们需要探索多次</li>
<li>二次探测可以解决一部分这个问题，我们一起来看一看</li>
</ul>
</li>
</ul>
<h5 id="3-3-3-二次探测"><a href="#3-3-3-二次探测" class="headerlink" title="3.3.3 二次探测"></a>3.3.3 二次探测</h5><ul>
<li>我们刚才谈到，线性探测存在的问题：<ul>
<li>如果之前的数据是<code>连续插入</code>的，那么新插入的一个数据可能需要<code>探测很长的距离</code></li>
</ul>
</li>
<li>二次探测在线性探测的基础上进行了优化：<ul>
<li>二次探测主要优化的是<code>探测时的步长</code>，什么意思呢？</li>
<li><code>线性探测</code>，我们可以看成是<code>步长为1</code>的探测，比如从下标值x开始，那么线性测试就是x+1，x+2，x+3依次探测</li>
<li><code>二次探测</code>，对步长做了优化，比如从下标值x开始，x+1²，x+2²，x+3²</li>
<li>这样就可以<code>一次性探测比较长的距离</code>，比避免那些聚集带来的影响</li>
</ul>
</li>
<li>二次探测的问题：<ul>
<li>但是二次探测依然存在问题，比如我们连续插入的是32-112-82-2-192，那么它们依次累加的时候步长的相同的</li>
<li>也就是这种情况下会造成<code>步长不一样的一种聚集</code>。还是会影响效率。(当然这种可能性相对于<code>连续的数字</code>会小一些)</li>
<li>怎么根本解决这个问题呢？让<code>每个人的步长不一样</code>，一起来看看<code>再哈希法</code>吧</li>
</ul>
</li>
</ul>
<h5 id="3-3-4-再哈希法"><a href="#3-3-4-再哈希法" class="headerlink" title="3.3.4 再哈希法"></a>3.3.4 再哈希法</h5><ul>
<li>为了消除线性探测和二次探测中无论步长+1还是步长+平法中存在的问题，还有一种最常用的解决方案: <code>再哈希法</code></li>
<li>再哈希法：<ul>
<li>二次探测的算法产生的探测序列步长是固定的: 1, 4, 9, 16, 依次类推</li>
<li>现在需要一种方法: 产生一种<code>依赖关键字的探测序列</code>， 而不是每个关键字都一样</li>
<li>那么，<code>不同的关键字</code>即使映射到<code>相同的数组下标</code>， 也可以使用不同的探测序列</li>
<li>再哈希法的做法就是：把关键字用另外一个哈希函数，<code>再做一次哈希化</code>，用这次哈希化的<code>结果作为步长</code></li>
<li>对于<code>指定的关键字</code>，<code>步长</code>在整个探测中是<code>不变</code>的，不过<code>不同的关键字</code>使用<code>不同的步长</code></li>
</ul>
</li>
<li>第二次哈希化需要具备如下特点：<ul>
<li>和<code>第一个哈希函数不同 </code>(不要再使用上一次的哈希函数了, 不然结果还是原来的位置)</li>
<li><code>不能输出为0</code>(否则，将没有步长，每次探测都是原地踏步，算法就进入了死循环)</li>
</ul>
</li>
<li>其实，我们不用费脑细胞来设计了，<code>计算机专家</code>已经设计出一种工作很好的哈希函数：<ul>
<li><code>stepSize = constant - (key % constant)</code></li>
<li>其中constant是质数，且小于数组的容量</li>
<li>例如：stepSize &#x3D; 5 - (key % 5)，满足需求，并且结果不可能为0</li>
</ul>
</li>
</ul>
<h4 id="3-4-哈希化的效率"><a href="#3-4-哈希化的效率" class="headerlink" title="3.4 哈希化的效率"></a>3.4 哈希化的效率</h4><ul>
<li>哈希表中执行插入和搜索操作效率是非常高的<ul>
<li>如果<code>没有产生冲突</code>，那么效率就会更高</li>
<li>如果<code>发生冲突</code>，存取时间就依赖后来的探测长度</li>
<li>平均探测长度以及平均存取时间，取决于<code>填装因子</code>，随着填装因子变大，探测长度也越来越长</li>
<li>随着填装因子变大，效率下降的情况，在不同开放地址法方案中比链地址法更严重，所以我们来对比一下他们的效率，再决定我们选取的方案</li>
</ul>
</li>
<li>在分析效率之前，我们先了解一个概念：<code>装填因子</code><ul>
<li>装填因子表示当前哈希表中已经<code>包含的数据项</code>和<code>整个哈希表长度</code>的<code>比值</code></li>
<li><code>装填因子 = 总数据项 / 哈希表长度</code></li>
<li><code>开放地址法的装填因子</code>最大是多少呢？<code>1</code>，因为它必须寻找到空白的单元才能将元素放入</li>
<li><code>链地址法的装填因子</code>呢？可以大于<code>1</code>，因为拉链法可以无限的延伸下去，只要你愿意。(当然后面效率就变低了)</li>
</ul>
</li>
</ul>
<h5 id="3-4-1-线性探测效率"><a href="#3-4-1-线性探测效率" class="headerlink" title="3.4.1 线性探测效率"></a>3.4.1 线性探测效率</h5><ul>
<li>下面的等式显示了线性探测时，探测序列(P)和填装因子(L)的关系</li>
<li>公式来自于Knuth(算法分析领域的专家，现代计算机的先驱人物)，这些公式的推导自己去看了一下，确实有些繁琐，这里不再给出推导过程，仅仅说明它的效率</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745662308494.png" alt="74566230849"></p>
<ul>
<li>图片解析：<ul>
<li>当填装因子是1&#x2F;2时，成功的搜索需要1.5次比较，不成功的搜索需要2.5次</li>
<li>当填装因子为2&#x2F;3时，分别需要2.0次和5.0次比较</li>
<li>如果填装因子更大，比较次数会非常大</li>
<li>应该使填装因子保持在2&#x2F;3以下，最好在1&#x2F;2以下，另一方面，填装因子越低，对于给定数量的数据项，就需要越多的空间</li>
<li>实际情况中，最好的填装因子取决于存储效率和速度之间的平衡，随着填装因子变小，存储效率下降，而速度上升</li>
</ul>
</li>
</ul>
<h5 id="3-4-2-二次探测和再哈希化效率"><a href="#3-4-2-二次探测和再哈希化效率" class="headerlink" title="3.4.2 二次探测和再哈希化效率"></a>3.4.2 二次探测和再哈希化效率</h5><ul>
<li>二次探测和再哈希法的性能相当。它们的性能比线性探测略好</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745662585587.png" alt="74566258558"></p>
<ul>
<li>图片解析：<ul>
<li>当填装因子是0.5时，成功和不成的查找平均需要2次比较</li>
<li>当填装因子为2&#x2F;3时，分别需要2.37和3.0次比较</li>
<li>当填装因子为0.8时，分别需要2.9和5.0次</li>
<li>因此对于较高的填装因子，对比线性探测，二次探测和再哈希法还是可以忍受的</li>
</ul>
</li>
</ul>
<h5 id="3-4-3-链地址法效率"><a href="#3-4-3-链地址法效率" class="headerlink" title="3.4.3 链地址法效率"></a>3.4.3 链地址法效率</h5><ul>
<li><p>链地址法的效率分析有些不同，一般来说比开放地址法简单。我们来分析一下这个公式应该是怎么样的</p>
<ul>
<li>假如哈希表包含arraySize个数据项，每个数据项有一个链表，在表中一共包含N个数据项</li>
<li>那么，平均起来每个链表有多少个数据项呢？非常简单，<code>N / arraySize</code></li>
<li>有没有发现这个公式有点眼熟？其实就是<code>装填因子</code></li>
</ul>
</li>
<li><p>OK，那么我们现在就可以求出查找成功和不成功的次数了</p>
<ul>
<li>成功可能只需要查找链表的一半即可：<code>1 + loadFactor/2</code></li>
<li>不成功呢？可能需要将整个链表查询完才知道不成功：<code>1 + loadFactor</code></li>
</ul>
</li>
<li><p>经过上面的比较我们可以发现，<strong>链地址法相对来说效率是好于开放地址法的</strong></p>
</li>
<li><p>所以在真实开发中，使用<code>链地址法</code>的情况较多</p>
<ul>
<li>因为它不会因为添加了某元素后性能急剧下降</li>
<li>比如在Java的HashMap中使用的就是链地址法</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1745662712206.png" alt="74566271220"></p>
</li>
</ul>
<h3 id="4-哈希函数代码实现"><a href="#4-哈希函数代码实现" class="headerlink" title="4. 哈希函数代码实现"></a>4. 哈希函数代码实现</h3><h4 id="4-1-哈希函数"><a href="#4-1-哈希函数" class="headerlink" title="4.1 哈希函数"></a>4.1 哈希函数</h4><ul>
<li>讲了很久的哈希表理论知识，你有没有发现在整个过程中，一个非常重要的东西：<code>哈希函数</code>呢？</li>
<li>好的哈希函数应该尽可能让计算的过程变得简单，提高计算的效率<ul>
<li>哈希表的主要<code>优点是它的速度</code>，所以在速度上不能满足，那么就达不到设计的目的了</li>
<li>提高速度的一个办法就是让哈希函数中<code>尽量少的有乘法和除法</code>。因为它们的性能是比较低的</li>
</ul>
</li>
<li>设计好的哈希函数应该具备哪些优点呢？<ul>
<li><code>快速的计算</code><ul>
<li>哈希表的优势就在于效率，所以快速获取到对应的hashCode非常重要</li>
<li>我们需要通过快速的计算来获取到元素对应的hashCode</li>
</ul>
</li>
<li><code>均匀的分布</code><ul>
<li>哈希表中，无论是链地址法还是开放地址法，当多个元素映射到同一个位置的时候，都会影响效率</li>
<li>所以，优秀的哈希函数应该尽可能将元素映射到不同的位置，让元素在哈希表中均匀的分布</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-2-快速计算：霍纳法则"><a href="#4-2-快速计算：霍纳法则" class="headerlink" title="4.2 快速计算：霍纳法则"></a>4.2 快速计算：霍纳法则</h4><ul>
<li>在前面，我们计算哈希值的时候使用的方式<ul>
<li>cats &#x3D; 3*27³ + 1*27² + 20*27 + 19 &#x3D; 60337</li>
</ul>
</li>
<li>这种方式是<code>直观的计算结果</code>，那么这种计算方式会进行<code>几次乘法几次加法</code>呢？<ul>
<li>当然，我们可能不止4项，可能有更多项</li>
<li>我们抽象一下，这个表达式其实是一个多项式：a(n)x^n + a(n-1)x^(n-1) + …+ a(1)x + a(0)</li>
</ul>
</li>
<li>现在问题就变成了多项式<code>有多少次乘法和加法</code>：<ul>
<li>乘法次数 (不考虑前面的系数)：n＋(n－1)＋…＋1＝n(n+1)&#x2F;2</li>
<li>加法次数：n次</li>
<li>O(N²)</li>
</ul>
</li>
<li>多项式的优化：<code>霍纳法则</code><ul>
<li>解决这类求值问题的高效算法–<code>霍纳法则</code>。在中国，霍纳法则也被称为<code>秦九韶算法</code></li>
</ul>
</li>
<li>通过如下变换我们可以得到一种<code>快得多</code>的算法，即<ul>
<li>Pn(x) &#x3D;  anx^n + a(n－1)x^(n-1) + … + a1x + a0 &#x3D; ((…(((anx +an－1)x+an－2)x+ an－3)…)x+a1)x+a0</li>
<li>这种求值的方式我们称为<code>霍纳法则</code></li>
</ul>
</li>
<li>变换后，我们需要<code>多少次乘法，多少次加法</code>呢？<ul>
<li>乘法次数：N次</li>
<li>加法次数：N次</li>
<li>如果使用大O表示时间复杂度的话，我们直接从 O(N²) 降到了 O(N)</li>
</ul>
</li>
</ul>
<h4 id="4-3-均匀分布"><a href="#4-3-均匀分布" class="headerlink" title="4.3 均匀分布"></a>4.3 均匀分布</h4><ul>
<li>均匀的分布<ul>
<li>在设计哈希表时，我们已经有办法处理<code>映射到相同下标值</code>的情况：链地址法或者开放地址法</li>
<li>但是无论哪种方案，为了提供效率，最好的情况还是让数据在哈希表中<code>均匀分布</code></li>
<li>因此，我们需要在<code>使用常量的地方</code>，尽量使用<code>质数</code></li>
<li>哪些地方我们会使用到常量呢？</li>
</ul>
</li>
<li>质数的使用：<ul>
<li>哈希表的长度 (取余操作的时候分布的更加均匀)</li>
<li>N次幂的底数 (我们之前使用的是27)</li>
</ul>
</li>
<li>为什么他们使用质数，会让哈希表分布更加均匀呢？<ul>
<li>质数和其他数相乘的结果相比于其他数字更容易产生唯一性的结果，减少哈希冲突</li>
<li>Java中的N次幂的底数选择的是31，是经过长期观察分布结果得出的</li>
</ul>
</li>
</ul>
<h4 id="4-4-Java中的HashMap"><a href="#4-4-Java中的HashMap" class="headerlink" title="4.4 Java中的HashMap"></a>4.4 Java中的HashMap</h4><ul>
<li>Java中的哈希表采用的是<code>链地址法</code></li>
<li>HashMap的<code>初始长度是16</code>，每次<code>自动扩展</code>(我们还没有聊到扩展的话题)，长度必须是2的次幂<ul>
<li>这是为了<code>服务于从Key映射到index</code>的算法。60000000 % 100 &#x3D; 数字。下标值</li>
</ul>
</li>
<li>HashMap中为了提高效率，采用了<code>位运算的方式</code><ul>
<li>HashMap中index的计算公式：index &#x3D; HashCode（Key） &amp; （Length - 1）</li>
<li>比如计算book的hashcode，结果为十进制的3029737，二进制的101110001110101110 1001</li>
<li>假定HashMap长度是默认的16，计算Length-1的结果为十进制的15，二进制的1111</li>
<li>把以上两个结果做与运算，101110001110101110 1001 &amp; 1111 &#x3D; 1001，十进制是9，所以 index&#x3D;9</li>
</ul>
</li>
<li>但是，我个人发现JavaScript中进行较大数据的位运算时会出问题，所以我的代码实现中还是使用了取模<ul>
<li>另外，我这里为了方便代码之后向<code>开放地址法中迁移，容量还是选择使用质数</code></li>
</ul>
</li>
</ul>
<h4 id="4-5-N次幂的底数"><a href="#4-5-N次幂的底数" class="headerlink" title="4.5 N次幂的底数"></a>4.5 N次幂的底数</h4><ul>
<li>这里采用质数的原因是为了产生的数据不按照某种规律递增<ul>
<li>比如我们这里有一组数据是按照4进行递增的：0 4 8 12 16，将其映射到长度为8的哈希表中</li>
<li>它们的位置是多少呢？0 - 4 - 0 - 4，依次类推 (取余操作)</li>
<li>如果我们哈希表本身不是质数，而我们递增的数量可以使用质数，比如5，那么 0 5 10 15 20</li>
<li>它们的位置是多少呢？0 - 5 - 2 - 7 - 4，依次类推。也可以尽量让数据均匀的分布</li>
<li>我们之前使用的是27，这次可以使用一个接近的数，比如31&#x2F;37&#x2F;41等等。一个比较常用的数是31或37</li>
</ul>
</li>
<li>总之，质数是一个非常神奇的数字</li>
<li>这里建议两处都使用质数：<ul>
<li>哈希表中数组的长度</li>
<li>N次幂的底数</li>
</ul>
</li>
</ul>
<h3 id="5-哈希表创建和操作"><a href="#5-哈希表创建和操作" class="headerlink" title="5. 哈希表创建和操作"></a>5. 哈希表创建和操作</h3><h4 id="5-1-哈希函数的实现"><a href="#5-1-哈希函数的实现" class="headerlink" title="5.1 哈希函数的实现"></a>5.1 哈希函数的实现</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希函数：将key映射成index</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hashFunc</span>(<span class="params">key: <span class="built_in">string</span>, max: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="comment">// 1.计算hashCode  cats =&gt; 60337 (27为底的时候)</span></span><br><span class="line">  <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> length = key.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// 霍纳法则计算 (31为底)</span></span><br><span class="line">    hashCode = <span class="number">31</span> * hashCode + key.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.求出索引值 (取余)</span></span><br><span class="line">  <span class="keyword">const</span> index = hashCode % max;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试哈希函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hashFunc</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">7</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hashFunc</span>(<span class="string">&quot;cba&quot;</span>, <span class="number">7</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hashFunc</span>(<span class="string">&quot;nba&quot;</span>, <span class="number">7</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hashFunc</span>(<span class="string">&quot;mba&quot;</span>, <span class="number">7</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-创建哈希表"><a href="#5-2-创建哈希表" class="headerlink" title="5.2 创建哈希表"></a>5.2 创建哈希表</h4><ul>
<li><p>经过前面那么多内容的学习，我们现在可以真正<code>实现自己的哈希表</code>了</p>
<ul>
<li>可能你学到这里的时候，已经感觉到数据结构的一些复杂性</li>
<li>但是如果你仔细品味，你也会发现它在设计时候的巧妙和优美</li>
<li>当你爱上它的那一刻，你也真正爱上了编程，爱上数据结构</li>
</ul>
</li>
<li><p>我们这里采用<code>链地址法</code>来实现哈希表</p>
<ul>
<li>实现的哈希表 (基于storage的数组)每个index对应的是一个数组(bucket)。(当然基于链表也可以)</li>
<li>bucket中存放什么呢？我们最好将key和value都放进去，我们继续使用一个数组。(其实其他语言使用元组更好)</li>
<li>最终我们的哈希表的数据格式是这样：[ [[k，v]，[k，v]，[k，v]] ，[[k，v]，[k，v]]，[[k，v]] ]</li>
</ul>
</li>
<li><p>代码解析，我们定义了三个属性：</p>
<ul>
<li><code>storage</code>作为我们的数组，数组中存放相关的元素</li>
<li><code>count</code>表示当前已经存在了多少数据</li>
<li><code>limit</code>用于标记数组中一共可以存放多少个元素</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1747313183758.png" alt="74731318375"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>&lt;T = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建一个数组，用来存放链地址法中的链子(数组)</span></span><br><span class="line">  <span class="comment">// [string, T] 表示一个元组类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">storage</span>: [<span class="built_in">string</span>, T][][] = [];</span><br><span class="line">  <span class="comment">// 记录数组的长度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">length</span>: <span class="built_in">number</span> = <span class="number">7</span>;</span><br><span class="line">  <span class="comment">// 记录已经存放元素的个数</span></span><br><span class="line">  <span class="comment">// 装填因子loadFactor = count / length</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">count</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 哈希函数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">hashFunc</span>(<span class="attr">key</span>: <span class="built_in">string</span>, <span class="attr">max</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// 1.计算hashCode  cats =&gt; 60337 (27为底的时候)</span></span><br><span class="line">    <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> length = key.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="comment">// 霍纳法则计算 (31为底)</span></span><br><span class="line">      hashCode = <span class="number">31</span> * hashCode + key.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.求出索引值 (取余)</span></span><br><span class="line">    <span class="keyword">const</span> index = hashCode % max;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扩容函数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">resize</span>(<span class="params">newLength: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在此处封装哈希表相关方法</span></span><br><span class="line">  <span class="title function_">put</span>(<span class="params">key: <span class="built_in">string</span>, value: T</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">get</span>(<span class="attr">key</span>: <span class="built_in">string</span>): T | <span class="literal">null</span> &#123;&#125;</span><br><span class="line">  <span class="title function_">delete</span>(<span class="attr">key</span>: <span class="built_in">string</span>): T | <span class="literal">null</span>  &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hashTable = <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-3-插入-amp-修改数据"><a href="#5-3-插入-amp-修改数据" class="headerlink" title="5.3 插入 &amp; 修改数据"></a>5.3 插入 &amp; 修改数据</h4><ul>
<li>哈希表的插入和修改操作是同一个函数<ul>
<li>因为，当使用者传入一个&lt;Key，Value&gt;时</li>
<li>如果原来不存该key，那么就是插入操作</li>
<li>如果已经存在该key，那么就是修改操作</li>
</ul>
</li>
<li>代码解析<ul>
<li>步骤1：根据传入的key获取对应的hashCode，也就是数组的index</li>
<li>步骤2：从哈希表的index位置中取出桶(另外一个数组)</li>
<li>步骤3：查看上一步的bucket是否为null<ul>
<li>为null，表示之前在该位置没有放置过任何的内容，那么就新建一个数组[]</li>
</ul>
</li>
<li>步骤4：查看是否之前已经放置过key对应的value<ul>
<li>如果放置过，那么就是依次替换操作，而不是插入新的数据</li>
<li>我们使用一个变量override来记录是否是修改操作</li>
</ul>
</li>
<li>步骤5：如果不是修改操作，那么插入新的数据<ul>
<li>在bucket中push新的[key，value]即可</li>
<li>注意：这里需要将count+1，因为数据增加了一项</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入&amp;修改数据</span></span><br><span class="line"><span class="title function_">put</span>(<span class="params">key: <span class="built_in">string</span>, value: T</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.根据key获取数组中对应的索引值</span></span><br><span class="line">  <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key, <span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.取出对应位置的桶(bucket)</span></span><br><span class="line">  <span class="keyword">let</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line">  <span class="keyword">if</span> (!bucket) &#123;</span><br><span class="line">    bucket = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span>[index] = bucket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.判断是新增还是修改原来的值</span></span><br><span class="line">  <span class="keyword">let</span> isCover = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">    <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">      <span class="comment">// 修改操作</span></span><br><span class="line">      tuple[<span class="number">1</span>] = value;</span><br><span class="line">      isCover = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.如果上面的代码没有进行覆盖，那么在该位置进行添加</span></span><br><span class="line">  <span class="keyword">if</span> (!isCover) &#123;</span><br><span class="line">    bucket.<span class="title function_">push</span>([key, value]);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-获取数据"><a href="#5-4-获取数据" class="headerlink" title="5.4 获取数据"></a>5.4 获取数据</h4><ul>
<li>获取数据：根据key获取对应的value</li>
<li>代码解析<ul>
<li>步骤1：根据key获取hashCode(也就是index)</li>
<li>步骤2：根据index取出bucket</li>
<li>步骤3：因为如果bucket都是null，那么说明这个位置之前并没有插入过数据</li>
<li>步骤4：有了bucket，就遍历，并且如果找到，就将对应的value返回即可</li>
<li>步骤5：没有找到，返回null</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="title function_">get</span>(<span class="attr">key</span>: <span class="built_in">string</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 1.根据key获取索引值index</span></span><br><span class="line">  <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key, <span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.根据索引获取桶bucket</span></span><br><span class="line">  <span class="keyword">const</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line">  <span class="keyword">if</span> (!bucket) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.遍历桶中的数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">    <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">      <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-删除数据"><a href="#5-5-删除数据" class="headerlink" title="5.5 删除数据"></a>5.5 删除数据</h4><ul>
<li>删除数据：我们根据对应的key，删除对应的key&#x2F;value</li>
<li>代码解析：思路和获取数据相似，不再给出解析</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="title function_">delete</span>(<span class="attr">key</span>: <span class="built_in">string</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 1.根据key获取index</span></span><br><span class="line">  <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key, <span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.根据索引获取桶bucket</span></span><br><span class="line">  <span class="keyword">const</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line">  <span class="keyword">if</span> (!bucket) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.遍历桶中的数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">    <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">      bucket.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">      <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-哈希表的自动扩容"><a href="#6-哈希表的自动扩容" class="headerlink" title="6. 哈希表的自动扩容"></a>6. 哈希表的自动扩容</h3><h4 id="6-1-哈希表扩容的思想"><a href="#6-1-哈希表扩容的思想" class="headerlink" title="6.1 哈希表扩容的思想"></a>6.1 哈希表扩容的思想</h4><ul>
<li>为什么需要扩容？<ul>
<li>目前，我们是将所有的数据项放在<code>长度为7的数组</code>中的</li>
<li>因为我们使用的是<code>链地址法</code>，<code>loadFactor</code>可以大于1，所以这个哈希表可以无限制的插入新数据</li>
<li>但是，随着<code>数据量的增多</code>，每一个index对应的bucket会越来越长，也就造成<code>效率的降低</code></li>
<li>所以，在合适的情况对数组进行<code>扩容</code>，比如扩容两倍</li>
</ul>
</li>
<li>如何进行扩容？<ul>
<li>扩容可以简单的将容量<code>增大两倍</code>(不是质数吗？质数的问题后面再讨论)</li>
<li>但是这种情况下，所有的数据项<code>一定要同时进行修改</code>(重新调用哈希函数，来获取到不同的位置)</li>
<li>比如hashCode&#x3D;12的数据项，在length&#x3D;8的时候，index&#x3D;4。在长度为16的时候呢？index&#x3D;12</li>
<li>这是一个<code>耗时的过程</code>，但是如果<code>数组需要扩容</code>，那么这个过程是<code>必要的</code></li>
</ul>
</li>
<li>什么情况下扩容呢？<ul>
<li>比较常见的情况是<code>loadFactor &gt; 0.75</code>的时候进行扩容</li>
<li>比如Java的哈希表就是在装填因子大于0.75的时候，对哈希表进行扩容</li>
</ul>
</li>
</ul>
<h4 id="6-2-扩容函数"><a href="#6-2-扩容函数" class="headerlink" title="6.2 扩容函数"></a>6.2 扩容函数</h4><ul>
<li>我们来实现一下扩容函数</li>
<li>代码解析<ul>
<li>步骤1：先将之前数组保存起来，因为我们待会儿会将storeage &#x3D; []</li>
<li>步骤2：之前的属性值需要重置</li>
<li>步骤3：遍历所有的数据项，重新插入到哈希表中</li>
</ul>
</li>
<li>在什么时候调用扩容方法呢？<ul>
<li>在每次添加完新的数据时，都进行判断。(也就是put方法中)</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">resize</span>(<span class="params">newLength: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 设置新的长度</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span> = newLength;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取原来的数据，并且重新放入到新的容量数组中</span></span><br><span class="line">  <span class="comment">// 1.对数据进行初始化操作</span></span><br><span class="line">  <span class="keyword">const</span> oldStorage = <span class="variable language_">this</span>.<span class="property">storage</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">storage</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.获取原来的数据，放入新的数组中</span></span><br><span class="line">  oldStorage.<span class="title function_">forEach</span>(<span class="function">(<span class="params">bucket</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!bucket) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">put</span>(tuple[<span class="number">0</span>], tuple[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-put-x2F-remove方法修改"><a href="#6-3-put-x2F-remove方法修改" class="headerlink" title="6.3 put&#x2F;remove方法修改"></a>6.3 put&#x2F;remove方法修改</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入&amp;修改数据</span></span><br><span class="line"><span class="title function_">put</span>(<span class="params">key: <span class="built_in">string</span>, value: T</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.根据key获取数组中对应的索引值</span></span><br><span class="line">  <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key, <span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.取出对应位置的桶(bucket)</span></span><br><span class="line">  <span class="keyword">let</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line">  <span class="keyword">if</span> (!bucket) &#123;</span><br><span class="line">    bucket = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span>[index] = bucket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.判断是新增还是修改原来的值</span></span><br><span class="line">  <span class="keyword">let</span> isCover = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">    <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">      <span class="comment">// 修改操作</span></span><br><span class="line">      tuple[<span class="number">1</span>] = value;</span><br><span class="line">      isCover = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.如果上面的代码没有进行覆盖，那么在该位置进行添加</span></span><br><span class="line">  <span class="keyword">if</span> (!isCover) &#123;</span><br><span class="line">    bucket.<span class="title function_">push</span>([key, value]);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="comment">// 发现loadFactor比例已经大于0.75了，那么就进行扩容</span></span><br><span class="line">    <span class="keyword">const</span> loadFactor = <span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &gt; <span class="number">0.75</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="variable language_">this</span>.<span class="property">length</span> * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据-------------------------------------------------------------</span></span><br><span class="line"><span class="title function_">delete</span>(<span class="attr">key</span>: <span class="built_in">string</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 1.根据key获取index</span></span><br><span class="line">  <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key, <span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.根据索引获取桶bucket</span></span><br><span class="line">  <span class="keyword">const</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line">  <span class="keyword">if</span> (!bucket) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.遍历桶中的数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">    <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">      bucket.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 缩容操作：数组长度最小为7，只有大于7的时候，才需要进行缩容操作</span></span><br><span class="line">      <span class="keyword">const</span> loadFactor = <span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt; <span class="number">0.25</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">length</span> &gt; <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="variable language_">this</span>.<span class="property">length</span> / <span class="number">2</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-容量质数"><a href="#6-4-容量质数" class="headerlink" title="6.4 容量质数"></a>6.4 容量质数</h4><ul>
<li>我们前面提到过，容量最好是质数<ul>
<li>虽然在链地址法中将容量设置为质数，没有在开放地址法中重要</li>
<li>但是其实链地址法中质数作为容量也更利于数据的均匀分布。所以，我们还是完成一下这个步骤</li>
</ul>
</li>
<li>我们这里先讨论一个常见的面试题，<code>判断一个数是质数</code></li>
<li>质数的特点：<ul>
<li>质数也称为<code>素数</code></li>
<li>质数表示大于1的自然数中，<code>只能被1和自己整除的数</code></li>
</ul>
</li>
<li>OK，了解了这个特点，应该不难写出它的算法</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个数是否是质数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isPrime</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="comment">// 质数的特点是只能被1和num整除</span></span><br><span class="line">    <span class="keyword">if</span> (num % i === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isPrime</span>(<span class="number">3</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isPrime</span>(<span class="number">32</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isPrime</span>(<span class="number">37</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isPrime</span>(<span class="number">45</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="6-5-更高效的质数判断"><a href="#6-5-更高效的质数判断" class="headerlink" title="6.5 更高效的质数判断"></a>6.5 更高效的质数判断</h4><ul>
<li>但是，这种做法的效率并不高。为什么呢？<ul>
<li>对于每个数n，其实并不需要从2判断到n-1</li>
<li>一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n)<ul>
<li>注意： sqrt是square root的缩写，表示平方根</li>
</ul>
</li>
<li>比如16可以被分别。那么是2*8，2小于sqrt(16)，也就是4，8大于4。而4*4都是等于sqrt(n)</li>
<li>所以其实我们遍历到等于sqrt(n)即可</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个数是否是质数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isPrime</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sqrt = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(num);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= sqrt; i++) &#123;</span><br><span class="line">    <span class="comment">// 质数的特点是只能被1和num整除</span></span><br><span class="line">    <span class="keyword">if</span> (num % i === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isPrime</span>(<span class="number">3</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isPrime</span>(<span class="number">32</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isPrime</span>(<span class="number">37</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isPrime</span>(<span class="number">45</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="6-6-扩容的质数-完整封装"><a href="#6-6-扩容的质数-完整封装" class="headerlink" title="6.6 扩容的质数 (完整封装)"></a>6.6 扩容的质数 (完整封装)</h4><ul>
<li>前面，我们有对容量进行扩展，方式是：原来的容量 x 2<ul>
<li>比如之前的容量是7，那么扩容后就是14。14还是一个质数吗？</li>
<li>显然不是，所以我们还需要一个方法，来实现一个新的容量为质数的算法</li>
</ul>
</li>
<li>那么我们可以封装获取新的容量的代码(质数)</li>
<li>哈希表质数扩容(完整代码)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>&lt;T = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建一个数组，用来存放链地址法中的链子(数组)</span></span><br><span class="line">  <span class="comment">// [string, T] 表示一个元组类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">storage</span>: [<span class="built_in">string</span>, T][][] = [];</span><br><span class="line">  <span class="comment">// 记录数组的长度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">length</span>: <span class="built_in">number</span> = <span class="number">7</span>;</span><br><span class="line">  <span class="comment">// 记录已经存放元素的个数</span></span><br><span class="line">  <span class="comment">// 装填因子loadFactor = count / length</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">count</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 哈希函数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">hashFunc</span>(<span class="attr">key</span>: <span class="built_in">string</span>, <span class="attr">max</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// 1.计算hashCode  cats =&gt; 60337 (27为底的时候)</span></span><br><span class="line">    <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> length = key.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="comment">// 霍纳法则计算 (31为底)</span></span><br><span class="line">      hashCode = <span class="number">31</span> * hashCode + key.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.求出索引值 (取余)</span></span><br><span class="line">    <span class="keyword">const</span> index = hashCode % max;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断数字是否是质数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">isPrime</span>(<span class="attr">num</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> sqrt = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= sqrt; i++) &#123;</span><br><span class="line">      <span class="comment">// 质数的特点是只能被1和num整除</span></span><br><span class="line">      <span class="keyword">if</span> (num % i === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找下一个质数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getNextPrime</span>(<span class="attr">num</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newPrime = num;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="variable language_">this</span>.<span class="title function_">isPrime</span>(newPrime)) &#123;</span><br><span class="line">      newPrime++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newPrime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扩容函数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">resize</span>(<span class="params">newLength: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 设置新的长度(新的长度是质数，并且最小长度为7)</span></span><br><span class="line">    <span class="keyword">let</span> newPrime = <span class="variable language_">this</span>.<span class="title function_">getNextPrime</span>(newLength);</span><br><span class="line">    <span class="keyword">if</span> (newPrime &lt; <span class="number">7</span>) &#123;</span><br><span class="line">      newPrime = <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = newPrime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原来的数据，并且重新放入到新的容量数组中</span></span><br><span class="line">    <span class="comment">// 1.对数据进行初始化操作</span></span><br><span class="line">    <span class="keyword">const</span> oldStorage = <span class="variable language_">this</span>.<span class="property">storage</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取原来的数据，放入新的数组中</span></span><br><span class="line">    oldStorage.<span class="title function_">forEach</span>(<span class="function">(<span class="params">bucket</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!bucket) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">put</span>(tuple[<span class="number">0</span>], tuple[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入&amp;修改数据</span></span><br><span class="line">  <span class="title function_">put</span>(<span class="params">key: <span class="built_in">string</span>, value: T</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.根据key获取数组中对应的索引值</span></span><br><span class="line">    <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key, <span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.取出对应位置的桶(bucket)</span></span><br><span class="line">    <span class="keyword">let</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line">    <span class="keyword">if</span> (!bucket) &#123;</span><br><span class="line">      bucket = [];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">storage</span>[index] = bucket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.判断是新增还是修改原来的值</span></span><br><span class="line">    <span class="keyword">let</span> isCover = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">        <span class="comment">// 修改操作</span></span><br><span class="line">        tuple[<span class="number">1</span>] = value;</span><br><span class="line">        isCover = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.如果上面的代码没有进行覆盖，那么在该位置进行添加</span></span><br><span class="line">    <span class="keyword">if</span> (!isCover) &#123;</span><br><span class="line">      bucket.<span class="title function_">push</span>([key, value]);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 扩容操作</span></span><br><span class="line">      <span class="comment">// 发现loadFactor比例已经大于0.75了，那么就进行扩容</span></span><br><span class="line">      <span class="keyword">const</span> loadFactor = <span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">      <span class="keyword">if</span> (loadFactor &gt; <span class="number">0.75</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="variable language_">this</span>.<span class="property">length</span> * <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取数据</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="attr">key</span>: <span class="built_in">string</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// 1.根据key获取索引值index</span></span><br><span class="line">    <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key, <span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.根据索引获取桶bucket</span></span><br><span class="line">    <span class="keyword">const</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line">    <span class="keyword">if</span> (!bucket) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.遍历桶中的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">        <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除数据</span></span><br><span class="line">  <span class="title function_">delete</span>(<span class="attr">key</span>: <span class="built_in">string</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// 1.根据key获取index</span></span><br><span class="line">    <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="title function_">hashFunc</span>(key, <span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.根据索引获取桶bucket</span></span><br><span class="line">    <span class="keyword">const</span> bucket = <span class="variable language_">this</span>.<span class="property">storage</span>[index];</span><br><span class="line">    <span class="keyword">if</span> (!bucket) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.遍历桶中的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">        bucket.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缩容操作：数组长度最小为7，只有大于7的时候，才需要进行缩容操作</span></span><br><span class="line">        <span class="keyword">const</span> loadFactor = <span class="variable language_">this</span>.<span class="property">count</span> / <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt; <span class="number">0.25</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">length</span> &gt; <span class="number">7</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="variable language_">this</span>.<span class="property">length</span> / <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七-树结构（Tree）"><a href="#七-树结构（Tree）" class="headerlink" title="(七) 树结构（Tree）"></a>(七) 树结构（Tree）</h2><h3 id="1-认识树结构以及特性"><a href="#1-认识树结构以及特性" class="headerlink" title="1. 认识树结构以及特性"></a>1. 认识树结构以及特性</h3><h4 id="1-1-什么是树？"><a href="#1-1-什么是树？" class="headerlink" title="1.1 什么是树？"></a>1.1 什么是树？</h4><ul>
<li>真实的树：相信每个人对<code>现实生活中的树</code>都会非常熟悉</li>
<li>我们来看一下树有什么特点？<ul>
<li>树通常有一个<code>根</code>，连接着根的是<code>树干</code></li>
<li>树干到上面之后会进行分叉成<code>树枝</code>，树枝还会分叉成更小的<code>树枝</code></li>
<li>在树枝的最后是<code>叶子</code></li>
</ul>
</li>
<li>树的抽象：专家们对树的结构进行了抽象，发现树可以<code>模拟生活</code>中的<code>很多场景</code></li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1748956367180.png" alt="74895636718"></p>
<h4 id="1-2-模拟树结构"><a href="#1-2-模拟树结构" class="headerlink" title="1.2 模拟树结构"></a>1.2 模拟树结构</h4><ul>
<li><code>公司组织架构</code></li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1748956465815.png" alt="74895646581"></p>
<ul>
<li><code>红楼梦家谱</code></li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1748956489538.png" alt="74895648953"></p>
<ul>
<li><code>前端非常熟悉的 DOM Tree</code></li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1748956527005.png" alt="74895652700"></p>
<h4 id="1-3-树结构的抽象"><a href="#1-3-树结构的抽象" class="headerlink" title="1.3 树结构的抽象"></a>1.3 树结构的抽象</h4><ul>
<li>我们再将里面的<code>数据移除</code>，仅仅抽象出来<code>结构</code>，那么就是我们要学习的<code>树结构</code></li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1748956696158.png" alt="74895669615"></p>
<h3 id="2-树结构的优点和术语"><a href="#2-树结构的优点和术语" class="headerlink" title="2. 树结构的优点和术语"></a>2. 树结构的优点和术语</h3><h4 id="2-1-树的优点"><a href="#2-1-树的优点" class="headerlink" title="2.1 树的优点"></a>2.1 树的优点</h4><ul>
<li><p>我们之前已经学习了多种数据结构来保存数据，为什么要<code>使用树结构</code>来保存数据呢？</p>
</li>
<li><p><code>树结构</code>和<code>数组/链表/哈希表的对比</code>有什么<code>优点</code>呢？</p>
</li>
<li><p><strong>数组</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li>数组的主要优点是根据<code>下标值访问</code>效率会很高</li>
<li>但是如果我们希望根据元素来查找对应的位置呢？</li>
<li>比较好的方式是先对数组进行<code>排序</code>，再进行<code>二分查找</code></li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>需要先对数组进行<code>排序</code>，生成<code>有序数组</code>，才能提高查找效率</li>
<li>另外数组在插入和删除数据时，需要有大量的<code>位移操作</code>(插入到首位或者中间位置的时候)，效率很低。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>链表</strong></p>
<ul>
<li>优点：<ul>
<li>链表的插入和删除操作效率都很高</li>
</ul>
</li>
<li>缺点：<ul>
<li><code>查找</code>效率很低，需要从头开始依次访问链表中的每个数据项，直到找到</li>
<li>而且即使插入和删除操作效率很高，但是如果要插入和删除中间位置的数据，还是需要重头先找到对应的数据</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>哈希表</strong></p>
<ul>
<li>优点：<ul>
<li>我们学过哈希表后，已经发现了哈希表的插入&#x2F;查询&#x2F;删除效率都是非常高的</li>
<li>但是哈希表也有很多缺点</li>
</ul>
</li>
<li>缺点：<ul>
<li><code>空间利用率不高</code>，底层使用的是数组，并且某些单元是没有被利用的</li>
<li>哈希表中的元素是<code>无序</code>的，不能按照固定的顺序来遍历哈希表中的元素</li>
<li>不能快速的找出哈希表中的<code>最大值或者最小值</code>这些特殊的值</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>树结构</strong></p>
<ul>
<li>我们不能说树结构比其他结构都要好，因为<code>每种数据结构都有自己特定的应用场景</code></li>
<li>但是<code>树确实也综合了上面的数据结构的优点</code>(当然优点不足于盖过其他数据结构，比如效率一般情况下没有哈希表高)</li>
<li>并且<code>也弥补了上面数据结构的缺点</code></li>
</ul>
</li>
<li><p><strong>而且为了模拟某些场景，我们使用树结构会更加方便</strong></p>
<ul>
<li>因为数结构的非线性的，可以表示<code>一对多</code>的关系</li>
<li>比如<code>文件的目录结构</code></li>
</ul>
</li>
</ul>
<h4 id="2-2-树的术语"><a href="#2-2-树的术语" class="headerlink" title="2.2 树的术语"></a>2.2 树的术语</h4><ul>
<li><p>在描述树的各个部分的时候有很多<code>术语</code></p>
<ul>
<li>为了让介绍的内容更容易理解，需要知道一些<code>树的术语</code></li>
<li>不过大部分术语都与真实世界的<code>树相关</code>，或者和<code>家庭关系相关</code>(如父节点和子节点)，所以它们比较容易理解</li>
</ul>
</li>
<li><p>树（Tree）：n（n≥0）个节点构成的<code>有限集合</code></p>
<ul>
<li>当n&#x3D;0时，称为<code>空树</code></li>
</ul>
</li>
<li><p>对于任一棵非空树（n&gt; 0），它具备以下性质：</p>
<ul>
<li>树中有一个称为<code>“根（Root）”</code>的特殊节点，用 r 表示</li>
<li>其余节点可分为m(m&gt;0)个互不相交的有限集T1，T2，..。，Tm，其中每个集合本身又是一棵树，称为原来树的<code>“子树（SubTree）”</code></li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1748957500631.png" alt="74895750063"></p>
</li>
<li><p><strong>树的术语</strong></p>
<ul>
<li><code>节点的度（Degree）</code>：节点的<code>子树个数</code></li>
<li><code>树的度 （Degree）</code> ：树的所有节点中<code>最大的度数</code></li>
<li><code>叶节点（Leaf）</code>：<code>度为0的节点</code>。(也称为<code>叶子节点</code>)</li>
<li><code>父节点（Parent）</code>：有子树的节点是其子树的根节点的父节点</li>
<li><code>子节点（Child）</code>：若A节点是B节点的父节点，则称B节点是A节点的子节点；子节点也称孩子节点</li>
<li><code>兄弟节点（Sibling）</code>：具有同一父节点的各节点彼此是兄弟节点</li>
<li><code>路径和路径长度</code>：从节点n1到nk的路径为一个节点序列n1 ，n2，… ，nk<ul>
<li>ni是 n(i+1)的父节点</li>
<li>路径所包含 边 的个数为路径的长度</li>
</ul>
</li>
<li><code>节点的层次（Level）</code>：规定<code>根节点在1层</code>，其它任一节点的层数是其父节点的<code>层数加1</code></li>
<li><code>树的深度（Depth）</code>：对于任意节点n，n的深度为从根到n的唯一路径长，根的深度为0</li>
<li><code>树的高度（Height）</code>：对于任意节点n，n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0</li>
</ul>
</li>
</ul>
<h3 id="3-树结构常见表示方法"><a href="#3-树结构常见表示方法" class="headerlink" title="3. 树结构常见表示方法"></a>3. 树结构常见表示方法</h3><ul>
<li>普通的表示方式</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1748957881769.png" alt="74895788176"></p>
<ul>
<li>儿子 - 兄弟表示法</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1748957896927.png" alt="74895789692"></p>
<ul>
<li>儿子 - 兄弟表示法旋转</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1748957918043.png" alt="74895791804"></p>
<ul>
<li><strong>你发现上面规律了吗？</strong><ul>
<li>其实所有的树本质上都可以<code>使用二叉树模拟出来</code></li>
<li>所以在学习树的过程中，<code>二叉树非常重要</code></li>
</ul>
</li>
</ul>
<h3 id="4-二叉树特性以及概念"><a href="#4-二叉树特性以及概念" class="headerlink" title="4. 二叉树特性以及概念"></a>4. 二叉树特性以及概念</h3><h4 id="4-1-二叉树的概念"><a href="#4-1-二叉树的概念" class="headerlink" title="4.1 二叉树的概念"></a>4.1 二叉树的概念</h4><ul>
<li>果树中每个节点<code>最多只能有两个子节点</code>，这样的树就成为<code>&quot;二叉树&quot;</code><ul>
<li>前面，我们已经提过二叉树的重要性，不仅仅是因为简单，也因为几乎上所有的树都可以表示成二叉树的形式</li>
</ul>
</li>
<li>二叉树的定义<ul>
<li>二叉树<code>可以为空</code>，也就是<code>没有节点</code></li>
<li>若<code>不为空</code>，则它是<code>由根节点</code> 和 称为其 <code>左子树TL</code>和 <code>右子树TR</code> 的两个不相交的二叉树组成</li>
</ul>
</li>
<li>二叉树有五种形态</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1749883490391.png" alt="74988349039"></p>
<h4 id="4-2-二叉树的特性"><a href="#4-2-二叉树的特性" class="headerlink" title="4.2 二叉树的特性"></a>4.2 二叉树的特性</h4><ul>
<li><p>二叉树有几个比较重要的特性，在笔试题中比较常见</p>
<ul>
<li>一颗二叉树<code>第 i 层的最大节点数</code>为：2^(i-1)，i &gt;&#x3D; 1</li>
<li>深度<code>为k的二叉树有最大节点总数</code>为： 2^k - 1，k &gt;&#x3D; 1</li>
<li>对<code>任何非空二叉树T</code>，若n0表示叶节点的个数、n2是度为2的非叶节点个数，那么两者满足关系n0 &#x3D; n2 + 1</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1749883561927.png" alt="74988356192"></p>
</li>
</ul>
<h4 id="4-3-完美二叉树"><a href="#4-3-完美二叉树" class="headerlink" title="4.3 完美二叉树"></a>4.3 完美二叉树</h4><ul>
<li>完美二叉树(Perfect Binary Tree) ，也称为满二叉树(Full Binary Tree）<ul>
<li>在二叉树中，除了<code>最下一层的叶节点外，每层节点都有2个子节点</code>，就构成了<code>满二叉树</code></li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1749884619411.png" alt="74988461941"></p>
<h4 id="4-4-完全二叉树"><a href="#4-4-完全二叉树" class="headerlink" title="4.4 完全二叉树"></a>4.4 完全二叉树</h4><ul>
<li>完全二叉树(Complete Binary Tree)<ul>
<li>除<code>二叉树最后一层外，其他各层的节点数都达到最大个数</code></li>
<li>且<code>最后一层从左向右的叶节点连续存在，只缺右侧若干节点</code></li>
<li><code>完美二叉树</code>是特殊的<code>完全二叉树</code></li>
</ul>
</li>
<li>下面不是完全二叉树，因为D节点还没有右节点，但是E节点就有了左右节点</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1749884666256.png" alt="74988466625"></p>
<h3 id="5-二叉树常见存储方式"><a href="#5-二叉树常见存储方式" class="headerlink" title="5. 二叉树常见存储方式"></a>5. 二叉树常见存储方式</h3><ul>
<li><p>二叉树的存储常见的方式是<code>数组</code>和<code>链表</code></p>
</li>
<li><p><strong>使用数组</strong></p>
<ul>
<li><p><code>完全二叉树</code>：按从上至下、从左到右顺序存储</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1749885105381.png" alt="74988510538"> </p>
</li>
<li><p><code>非完全二叉树</code></p>
<ul>
<li><p>非完全二叉树要转成完全二叉树才可以按照上面的方案存储</p>
</li>
<li><p>但是会造成很大的空间浪费</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1749885129096.png" alt="74988512909"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>链表存储</strong></p>
<ul>
<li>二叉树最常见的方式还是使用链表存储<ul>
<li><code>每个节点封装成一个Node</code>，Node中<code>包含存储的数据，左节点的引用，右节点的引用</code></li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1749885237426.png" alt="74988523742"></p>
</li>
</ul>
<h3 id="6-认识二叉搜索树特性"><a href="#6-认识二叉搜索树特性" class="headerlink" title="6. 认识二叉搜索树特性"></a>6. 认识二叉搜索树特性</h3><h4 id="6-1-什么是二叉搜索树？"><a href="#6-1-什么是二叉搜索树？" class="headerlink" title="6.1 什么是二叉搜索树？"></a>6.1 什么是二叉搜索树？</h4><ul>
<li><p>二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树</p>
</li>
<li><p>二叉搜索树是一颗二叉树，可以为空</p>
</li>
<li><p>如果不为空，满足以下<code>性质</code>：</p>
<ul>
<li>非空左子树的所有键值小于其根节点的键值</li>
<li>非空右子树的所有键值大于其根节点的键值</li>
<li>左、右子树本身也都是二叉搜索树</li>
</ul>
</li>
<li><p>下面哪些是二叉搜索树，哪些不是？</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1749885403568.png" alt="74988540356"></p>
</li>
<li><p>二叉搜索树的<code>特点</code>：</p>
<ul>
<li>二叉搜索树的特点就是相对<code>较小的值</code>总是保存在<code>左节点</code>上，相对<code>较大的值</code>总是保存在<code>右节点</code>上</li>
<li>那么利用这个特点，我们可以做什么事情呢？</li>
<li>查找效率非常高，这也是<code>二叉搜索树</code>中，<code>搜索的来源</code></li>
</ul>
</li>
</ul>
<h4 id="6-2-二叉搜索树"><a href="#6-2-二叉搜索树" class="headerlink" title="6.2 二叉搜索树"></a>6.2 二叉搜索树</h4><ul>
<li><p>下面是一个二叉搜索</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1749885630870.png" alt="74988563087"></p>
</li>
<li><p>这样的数据结构有什么好处呢？我们试着<code>查找一下值为10的节点</code></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1749885681474.png" alt="74988568147"></p>
</li>
<li><p>这种方式就是二分查找的思想</p>
<ul>
<li><code>查找所需的最大次数</code>等于<code>二叉搜索树的深度</code></li>
<li><code>插入节点</code>时，也<code>利用类似的方法，一层层比较大小，找到新节点合适的位置</code></li>
</ul>
</li>
</ul>
<h3 id="7-二叉搜索树类的封装"><a href="#7-二叉搜索树类的封装" class="headerlink" title="7. 二叉搜索树类的封装"></a>7. 二叉搜索树类的封装</h3><ul>
<li>们像封装其他数据结构一样，先来封装一个BSTree的类</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1749885810547.png" alt="74988581054"></p>
<ul>
<li>代码解析：<ul>
<li>封装BSTree的类</li>
<li>还需要封装一个用于保存每一个节点的类TreeNode</li>
<li>该类包含三个属性：节点对应的value，指向的左子树left，指向的右子树right</li>
<li>对于BSTree来说，只需要保存根节点即可，因为其他节点都可以通过根节点找到</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 新增属性</span></span><br><span class="line">  <span class="comment">// 当前节点的父节点</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 当前节点是父节点的左子节点</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isLeft</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="variable language_">this</span>.<span class="property">parent</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">left</span> === <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前节点是父节点的右子节点</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isRight</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="variable language_">this</span>.<span class="property">parent</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">right</span> === <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">root</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 树常见操作的方法</span></span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">searchNode</span>(<span class="attr">value</span>: T): <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入操作</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">value: T</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">insertNode</span>(<span class="params">node: TreeNode&lt;T&gt;, newNode: TreeNode&lt;T&gt;</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 遍历操作</span></span><br><span class="line">  <span class="title function_">preOrderTraverse</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">preOrderTraverseNode</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">inOrderTraverse</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">inOrderTraverseNode</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">postOrderTraverse</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">postOrderTraverseNode</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">levelOrderTraversal</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 最大值/最小值</span></span><br><span class="line">  <span class="title function_">getMinValue</span>(): T | <span class="literal">null</span> &#123;&#125;</span><br><span class="line">  <span class="title function_">getMaxValue</span>(): T | <span class="literal">null</span> &#123;&#125;</span><br><span class="line">  <span class="comment">// 搜索</span></span><br><span class="line">  <span class="title function_">search</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;&#125;</span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getSuccessor</span>(<span class="attr">delNode</span>: <span class="title class_">TreeNode</span>&lt;T&gt;): <span class="title class_">TreeNode</span>&lt;T&gt; &#123;&#125;</span><br><span class="line">  <span class="title function_">remove</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-二叉搜索树常见操作"><a href="#8-二叉搜索树常见操作" class="headerlink" title="8. 二叉搜索树常见操作"></a>8. 二叉搜索树常见操作</h3><ul>
<li>二叉搜索树有哪些常见的操作呢？</li>
<li>插入操作：<ul>
<li><code>insert(value)</code>：向树中插入一个新的数据</li>
</ul>
</li>
<li>查找操作：<ul>
<li><code>search(value)</code>：在树中查找一个数据，如果节点存在，则返回true；如果不存在，则返回false</li>
<li><code>min</code>：返回树中最小的值&#x2F;数据</li>
<li><code>max</code>：返回树中最大的值&#x2F;数据</li>
</ul>
</li>
<li>遍历操作：<ul>
<li><code>inOrderTraverse</code>：通过<code>中序遍历</code>方式遍历所有节点</li>
<li><code>preOrderTraverse</code>：通过<code>先序遍历</code>方式遍历所有节点</li>
<li><code>postOrderTraverse</code>：通过<code>后序遍历</code>方式遍历所有节点</li>
<li><code>levelOrderTraverse</code>：通过<code>层序遍历</code>方式遍历所有节点</li>
</ul>
</li>
<li>删除操作（有一点点复杂）：<ul>
<li><code>remove(value)</code>：从树中移除某个数据</li>
</ul>
</li>
</ul>
<h3 id="9-二叉搜索树插入操作"><a href="#9-二叉搜索树插入操作" class="headerlink" title="9. 二叉搜索树插入操作"></a>9. 二叉搜索树插入操作</h3><ul>
<li><p>我们分两个部分来完成这个功能</p>
</li>
<li><p><strong>首先，外界调用的insert方法</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入数据的操作</span></span><br><span class="line"><span class="title function_">insert</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.创建新节点</span></span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.判断是否有根节点</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码解析：</p>
<ul>
<li>首先，根据传入的value，创建对应的Node</li>
<li>其次，向树中插入数据需要分成两种情况：<ul>
<li>第一次插入，直接修改根节点即可</li>
<li>其他次插入，需要进行相关的比较决定插入的位置</li>
</ul>
</li>
<li>代码中的insertNode方法，我们还没有实现，也是我们接下来要完成的任务</li>
</ul>
</li>
<li><p><strong>其次，插入非根节点</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入非根节点</span></span><br><span class="line"><span class="title function_">insertNode</span>(<span class="params">node: TreeNode&lt;T&gt;, newNode: TreeNode&lt;T&gt;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (newNode.<span class="property">value</span> &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 向左子树插入</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.<span class="property">left</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 向右子树插入</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.<span class="property">right</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码解析：</p>
<ul>
<li>插入其他节点时，我们需要判断该值到底是插入到左边还是插入到右边</li>
<li>判断的依据来自于新节点的value和原来节点的value值的比较<ul>
<li>如果新节点的newvalue小于原节点的oldvalue，那么就向左边插入</li>
<li>如果新节点的newvalue大于原节点的oldvalue，那么就向右边插入</li>
</ul>
</li>
<li>代码的1序号位置，就是准备向左子树插入数据。但是它本身又分成两种情况<ul>
<li>情况一(代码1.1位置)：左子树上原来没有内容，那么直接插入即可</li>
<li>情况二(代码1.2位置)：左子树上已经有了内容，那么就一次向下继续查找新的走向，所以使用递归调用即可</li>
</ul>
</li>
<li>代码的2序号位置，和1序号位置几乎逻辑是相同的，只是是向右去查找<ul>
<li>情况一(代码2.1位置)：左右树上原来没有内容，那么直接插入即可</li>
<li>情况二(代码2.2位置)：右子树上已经有了内容，那么就一次向下继续查找新的走向，所以使用递归调用即可</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>测试插入代码</strong></p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; btPrint &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印树的方法</span></span><br><span class="line"><span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 使用coderwhy老师封装的库hy-algokit，查看树的结构，传入树的根节点</span></span><br><span class="line">  <span class="title function_">btPrint</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bst = <span class="keyword">new</span> <span class="title class_">BSTree</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">11</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">7</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">15</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">5</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">3</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">9</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">8</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">10</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">13</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">12</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">14</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">20</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">18</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">25</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用打印树的方法</span></span><br><span class="line">bst.<span class="title function_">print</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750337469617.png" alt="75033746961"></p>
<h3 id="10-二叉搜索树遍历操作"><a href="#10-二叉搜索树遍历操作" class="headerlink" title="10. 二叉搜索树遍历操作"></a>10. 二叉搜索树遍历操作</h3><ul>
<li>前面，我们向树中插入了很多的数据，为了能很多的看到测试结果。我们先来学习一下<code>树的遍历</code><ul>
<li>注意：这里我们学习的树的遍历，<code>针对所有的二叉树</code>都是适用的，<code>不仅仅是二叉搜索树</code></li>
</ul>
</li>
<li>树的遍历<ul>
<li>遍历一棵树是指访问<code>树的每个节点</code>(也可以对每个节点进行某些操作，我们这里就是简单的打印)</li>
<li>但是树和线性结构不太一样，线性结构我们通常按照<code>从前到后的顺序遍历</code>，但是树呢？</li>
<li>应该从树的顶端还是底端开始呢？ 从左开始还是从右开始呢？</li>
</ul>
</li>
<li>二叉树的遍历常见的有<code>四种方式</code>，先序&#x2F;中序&#x2F;后序，取决于访问根节点（root）的时机<ul>
<li>先序遍历：根节点 - 左子树 - 右子树</li>
<li>中序遍历：左子树 - 根节点 - 右子树</li>
<li>后序遍历：左子树 - 右子树 - 根节点</li>
<li>层序遍历：从上向下逐层遍历</li>
</ul>
</li>
</ul>
<h4 id="10-1-先序遍历"><a href="#10-1-先序遍历" class="headerlink" title="10.1 先序遍历"></a>10.1 先序遍历</h4><ul>
<li><p>遍历过程为：</p>
<ul>
<li>①访问根节点</li>
<li>②先序遍历其左子树</li>
<li>③先序遍历其右子树</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750336811162.png" alt="75033681116"></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750336837859.png" alt="75033683785"></p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="title function_">preOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">preOrderTraverseNode</span>(<span class="params">node: TreeNode&lt;T&gt; | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：11 - 7 - 5 - 3 - 6 - 9 - 8 - 10 - 15 - 13 - 12 - 14 - 20 - 18 - 25</span></span><br></pre></td></tr></table></figure>

<ul>
<li>先序遍历（非递归 – 课下扩展）</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750573814901.png" alt="75057381490"> </p>
<h4 id="10-2-中序遍历"><a href="#10-2-中序遍历" class="headerlink" title="10.2 中序遍历"></a>10.2 中序遍历</h4><ul>
<li>遍历过程为：<ul>
<li>①中序遍历其左子树</li>
<li>②访问根节点</li>
<li>③中序遍历其右子树</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750337966689.png" alt="75033796668"></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750338193532.png" alt="75033819353"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="title function_">inOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">inOrderTraverseNode</span>(<span class="params">node: TreeNode&lt;T&gt; | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 输出：3 - 5 - 6 - 7 - 8 - 9 - 10 - 11 - 12 - 13 - 14 - 15 - 18 - 20 - 25</span></span><br></pre></td></tr></table></figure>

<ul>
<li>中序遍历（非递归 – 课下扩展）</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750573979501.png" alt="75057397950"> </p>
<h4 id="10-3-后序遍历"><a href="#10-3-后序遍历" class="headerlink" title="10.3 后序遍历"></a>10.3 后序遍历</h4><ul>
<li>遍历过程为：<ul>
<li>①后序遍历其左子树</li>
<li>②后序遍历其右子树</li>
<li>③访问根节点</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750338331227.png" alt="75033833122"></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750338346984.png" alt="75033834698"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="title function_">postOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">postOrderTraverseNode</span>(<span class="params">node: TreeNode&lt;T&gt; | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：3 - 6 - 5 - 8 - 10 - 9 - 7 - 12 - 14 - 13 - 18 - 25 - 20 - 15 - 11</span></span><br></pre></td></tr></table></figure>

<ul>
<li>后序遍历（非递归 – 课下扩展）</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750574009556.png" alt="75057400955"> </p>
<h4 id="10-4-层序遍历"><a href="#10-4-层序遍历" class="headerlink" title="10.4 层序遍历"></a>10.4 层序遍历</h4><ul>
<li>遍历过程为：<ul>
<li>层序遍历很好理解，就是从上向下逐层遍历</li>
<li>层序遍历通常我们会借助于队列来完成，也是队列的一个经典应用场景</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750338438574.png" alt="75033843857"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="title function_">levelOrderTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 没有根节点，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个队列</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">TreeNode</span>&lt;T&gt;[] = [];</span><br><span class="line">  queue.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = queue.<span class="title function_">shift</span>()!;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(current?.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      queue.<span class="title function_">push</span>(current.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      queue.<span class="title function_">push</span>(current.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：11 - 7 - 15 - 5 - 9 - 13 - 20 - 3 - 6 - 8 - 10 - 12 - 14 - 18 - 25</span></span><br></pre></td></tr></table></figure>

<h3 id="11-二叉搜索树最大值-amp-最小值"><a href="#11-二叉搜索树最大值-amp-最小值" class="headerlink" title="11. 二叉搜索树最大值 &amp; 最小值"></a>11. 二叉搜索树最大值 &amp; 最小值</h3><ul>
<li>在二叉搜索树中搜索最值是一件非常简单的事情，其实用眼睛看就可以看出来了</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750338713742.png" alt="75033871374"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小值：3</span></span><br><span class="line"><span class="title function_">getMinValue</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">  <span class="keyword">while</span> (current &amp;&amp; current.<span class="property">left</span>) &#123;</span><br><span class="line">    current = current.<span class="property">left</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大值：25</span></span><br><span class="line"><span class="title function_">getMaxValue</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">  <span class="keyword">while</span> (current &amp;&amp; current.<span class="property">right</span>) &#123;</span><br><span class="line">    current = current.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-二叉搜索树搜索操作"><a href="#12-二叉搜索树搜索操作" class="headerlink" title="12. 二叉搜索树搜索操作"></a>12. 二叉搜索树搜索操作</h3><ul>
<li>二叉搜索树不仅仅获取最值效率非常高，搜索特定的值效率也非常高<ul>
<li>注意：这里的实现返回boolean类型即可</li>
</ul>
</li>
<li>代码解析：<ul>
<li>这里我们还是使用了递归的方式</li>
<li>递归必须有退出条件，我们这里是两种情况下退出<ul>
<li>node &#x3D;&#x3D;&#x3D; null，也就是后面不再有节点的时候</li>
<li>找到对应的value，也就是node.value &#x3D;&#x3D;&#x3D; value的时候</li>
</ul>
</li>
<li>在其他情况下，根据node.的value和传入的value进行比较来决定向左还是向右查找<ul>
<li>如果node.value &gt; value，那么说明传入的值更小，需要向左查找</li>
<li>如果node.value &lt; value，那么说明传入的值更大，需要向右查找</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索</span></span><br><span class="line"><span class="title function_">search</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">searchNode</span>(<span class="attr">node</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span>, <span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="comment">// 1.如果节点为null，那么直接退出递归</span></span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.判断节点的value和传入的value的大小</span></span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">value</span> &gt; value) &#123;</span><br><span class="line">    <span class="comment">// 在左边继续查找</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(node.<span class="property">left</span>, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">value</span> &lt; value) &#123;</span><br><span class="line">    <span class="comment">// 在右边继续查找</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(node.<span class="property">right</span>, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>search搜索特定的值（非递归）</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索</span></span><br><span class="line"><span class="title function_">search</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">value</span> === value) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">value</span> &lt; value) &#123;</span><br><span class="line">      current = current.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = current.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-二叉搜索树删除操作"><a href="#13-二叉搜索树删除操作" class="headerlink" title="13. 二叉搜索树删除操作"></a>13. 二叉搜索树删除操作</h3><ul>
<li>二叉搜索树的删除有些复杂，我们一点点完成</li>
<li>删除节点要从查找要删的节点开始，找到节点后，需要考虑三种情况：<ul>
<li>该节点是叶节点 (没有字节点，比较简单)</li>
<li>该节点有一个子节点 (也相对简单)</li>
<li>该节点有两个子节点 (情况比较复杂，我们后面慢慢道来)</li>
</ul>
</li>
<li>我们先从查找要删除的节点入手</li>
<li><code>1&gt; 先找到要删除的节点，如果没有找到，不需要删除</code></li>
<li><code>2&gt; 找到要删除节点</code><ul>
<li><code>1) 删除叶子节点</code></li>
<li><code>2) 删除只有一个子节点的节点</code></li>
<li><code>3) 删除有两个子节点的节点</code></li>
</ul>
</li>
</ul>
<h4 id="13-1-情况一：没有子节点"><a href="#13-1-情况一：没有子节点" class="headerlink" title="13.1 情况一：没有子节点"></a>13.1 情况一：没有子节点</h4><ul>
<li><p>情况一：没有子节点</p>
<ul>
<li>这种情况相对比较简单，我们需要检测current的left以及right是否都为null</li>
<li>都为null之后还要检测一个东西，就是是否current就是根，都为null，并且为根，那么相当于要清空二叉树(当然，只是清空了根，因为只有它)</li>
<li>否则就把父节点的left或者right字段设置为null即可</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750584888683.png" alt="75058488868"></p>
</li>
<li><p>如果只有一个单独的根，直接删除即可</p>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750584843985.png" alt="75058484398"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索 &amp; 删除方法有重复代码，进行重构，叶子节点删除</span></span><br><span class="line"><span class="keyword">import</span> &#123; btPrint &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增属性</span></span><br><span class="line">  <span class="comment">// 当前节点的父节点</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 当前节点是父节点的左子节点</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isLeft</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="variable language_">this</span>.<span class="property">parent</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">left</span> === <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前节点是父节点的右子节点</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isRight</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="variable language_">this</span>.<span class="property">parent</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">right</span> === <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">root</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印树的方法</span></span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用coderwhy老师封装的库hy-algokit，查看树的结构</span></span><br><span class="line">    <span class="comment">// 传入树的根节点</span></span><br><span class="line">    <span class="title function_">btPrint</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">searchNode</span>(<span class="attr">value</span>: T): <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">parent</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      <span class="comment">// 1.如果找到current，直接返回即可</span></span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">value</span> === value) &#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.继续向下找</span></span><br><span class="line">      parent = current;</span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">value</span> &lt; value) &#123;</span><br><span class="line">        current = current.<span class="property">right</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current = current.<span class="property">left</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果current有值，那么current保存自己的父节点</span></span><br><span class="line">      <span class="keyword">if</span> (current) current.<span class="property">parent</span> = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入数据的操作</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.创建新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断是否有根节点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入非根节点</span></span><br><span class="line">  <span class="title function_">insertNode</span>(<span class="params">node: TreeNode&lt;T&gt;, newNode: TreeNode&lt;T&gt;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newNode.<span class="property">value</span> &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">      <span class="comment">// 向左子树插入</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">left</span> = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 向右子树插入</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">right</span> = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索方法重构</span></span><br><span class="line">  <span class="title function_">search</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!<span class="variable language_">this</span>.<span class="title function_">searchNode</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 1.搜索：当前是否有这个value</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (!current) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取三个属性：当前节点、父节点、当前节点是父节点的左子节点还是右子节点</span></span><br><span class="line">    <span class="comment">// 2.1.如果删除的是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (current === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点是根节点</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">isLeft</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点是父节点的左子节点</span></span><br><span class="line">        current.<span class="property">parent</span>!.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前节点是父节点的右子节点</span></span><br><span class="line">        current.<span class="property">parent</span>!.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bst = <span class="keyword">new</span> <span class="title class_">BSTree</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">11</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">7</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">15</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">5</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">3</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">9</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">8</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">10</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">13</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">12</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">14</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">20</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">18</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">25</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用打印树的方法</span></span><br><span class="line">bst.<span class="title function_">print</span>();</span><br><span class="line">bst.<span class="title function_">remove</span>(<span class="number">6</span>);</span><br><span class="line">bst.<span class="title function_">remove</span>(<span class="number">12</span>);</span><br><span class="line">bst.<span class="title function_">print</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750589040635.png" alt="75058904063"></p>
<h4 id="13-2-情况二：一个子节点"><a href="#13-2-情况二：一个子节点" class="headerlink" title="13.2 情况二：一个子节点"></a>13.2 情况二：一个子节点</h4><ul>
<li><p>情况二：有一个子节点</p>
<ul>
<li>这种情况也不是很难</li>
<li>要删除的current节点，只有2个连接(如果有两个子节点，就是三个连接了)，一个连接父节点，一个连接唯一的子节点</li>
<li>需要从这三者之间：爷爷 - 自己 - 儿子，将自己(current)剪短，让爷爷直接连接儿子即可</li>
<li>这个过程要求改变父节点的left或者right，指向要删除节点的子节点</li>
<li>当然，在这个过程中还要考虑是否current就是根</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750585029594.png" alt="75058502959"></p>
</li>
<li><p>图解过程</p>
<ul>
<li>如果是根的情况，大家可以自己画一下，比较简单，这里不再给出</li>
<li>如果不是根，并且只有一个子节点的情况</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="title function_">remove</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="comment">// 1.搜索：当前是否有这个value</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(value);</span><br><span class="line">  <span class="keyword">if</span> (!current) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.获取三个属性：当前节点、父节点、当前节点是父节点的左子节点还是右子节点</span></span><br><span class="line">  <span class="comment">// 2.1.如果删除的是叶子节点</span></span><br><span class="line">  <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="comment">// 当前节点是根节点</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">isLeft</span>) &#123;</span><br><span class="line">      <span class="comment">// 当前节点是父节点的左子节点</span></span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当前节点是父节点的右子节点</span></span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.2.只有一个子节点：只有左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (current === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = current.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">isLeft</span>) &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">left</span> = current.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">right</span> = current.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.2.只有一个子节点：只有右子节点</span></span><br><span class="line">    <span class="keyword">if</span> (current === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = current.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">isLeft</span>) &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">left</span> = current.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">right</span> = current.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-3-情况三：两个子节点"><a href="#13-3-情况三：两个子节点" class="headerlink" title="13.3 情况三：两个子节点"></a>13.3 情况三：两个子节点</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750585050114.png" alt="75058505011"></p>
<ul>
<li>如果我们要<code>删除的节点有两个子节点</code>，甚至<code>子节点还有子节点</code>，这种情况下我们需要从<code>下面的子节点中找到一个节点</code>，来替换<code>当前的节点</code></li>
<li>但是找到的这个节点<code>有什么特征呢</code>？ 应该是current节点下面所有节点中<code>最接近current节点</code>的<ul>
<li>要么<code>比current节点小一点点</code>，要么比<code>current节点大一点点</code></li>
<li>总结你<code>最接近current</code>，你就可以用来<code>替换current的位置</code></li>
</ul>
</li>
<li>这个节点怎么找呢？<ul>
<li>比current<code>小一点点的节点</code>，一定是current<code>左子树的最大值</code></li>
<li>比current<code>大一点点的节点</code>，一定是current<code>右子树的最小值</code></li>
</ul>
</li>
<li>前驱&amp;后继<ul>
<li>在二叉搜索树中，这两个特别的节点，有两个<code>特别的名字</code></li>
<li>比current小一点点的节点，称为current节点的<code>前驱</code></li>
<li>比current大一点点的节点，称为current节点的<code>后继</code></li>
</ul>
</li>
<li>也就是为了能够删除有两个子节点的current，要么找到它的前驱，要么找到它的后继</li>
<li>所以，接下来，我们先找到这样的节点 (前驱或者后继都可以，我这里以找后继为例)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现删除操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">getSuccessor</span>(<span class="attr">delNode</span>: <span class="title class_">TreeNode</span>&lt;T&gt;): <span class="title class_">TreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取右子树</span></span><br><span class="line">  <span class="keyword">let</span> current = delNode.<span class="property">right</span>;</span><br><span class="line">  <span class="comment">// 后继节点</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">successor</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找右子树的最小节点</span></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    successor = current;</span><br><span class="line">    current = current.<span class="property">left</span>;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">      current.<span class="property">parent</span> = successor;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (successor !== delNode.<span class="property">right</span>) &#123;</span><br><span class="line">    successor!.<span class="property">parent</span>!.<span class="property">left</span> = successor!.<span class="property">right</span>;</span><br><span class="line">    successor!.<span class="property">right</span> = delNode.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将删除节点的left，赋值给后继节点的left</span></span><br><span class="line">  successor!.<span class="property">left</span> = delNode.<span class="property">left</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到了后继节点</span></span><br><span class="line">  <span class="keyword">return</span> successor!;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="title function_">remove</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="comment">// 1.搜索：当前是否有这个value</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(value);</span><br><span class="line">  <span class="keyword">if</span> (!current) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.获取三个属性：当前节点、父节点、当前节点是父节点的左子节点还是右子节点</span></span><br><span class="line">  <span class="comment">// 2.1.如果删除的是叶子节点</span></span><br><span class="line">  <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="comment">// 当前节点是根节点</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">isLeft</span>) &#123;</span><br><span class="line">      <span class="comment">// 当前节点是父节点的左子节点</span></span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当前节点是父节点的右子节点</span></span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.2.只有一个子节点：只有左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (current === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = current.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">isLeft</span>) &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">left</span> = current.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">right</span> = current.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.2.只有一个子节点：只有右子节点</span></span><br><span class="line">    <span class="keyword">if</span> (current === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = current.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">isLeft</span>) &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">left</span> = current.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">right</span> = current.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 2.2.有两个子节点</span></span><br><span class="line">    <span class="keyword">const</span> successor = <span class="variable language_">this</span>.<span class="title function_">getSuccessor</span>(current);</span><br><span class="line">    <span class="keyword">if</span> (current === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">isLeft</span>) &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">left</span> = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">right</span> = successor;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-4-删除操作总结"><a href="#13-4-删除操作总结" class="headerlink" title="13.4 删除操作总结"></a>13.4 删除操作总结</h4><ul>
<li>看到这里，你就会发现删除节点<code>相当棘手</code></li>
<li>实际上，因为它<code>非常复杂</code>，一些程序员都尝试着避开<code>删除操作</code><ul>
<li>他们的做法是在Node类中添加一个boolean的字段，比如名称为<code>isDeleted</code></li>
<li>要删除一个节点时，就将此字段设置为<code>true</code></li>
<li>其他操作，比如find()在查找之前先判断这个节点是不是标记为删除</li>
<li>这样相对比较简单，每次删除节点不会改变原有的树结构</li>
<li>但是在二叉树的存储中，还保留着那些本该已经被删除掉的节点</li>
</ul>
</li>
<li>上面的做法看起来很<code>聪明</code>，其实是一种<code>逃避</code><ul>
<li>这样会造成<code>很大空间的浪费</code>，特别是针对数据量较大的情况</li>
<li>而且，作为程序员要学会通过这些<code>复杂的操作</code>，锻炼<code>自己的逻辑</code></li>
</ul>
</li>
</ul>
<h3 id="14-二叉搜索树完整封装"><a href="#14-二叉搜索树完整封装" class="headerlink" title="14. 二叉搜索树完整封装"></a>14. 二叉搜索树完整封装</h3><h4 id="14-1-代码重构"><a href="#14-1-代码重构" class="headerlink" title="14.1 代码重构"></a>14.1 代码重构</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; btPrint &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增属性</span></span><br><span class="line">  <span class="comment">// 当前节点的父节点</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 当前节点是父节点的左子节点</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isLeft</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="variable language_">this</span>.<span class="property">parent</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">left</span> === <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前节点是父节点的右子节点</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isRight</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="variable language_">this</span>.<span class="property">parent</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">right</span> === <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">root</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印树的方法</span></span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用coderwhy老师封装的库hy-algokit，查看树的结构</span></span><br><span class="line">    <span class="comment">// 传入树的根节点</span></span><br><span class="line">    <span class="title function_">btPrint</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">searchNode</span>(<span class="attr">value</span>: T): <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">parent</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      <span class="comment">// 1.如果找到current，直接返回即可</span></span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">value</span> === value) &#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.继续向下找</span></span><br><span class="line">      parent = current;</span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">value</span> &lt; value) &#123;</span><br><span class="line">        current = current.<span class="property">right</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current = current.<span class="property">left</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果current有值，那么current保存自己的父节点</span></span><br><span class="line">      <span class="keyword">if</span> (current) current.<span class="property">parent</span> = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入数据的操作</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.创建新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断是否有根节点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入非根节点</span></span><br><span class="line">  <span class="title function_">insertNode</span>(<span class="params">node: TreeNode&lt;T&gt;, newNode: TreeNode&lt;T&gt;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newNode.<span class="property">value</span> &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">      <span class="comment">// 向左子树插入</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">left</span> = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 向右子树插入</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">right</span> = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先序遍历</span></span><br><span class="line">  <span class="title function_">preOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">preOrderTraverseNode</span>(<span class="params">node: TreeNode&lt;T&gt; | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中序遍历</span></span><br><span class="line">  <span class="title function_">inOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">inOrderTraverseNode</span>(<span class="params">node: TreeNode&lt;T&gt; | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后序遍历</span></span><br><span class="line">  <span class="title function_">postOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">postOrderTraverseNode</span>(<span class="params">node: TreeNode&lt;T&gt; | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 层序遍历</span></span><br><span class="line">  <span class="title function_">levelOrderTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 没有根节点，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个队列</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">TreeNode</span>&lt;T&gt;[] = [];</span><br><span class="line">    queue.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = queue.<span class="title function_">shift</span>()!;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(current?.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(current.<span class="property">left</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(current.<span class="property">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最小值</span></span><br><span class="line">  <span class="title function_">getMinValue</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current.<span class="property">left</span>) &#123;</span><br><span class="line">      current = current.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大值</span></span><br><span class="line">  <span class="title function_">getMaxValue</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current.<span class="property">right</span>) &#123;</span><br><span class="line">      current = current.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索</span></span><br><span class="line">  <span class="title function_">search</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!<span class="variable language_">this</span>.<span class="title function_">searchNode</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现删除操作</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getSuccessor</span>(<span class="attr">delNode</span>: <span class="title class_">TreeNode</span>&lt;T&gt;): <span class="title class_">TreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取右子树</span></span><br><span class="line">    <span class="keyword">let</span> current = delNode.<span class="property">right</span>;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">successor</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找右子树的最小节点</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      successor = current;</span><br><span class="line">      current = current.<span class="property">left</span>;</span><br><span class="line">      <span class="keyword">if</span> (current) &#123;</span><br><span class="line">        current.<span class="property">parent</span> = successor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (successor !== delNode.<span class="property">right</span>) &#123;</span><br><span class="line">      successor!.<span class="property">parent</span>!.<span class="property">left</span> = successor!.<span class="property">right</span>;</span><br><span class="line">      successor!.<span class="property">right</span> = delNode.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将删除节点的left，赋值给后继节点的left</span></span><br><span class="line">    successor!.<span class="property">left</span> = delNode.<span class="property">left</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到了后继节点</span></span><br><span class="line">    <span class="keyword">return</span> successor!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 1.搜索：当前是否有这个value</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (!current) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取三个属性：当前节点、父节点、当前节点是父节点的左子节点还是右子节点</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">replaceNode</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1.如果删除的是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      replaceNode = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.2.只有一个子节点：只有左子节点</span></span><br><span class="line">      replaceNode = current.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.2.只有一个子节点：只有右子节点</span></span><br><span class="line">      replaceNode = current.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 2.2.有两个子节点</span></span><br><span class="line">      <span class="keyword">const</span> successor = <span class="variable language_">this</span>.<span class="title function_">getSuccessor</span>(current);</span><br><span class="line">      replaceNode = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = replaceNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">isLeft</span>) &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">left</span> = replaceNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">right</span> = replaceNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-2-树存放对象"><a href="#14-2-树存放对象" class="headerlink" title="14.2 树存放对象"></a>14.2 树存放对象</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> price: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 用于比较对象</span></span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">price</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bst = <span class="keyword">new</span> <span class="title class_">BSTree</span>&lt;<span class="title class_">Product</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;iPhone&quot;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;huawei&quot;</span>, <span class="number">120</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;xiaomi&quot;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="keyword">const</span> p4 = <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;oppo&quot;</span>, <span class="number">90</span>);</span><br><span class="line"><span class="keyword">const</span> p5 = <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;vivo&quot;</span>, <span class="number">70</span>);</span><br><span class="line"></span><br><span class="line">bst.<span class="title function_">insert</span>(p1);</span><br><span class="line">bst.<span class="title function_">insert</span>(p2);</span><br><span class="line">bst.<span class="title function_">insert</span>(p3);</span><br><span class="line">bst.<span class="title function_">insert</span>(p4);</span><br><span class="line">bst.<span class="title function_">insert</span>(p5);</span><br><span class="line"></span><br><span class="line">bst.<span class="title function_">print</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751546431543.png" alt="75154643154"></p>
<ul>
<li><strong>树打印展示对象类型</strong></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; btPrint, <span class="title class_">PrintableNode</span> &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node类里面的value改成了data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">data</span>: T;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面新增实现接口：PrintableNode，实现接口必须有接口里面所有的属性</span></span><br><span class="line"><span class="comment">// interface PrintableNode &#123;</span></span><br><span class="line"><span class="comment">//   left: PrintableNode | null;</span></span><br><span class="line"><span class="comment">//   right: PrintableNode | null;</span></span><br><span class="line"><span class="comment">//   value: any;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">PrintableNode</span> &#123;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增一个属性value</span></span><br><span class="line">  <span class="comment">// 打印树的时候，hy-algokit库取值是value属性，我们自定义一个value</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">data</span> <span class="keyword">as</span> <span class="title class_">Product</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;data.name&#125;</span>-<span class="subst">$&#123;data.price&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增属性</span></span><br><span class="line">  <span class="comment">// 当前节点的父节点</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 当前节点是父节点的左子节点</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isLeft</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="variable language_">this</span>.<span class="property">parent</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">left</span> === <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前节点是父节点的右子节点</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isRight</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="variable language_">this</span>.<span class="property">parent</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">right</span> === <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">root</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印树的方法</span></span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用coderwhy老师封装的库hy-algokit，查看树的结构</span></span><br><span class="line">    <span class="comment">// 传入树的根节点</span></span><br><span class="line">    <span class="title function_">btPrint</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">searchNode</span>(<span class="attr">value</span>: T): <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">parent</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      <span class="comment">// 1.如果找到current，直接返回即可</span></span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">data</span> === value) &#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.继续向下找</span></span><br><span class="line">      parent = current;</span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">data</span> &lt; value) &#123;</span><br><span class="line">        current = current.<span class="property">right</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current = current.<span class="property">left</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果current有值，那么current保存自己的父节点</span></span><br><span class="line">      <span class="keyword">if</span> (current) current.<span class="property">parent</span> = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入数据的操作</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.创建新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断是否有根节点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入非根节点</span></span><br><span class="line">  <span class="title function_">insertNode</span>(<span class="params">node: TreeNode&lt;T&gt;, newNode: TreeNode&lt;T&gt;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newNode.<span class="property">data</span> &lt; node.<span class="property">data</span>) &#123;</span><br><span class="line">      <span class="comment">// 向左子树插入</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">left</span> = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 向右子树插入</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">right</span> = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先序遍历</span></span><br><span class="line">  <span class="title function_">preOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">preOrderTraverseNode</span>(<span class="params">node: TreeNode&lt;T&gt; | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">data</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中序遍历</span></span><br><span class="line">  <span class="title function_">inOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">inOrderTraverseNode</span>(<span class="params">node: TreeNode&lt;T&gt; | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">data</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后序遍历</span></span><br><span class="line">  <span class="title function_">postOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">postOrderTraverseNode</span>(<span class="params">node: TreeNode&lt;T&gt; | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 层序遍历</span></span><br><span class="line">  <span class="title function_">levelOrderTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 没有根节点，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个队列</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">TreeNode</span>&lt;T&gt;[] = [];</span><br><span class="line">    queue.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = queue.<span class="title function_">shift</span>()!;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(current?.<span class="property">data</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(current.<span class="property">left</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(current.<span class="property">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最小值</span></span><br><span class="line">  <span class="title function_">getMinValue</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current.<span class="property">left</span>) &#123;</span><br><span class="line">      current = current.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current?.<span class="property">data</span> ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大值</span></span><br><span class="line">  <span class="title function_">getMaxValue</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current.<span class="property">right</span>) &#123;</span><br><span class="line">      current = current.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current?.<span class="property">data</span> ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索</span></span><br><span class="line">  <span class="title function_">search</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!<span class="variable language_">this</span>.<span class="title function_">searchNode</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现删除操作</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getSuccessor</span>(<span class="attr">delNode</span>: <span class="title class_">TreeNode</span>&lt;T&gt;): <span class="title class_">TreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取右子树</span></span><br><span class="line">    <span class="keyword">let</span> current = delNode.<span class="property">right</span>;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">successor</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找右子树的最小节点</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      successor = current;</span><br><span class="line">      current = current.<span class="property">left</span>;</span><br><span class="line">      <span class="keyword">if</span> (current) &#123;</span><br><span class="line">        current.<span class="property">parent</span> = successor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (successor !== delNode.<span class="property">right</span>) &#123;</span><br><span class="line">      successor!.<span class="property">parent</span>!.<span class="property">left</span> = successor!.<span class="property">right</span>;</span><br><span class="line">      successor!.<span class="property">right</span> = delNode.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将删除节点的left，赋值给后继节点的left</span></span><br><span class="line">    successor!.<span class="property">left</span> = delNode.<span class="property">left</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到了后继节点</span></span><br><span class="line">    <span class="keyword">return</span> successor!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 1.搜索：当前是否有这个value</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (!current) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取三个属性：当前节点、父节点、当前节点是父节点的左子节点还是右子节点</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">replaceNode</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1.如果删除的是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      replaceNode = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.2.只有一个子节点：只有左子节点</span></span><br><span class="line">      replaceNode = current.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.2.只有一个子节点：只有右子节点</span></span><br><span class="line">      replaceNode = current.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 2.2.有两个子节点</span></span><br><span class="line">      <span class="keyword">const</span> successor = <span class="variable language_">this</span>.<span class="title function_">getSuccessor</span>(current);</span><br><span class="line">      replaceNode = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = replaceNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">isLeft</span>) &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">left</span> = replaceNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">right</span> = replaceNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> price: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 用于比较对象</span></span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">price</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bst = <span class="keyword">new</span> <span class="title class_">BSTree</span>&lt;<span class="title class_">Product</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;iPhone&quot;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;huawei&quot;</span>, <span class="number">120</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;xiaomi&quot;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="keyword">const</span> p4 = <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;oppo&quot;</span>, <span class="number">90</span>);</span><br><span class="line"><span class="keyword">const</span> p5 = <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;vivo&quot;</span>, <span class="number">70</span>);</span><br><span class="line"></span><br><span class="line">bst.<span class="title function_">insert</span>(p1);</span><br><span class="line">bst.<span class="title function_">insert</span>(p2);</span><br><span class="line">bst.<span class="title function_">insert</span>(p3);</span><br><span class="line">bst.<span class="title function_">insert</span>(p4);</span><br><span class="line">bst.<span class="title function_">insert</span>(p5);</span><br><span class="line"></span><br><span class="line">bst.<span class="title function_">print</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751547886783.png" alt="75154788678"></p>
<h3 id="15-二叉搜索树的缺陷"><a href="#15-二叉搜索树的缺陷" class="headerlink" title="15. 二叉搜索树的缺陷"></a>15. 二叉搜索树的缺陷</h3><ul>
<li><p>二叉搜索树作为数据存储的结构有重要的优势</p>
<ul>
<li>可以<code>快速的</code>找到给定关键字的数据项 并且可以快速地<code>插入和删除数据项</code></li>
</ul>
</li>
<li><p>但是，二叉搜索树有一个很麻烦的问题：</p>
<ul>
<li><p>如果插入的数据时<code>有序的数据</code>，比如下面的情况</p>
</li>
<li><p>有一棵初始化为 9 8 12 的二叉树</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750600084923.png" alt="75060008492"> </p>
</li>
<li><p>插入下面的数据：7 6 5 4 3</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750600114533.png" alt="75060011453"></p>
</li>
</ul>
</li>
<li><p>非平衡树：</p>
<ul>
<li>较好的二叉搜索树数据应该是<code>左右分布均匀</code>的</li>
<li>但是插入<code>连续数据</code>后，<code>分布的不均匀</code>，我称这种树为<code>非平衡树</code></li>
<li>对于一棵<code>平衡二叉树</code>来说，插入&#x2F;查找等操作的效率是<code>O(logN)</code></li>
<li>对于一棵<code>非平衡二叉树</code>，相当于编写了一个链表，查找效率变成了<code>O(N)</code></li>
</ul>
</li>
</ul>
<h3 id="16-树的平衡性"><a href="#16-树的平衡性" class="headerlink" title="16. 树的平衡性"></a>16. 树的平衡性</h3><ul>
<li>为了能以<code>较快的时间O(logN)</code>来操作一棵树，我们需要<code>保证树总是平衡</code>的：<ul>
<li>至少大部分是平衡的，那么时间复杂度也是接近O(logN)的</li>
<li>也就是说树中<code>每个节点左边的子孙节点</code>的个数，应该尽可能的等于<code>右边的子孙节点的个数</code></li>
<li>常见的平衡树有哪些呢？</li>
</ul>
</li>
<li>AVL树：<ul>
<li>AVL树是最早的一种平衡树。它有些办法保持<code>树的平衡</code>(每个节点多存储了一个额外的数据)</li>
<li>因为AVL树是<code>平衡的</code>，所以时间复杂度也是O(logN)</li>
<li>但是，每次插入&#x2F;删除操作相对于红黑树效率都不高，所以<code>整体效率不如红黑树</code></li>
</ul>
</li>
<li>红黑树：<ul>
<li>红黑树也通过<code>一些特性</code>来保持树的平衡</li>
<li>因为是平衡树，所以时间复杂度也是在O(logN)</li>
<li>另外插入&#x2F;删除等操作，红黑树的性能要优于AVL树，所以现在平衡树的应用基本都是红黑树</li>
</ul>
</li>
</ul>
<h2 id="八-图结构（Graph）"><a href="#八-图结构（Graph）" class="headerlink" title="(八) 图结构（Graph）"></a>(八) 图结构（Graph）</h2><h3 id="1-认识图结构以及特性"><a href="#1-认识图结构以及特性" class="headerlink" title="1. 认识图结构以及特性"></a>1. 认识图结构以及特性</h3><h4 id="1-1-什么是图"><a href="#1-1-什么是图" class="headerlink" title="1.1 什么是图?"></a>1.1 什么是图?</h4><ul>
<li>在计算机程序设计中，<code>图结构</code>也是一种非常常见的数据结构<ul>
<li>但是，<code>图论</code>其实是一个非常大的话题</li>
<li>我们通过本章的学习来认识一下关于图的一些内容 - 图的抽象数据类型 – 一些算法实现</li>
</ul>
</li>
<li>什么是图?<ul>
<li>图结构是一种与<code>树结构</code>有些相似的数据结构</li>
<li><code>图论</code>是<code>数学</code>的一个分支，并且，在数学的概念上，<code>树是图的一种</code></li>
<li>它以图为研究对象，研究<code>顶点</code> 和<code>边</code>组成的<code>图形的数学理论和方法</code></li>
<li>主要研究的目的是<code>事物之间的关系</code>，<code>顶点</code>代表<code>事物</code>，<code>边</code>代表两个事物间的<code>关系</code></li>
</ul>
</li>
<li>我们知道树可以用来模拟很多现实的数据结构<ul>
<li>比如： <code>家谱/公司组织架构</code>等等</li>
<li>那么图长什么样子? </li>
<li>或者什么样的数据使用图来模拟更合适呢?</li>
</ul>
</li>
</ul>
<h4 id="1-2-图的现实案例"><a href="#1-2-图的现实案例" class="headerlink" title="1.2 图的现实案例"></a>1.2 图的现实案例</h4><ul>
<li><p>人与人之间的关系网</p>
<ul>
<li>甚至科学家们在观察人与人之间的关系网时，还发现了<code>六度空间理论</code></li>
</ul>
</li>
<li><p>六度空间理论</p>
<ul>
<li>理论上认为世界上任何两个互相不认识的两人</li>
<li>只需要很少的中间人就可以建立起联系</li>
<li>并非一定要经过6步，只是需要很少的步骤</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750600906154.png" alt="75060090615"></p>
</li>
<li><p>图的实现案例一：北京地铁图</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750600989028.png" alt="75060098902"></p>
</li>
<li><p>图的现实案例二：村庄间的关系网</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750601015039.png" alt="75060101503"></p>
</li>
</ul>
<h4 id="1-3-再次-什么是图"><a href="#1-3-再次-什么是图" class="headerlink" title="1.3 再次 什么是图?"></a>1.3 再次 什么是图?</h4><ul>
<li>那么，什么是图呢?<ul>
<li>我们会发现，上面的节点(其实图中叫<code>顶点Vertex</code>)之间的关系，是不能使用树来表示</li>
<li>使用<code>任何的树结构</code>都不可以模拟</li>
<li>这个时候，我们就可以使用图来模拟它们</li>
</ul>
</li>
<li>图通常有什么特点呢?<ul>
<li><code>一组顶点</code>：通常用 V (Vertex) 表示顶点的集合</li>
<li><code>一组边</code>：通常用 E (Edge) 表示边的集合<ul>
<li>边是顶点和顶点之间的连线</li>
<li>边可以是有向的，也可以是无向的</li>
<li>比如A — B，通常表示无向。 A –&gt; B，通常表示有向</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-4-历史故事"><a href="#1-4-历史故事" class="headerlink" title="1.4 历史故事"></a>1.4 历史故事</h4><ul>
<li><p>18世纪著名古典数学问题之一</p>
<ul>
<li>在哥尼斯堡的一个公园里，有<code>七座桥</code>将<code>普雷格尔河中两个岛</code>及<code>岛与河岸连接起来</code>(如图)</li>
<li>有人提出问题： 一个人怎样才能不重复、不遗漏地一次走完七座桥，最后回到出发点</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750601308650.png" alt="75060130865"></p>
</li>
<li><p>1735年，有<code>几名大学生</code>写信给当时正在俄罗斯的彼得斯堡科学院任职的瑞典天才数学家<code>欧拉</code>，请他帮忙解决这一问题</p>
<ul>
<li>欧拉在亲自观察了哥伦斯堡的七桥后，认真思考走法，但是始终没有成功，于是他怀疑七桥问题是不是无解的</li>
<li>1736年29岁的欧拉向<code>彼得斯堡</code>科学院递交了《哥尼斯堡的七座桥》的论文，在解答问题的同时，开创了数学的一个新的分支——<code>图论与几何拓扑</code>，也由此展开了数学史上的新历程</li>
</ul>
</li>
</ul>
<h3 id="2-欧拉和七桥问题解法"><a href="#2-欧拉和七桥问题解法" class="headerlink" title="2. 欧拉和七桥问题解法"></a>2. 欧拉和七桥问题解法</h3><ul>
<li><p>他不仅解决了该问题，并且给出了<code>连通图</code>可以一笔画的充要条件是：</p>
<ul>
<li><code>奇点的数目不是0个就是2个</code></li>
<li>连到一点的<code>边的数目</code>如果是<code>奇数条</code>，就称为奇点</li>
<li>如果是<code>偶数条</code>就称为偶点</li>
<li>要想一笔画成，必须中间点均是偶点</li>
<li>也就是有<code>来路必有另一条去路，奇点只可能在两端</code>，因此<code>任何图能一笔画成，奇点要么没有要么在两端</code></li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750774039800.png" alt="75077403980"></p>
</li>
<li><p>个人思考：</p>
<ul>
<li>欧拉在思考这个问题的时候，并不是针对某一个特性的问题去考虑，而是将<code>岛和桥</code>抽象成了<code>点和线</code></li>
<li>抽象是<code>数学的本质</code>，而编程我们也一再强调抽象的重要性</li>
<li>汇编语言是对机器语言的抽象，高级语言是对汇编语言的抽象</li>
<li>操作系统是对硬件的抽象，应用程序在操作系统的基础上构建</li>
</ul>
</li>
</ul>
<h3 id="3-图结构的常见术语"><a href="#3-图结构的常见术语" class="headerlink" title="3. 图结构的常见术语"></a>3. 图结构的常见术语</h3><h4 id="3-1-图的术语"><a href="#3-1-图的术语" class="headerlink" title="3.1 图的术语"></a>3.1 图的术语</h4><ul>
<li><p>关于术语的概述</p>
<ul>
<li>我们在学习树的时候，树有很多的<code>相关术语</code></li>
<li>了解这些术语有助于我们更好的<code>理解树结构</code></li>
</ul>
</li>
<li><p>我们也来学习一下图相关的术语</p>
<ul>
<li>但是图的术语其实<code>非常多</code>，如果你找一本专门讲图的各个方面的书籍，会发现<code>只是术语</code>就可以<code>占据满满的一个章节</code></li>
<li>这里，我们先介绍几个<code>比较常见的术语</code>，某些术语后面用到的时候，再了解</li>
<li>没有用到的，在自行深入学习的过程中，可以通过查资料去了解</li>
</ul>
</li>
<li><p>我们先来看一个<code>抽象出来的图</code>，用<code>数字</code>更容易我们从整体来<code>观察整个图结构</code></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750774457960.png" alt="75077445796"></p>
</li>
<li><p><strong>顶点：</strong></p>
<ul>
<li>顶点刚才我们已经介绍过了，表示图中的一个<code>节点</code></li>
<li>比如地铁站中<code>某个站/多个村庄中的某个村庄/互联网中的某台主机/人际关系中的人</code></li>
</ul>
</li>
<li><p><strong>边：</strong></p>
<ul>
<li>边刚才我们也介绍过了，表示<code>顶点和顶点</code>之间的<code>连线</code></li>
<li>比如地铁站中<code>两个站点之间</code>的直接连线，就是一个边</li>
<li>注意： 这里的边不要叫做路径，路径有其他的概念，待会儿我们会介绍到</li>
<li>之前的图中： 0 - 1有一条边，1 - 2有一条边，0 - 2没有边</li>
</ul>
</li>
<li><p><strong>相邻顶点：</strong></p>
<ul>
<li>由一条边连接在一起的顶点称为<code>相邻顶点</code></li>
<li>比如0 - 1是相邻的，0 - 3是相邻的。 0 - 2是不相邻的</li>
</ul>
</li>
<li><p><strong>度：</strong></p>
<ul>
<li>一个顶点的度是<code>相邻顶点的数量</code></li>
<li>比如0顶点和其他两个顶点相连，0顶点的度是2</li>
<li>比如1顶点和其他四个顶点相连，1顶点的度是4</li>
</ul>
</li>
<li><p><strong>路径：</strong></p>
<ul>
<li>路径是顶点<code>v1，v2...，vn的一个连续序列</code>，比如上图中0 1 5 9就是一条路径</li>
<li>简单路径： 简单路径要求不包含重复的顶点。 比如 0 1 5 9是一条简单路径</li>
<li>回路： 第一个顶点和最后一个顶点<code>相同</code>的路径称为回路。 比如 0 1 5 6 3 0</li>
</ul>
</li>
<li><p><strong>无向图：</strong></p>
<ul>
<li>上面的图就是一张无向图，因为<code>所有的边都没有方向</code></li>
<li>比如 0 - 1之间有变，那么说明这条边可以保证 0 -&gt; 1，也可以保证 1 -&gt; 0</li>
</ul>
</li>
<li><p><strong>有向图：</strong></p>
<ul>
<li>有向图表示的<code>图中的边</code>是有<code>方向</code>的</li>
<li>比如 0 -&gt; 1，不能保证一定可以 1 -&gt; 0，要根据方向来定</li>
</ul>
</li>
<li><p><strong>无权图：</strong></p>
<ul>
<li>我们上面的图就是<code>一张无权图</code>(边没有携带权重)</li>
<li>我们上面的图中的边是<code>没有任何意义</code>的</li>
<li>不能说 0 - 1的边，比4 - 9的边更远或者用的时间更长</li>
</ul>
</li>
<li><p><strong>带权图：</strong></p>
<ul>
<li>带权图表示<code>边有一定的权重</code></li>
<li>这里的权重可以是<code>任意你希望表示的数据</code>：比如<code>距离</code>或者<code>花费的时间</code>或者<code>票价</code></li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750774899726.png" alt="75077489972"></p>
</li>
</ul>
<h4 id="3-2-图的表示"><a href="#3-2-图的表示" class="headerlink" title="3.2 图的表示"></a>3.2 图的表示</h4><ul>
<li>怎么在程序中表示图呢?<ul>
<li>我们知道一个图包含<code>很多顶点</code>，另外包含<code>顶点和顶点之间的连线(边)</code></li>
<li>这两个都是非常重要的<code>图信息</code>，因此都需要在程序中<code>体现出来</code></li>
</ul>
</li>
<li>顶点的表示相对简单，我们先讨论顶点的表示<ul>
<li>上面的顶点，我们<code>抽象成了1 2 3 4</code>，也可以<code>抽象成A B C D</code></li>
<li>在后面的案例中，我们使用A B C D</li>
<li>那么这些A B C D我们可以使用一个<code>数组</code>来存储起来(存储所有的顶点)</li>
<li>当然，A，B，C，D也可以表示其他含义的数据(比如村庄的名字)</li>
</ul>
</li>
<li>那么边怎么表示呢？<ul>
<li>因为边是<code>两个顶点之间的关系</code>，所以<code>表示起来会稍微麻烦一些</code></li>
<li>下面，我们具体讨论一下边常见的<code>表示方式</code><ul>
<li>邻接矩阵</li>
<li>邻接表</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-邻接矩阵和邻接表"><a href="#4-邻接矩阵和邻接表" class="headerlink" title="4. 邻接矩阵和邻接表"></a>4. 邻接矩阵和邻接表</h3><h4 id="4-1-邻接矩阵"><a href="#4-1-邻接矩阵" class="headerlink" title="4.1 邻接矩阵"></a>4.1 邻接矩阵</h4><ul>
<li><p>一种比较常见的表示图的方式：<code>邻接矩阵</code></p>
<ul>
<li>接矩阵让<code>每个节点和一个整数项关联</code>，该<code>整数作为数组的下标值</code></li>
<li>我们用一个<code>二维数组来表示顶点之间的连接</code></li>
<li>二维数组[0][2] -&gt; A -&gt; C</li>
</ul>
</li>
<li><p>画图演示：</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750775749265.png" alt="75077574926"> </p>
</li>
<li><p>图片解析：</p>
<ul>
<li>在二维数组中，<code>0表示没有连线，1表示有连线</code></li>
<li>通过二维数组，我们可以很快的找到<code>一个顶点和哪些顶点有连线</code>。(比如A顶点，只需要遍历第一行即可)</li>
<li>另外，A - A，B - B(也就是顶点到自己的连线)，通常使用0表示</li>
</ul>
</li>
<li><p>邻接矩阵的问题：</p>
<ul>
<li>邻接矩阵还有一个比较严重的问题，就是如果图是一个<code>稀疏图</code></li>
<li>那么矩阵中将存在<code>大量的0</code>，这意味着我们<code>浪费了计算机存储空间来表示根本不存在的边</code></li>
</ul>
</li>
</ul>
<h4 id="4-2-邻接表"><a href="#4-2-邻接表" class="headerlink" title="4.2 邻接表"></a>4.2 邻接表</h4><ul>
<li><p>另外一种常用的表示图的方式： <code>邻接表</code></p>
<ul>
<li>邻接表由图中<code>每个顶点以及和顶点相邻的顶点列表</code>组成</li>
<li>这个列表有很多种方式来存储： <code>数组/链表/字典(哈希表)</code>都可以</li>
</ul>
</li>
<li><p>画图演示：</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750775493737.png" alt="75077549373"> </p>
</li>
<li><p>图片解析：</p>
<ul>
<li>其实图片比较容易理解</li>
<li>比如我们要表示和<code>A顶点有关联的顶点</code>(边)，<code>A和B/C/D有边</code></li>
<li>那么我们可以通过A找到对应的数组&#x2F;链表&#x2F;字典，再取出其中的内容就可以啦</li>
</ul>
</li>
<li><p>邻接表的问题：</p>
<ul>
<li>邻接表计算<code>&quot;出度&quot;</code>是比较简单的(出度： 指向别人的数量，入度： 指向自己的数量)</li>
<li>邻接表如果需要计算有向图的<code>&quot;入度&quot;</code>，那么是一件非常麻烦的事情</li>
<li>它必须构造一个<code>&quot;逆邻接表&quot;</code>，才能有效的计算”入度”。但是开发中<code>&quot;入度&quot;</code>相对用的比较少</li>
</ul>
</li>
</ul>
<h3 id="5-创建图类"><a href="#5-创建图类" class="headerlink" title="5. 创建图类"></a>5. 创建图类</h3><ul>
<li><p>我们先来创建Graph类</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 顶点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">verteces</span>: T[] = [];</span><br><span class="line">  <span class="comment">// 邻接表表示边</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">adjList</span>: <span class="title class_">Map</span>&lt;T, T[]&gt; = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="title function_">addVertex</span>(<span class="params">v: T</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">addEdge</span>(<span class="params">v: T, w: T</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">printEdges</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">bfs</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">dfs</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码解析</p>
<ul>
<li>创建Graph的构造函数，这个我们在封装其他数据结构的时候已经非常熟悉了</li>
<li>定义了两个属性：<ul>
<li><code>vertexes</code>： 用于存储所有的顶点，我们说过使用一个数组来保存</li>
<li><code>adjList</code>： adj是adjoin的缩写，邻接的意思。adjList用于存储所有的边，我们这里采用<code>邻接表</code>的形式</li>
</ul>
</li>
</ul>
</li>
<li><p>之后，我们来定义一些方法以及实现一些算法就是一个完整的图类了</p>
</li>
</ul>
<h4 id="5-1-添加方法"><a href="#5-1-添加方法" class="headerlink" title="5.1 添加方法"></a>5.1 添加方法</h4><ul>
<li><p>在我们来增加一些添加方法</p>
<ul>
<li><code>添加顶点</code>： 可以向图中添加一些顶点</li>
<li><code>添加边</code>： 可以指定顶点和顶点之间的边</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加顶点</span></span><br><span class="line"><span class="title function_">addVertex</span>(<span class="params">v: T</span>) &#123;</span><br><span class="line">  <span class="comment">// 将顶点添加数组中保存</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">verteces</span>.<span class="title function_">push</span>(v);</span><br><span class="line">  <span class="comment">// 创建一个邻接表中的数组</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">set</span>(v, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加边</span></span><br><span class="line"><span class="title function_">addEdge</span>(<span class="params">v: T, w: T</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">get</span>(v)?.<span class="title function_">push</span>(w);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">get</span>(w)?.<span class="title function_">push</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加顶点代码解析：</p>
<ul>
<li>我们将添加的顶点放入到数组中</li>
<li>另外，我们给该顶点创建一个数组[]，该数组用于存储顶点连接的所有的边 (回顾邻接表的实现方式)</li>
</ul>
</li>
<li><p>添加边代码解析</p>
<ul>
<li>添加边需要传入两个顶点，因为边是两个顶点之间的边，边不可能单独存在</li>
<li>根据顶点v取出对应的数组，将w加入到它的数组中</li>
<li>根据顶点w取出对应的数组，将v加入到它的数组中</li>
<li>因为我们这里实现的是无向图，所以边是可以双向的</li>
</ul>
</li>
<li><p>测试代码</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = <span class="keyword">new</span> <span class="title class_">Graph</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加顶点</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;H&quot;</span>, <span class="string">&quot;I&quot;</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  graph.<span class="title function_">addVertex</span>(item);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加边</span></span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;G&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;G&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;E&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;F&quot;</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="string">&quot;E&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750854411968.png" alt="75085441196"></p>
</li>
</ul>
<h4 id="5-2-printEdges方法"><a href="#5-2-printEdges方法" class="headerlink" title="5.2 printEdges方法"></a>5.2 printEdges方法</h4><ul>
<li><p>为了能够正确的显示图的结果，我们来实现一下Graph的printEdges方法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示图的结果</span></span><br><span class="line"><span class="title function_">printEdges</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Edges：&quot;</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">verteces</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">vertex</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;vertex&#125;</span> -&gt; <span class="subst">$&#123;<span class="variable language_">this</span>.adjList.get(vertex)?.join(<span class="string">&quot; &quot;</span>)&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750854807185.png" alt="75085480718"></p>
<h3 id="6-图的遍历"><a href="#6-图的遍历" class="headerlink" title="6. 图的遍历"></a>6. 图的遍历</h3><h4 id="6-1-图的遍历"><a href="#6-1-图的遍历" class="headerlink" title="6.1 图的遍历"></a>6.1 图的遍历</h4><ul>
<li>图的遍历思想<ul>
<li>图的遍历思想和树的遍历思想是一样的</li>
<li>图的遍历意味着需要将图中<code>每个顶点访问一遍</code>，并且<code>不能有重复的访问</code></li>
</ul>
</li>
<li>有两种算法可以对图进行遍历<ul>
<li>广度优先搜索(Breadth-First Search，简称<code>BFS</code>)</li>
<li>深度优先搜索(Depth-First Search，简称<code>DFS</code>)</li>
<li>两种遍历算法，都需要明确指定<code>第一个被访问的顶点</code></li>
</ul>
</li>
<li>它们的遍历过程分别是怎么样呢<ul>
<li>我们以一个迷宫中关灯为例</li>
<li>现在需要你进入迷宫，将迷宫中的灯一个个关掉，你会怎么关呢?</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750855034754.png" alt="75085503475"></p>
<h4 id="6-2-遍历的思想"><a href="#6-2-遍历的思想" class="headerlink" title="6.2 遍历的思想"></a>6.2 遍历的思想</h4><ul>
<li>两种算法的思想：<ul>
<li>BFS： 基于队列，入队列的顶点先被探索</li>
<li>DFS： 基于栈或使用递归，通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问</li>
</ul>
</li>
<li>为了记录顶点是否被访问过，我们使用<code>三种颜色</code>来反应它们的状态<ul>
<li><code>白色</code>： 表示该顶点还没有被访问</li>
<li><code>灰色</code>： 表示该顶点被访问过，但并未被探索过</li>
<li><code>黑色</code>： 表示该顶点被访问过且被完全探索过</li>
</ul>
</li>
<li>或者我们也可以使用Set来存储被访问过的节点</li>
</ul>
<h4 id="6-3-广度优先搜索"><a href="#6-3-广度优先搜索" class="headerlink" title="6.3 广度优先搜索"></a>6.3 广度优先搜索</h4><ul>
<li>广度优先搜索算法的思路：<ul>
<li>广度优先算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层</li>
<li>换句话说，就是先宽后深的访问顶点</li>
</ul>
</li>
<li>图解BFS</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750855231510.png" alt="75085523151"></p>
<ul>
<li>广度优先搜索的实现：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广度优先搜索</span></span><br><span class="line"><span class="title function_">bfs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 1.判断是否有顶点</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">verteces</span>.<span class="property">length</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.创建队列结构</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">queue</span>: T[] = [];</span><br><span class="line">  queue.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">verteces</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.创建Set结构，记录某一个顶点是否被访问过</span></span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;T&gt;();</span><br><span class="line">  visited.<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">verteces</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.遍历队列中每一个顶点</span></span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 访问队列中的第一个顶点</span></span><br><span class="line">    <span class="keyword">const</span> vertes = queue.<span class="title function_">shift</span>()!;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(vertes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相邻的顶点</span></span><br><span class="line">    <span class="keyword">const</span> neighbors = <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">get</span>(vertes);</span><br><span class="line">    <span class="keyword">if</span> (!neighbors) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> nei <span class="keyword">of</span> neighbors) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visited.<span class="title function_">has</span>(nei)) &#123;</span><br><span class="line">        visited.<span class="title function_">add</span>(nei);</span><br><span class="line">        queue.<span class="title function_">push</span>(nei);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：A - B - C - D - E - F - G - H - I</span></span><br></pre></td></tr></table></figure>

<h4 id="6-4-深度优先搜索"><a href="#6-4-深度优先搜索" class="headerlink" title="6.4 深度优先搜索"></a>6.4 深度优先搜索</h4><ul>
<li>深度优先搜索的思路：<ul>
<li>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径知道这条路径最后被访问了</li>
<li>接着原路回退并探索下一条路径</li>
</ul>
</li>
<li>图解DFS：</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1750855355857.png" alt="75085535585"></p>
<ul>
<li>深度优先搜索算法的实现：<ul>
<li>广度优先搜索算法我们使用的是队列，这里可以使用栈完成，也可以使用递归</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深度优先搜索</span></span><br><span class="line"><span class="title function_">dfs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 1.判断是否有顶点</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">verteces</span>.<span class="property">length</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.创建一个栈结构</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">stack</span>: T[] = [];</span><br><span class="line">  stack.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">verteces</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.创建Set结构</span></span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;T&gt;();</span><br><span class="line">  visited.<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">verteces</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.从第一个顶点开始访问</span></span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> vertex = stack.<span class="title function_">pop</span>()!;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(vertex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> neighbors = <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">get</span>(vertex);</span><br><span class="line">    <span class="keyword">if</span> (!neighbors) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 反过来遍历邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = neighbors.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> nei = neighbors[i];</span><br><span class="line">      <span class="keyword">if</span> (!visited.<span class="title function_">has</span>(nei)) &#123;</span><br><span class="line">        visited.<span class="title function_">add</span>(nei);</span><br><span class="line">        stack.<span class="title function_">push</span>(nei);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：A - B - E - I - F - C - G - D - H</span></span><br></pre></td></tr></table></figure>

<h3 id="7-图完整封装"><a href="#7-图完整封装" class="headerlink" title="7. 图完整封装"></a>7. 图完整封装</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 顶点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">verteces</span>: T[] = [];</span><br><span class="line">  <span class="comment">// 邻接表表示边</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">adjList</span>: <span class="title class_">Map</span>&lt;T, T[]&gt; = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加顶点</span></span><br><span class="line">  <span class="title function_">addVertex</span>(<span class="params">v: T</span>) &#123;</span><br><span class="line">    <span class="comment">// 将顶点添加数组中保存</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">verteces</span>.<span class="title function_">push</span>(v);</span><br><span class="line">    <span class="comment">// 创建一个邻接表中的数组</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">set</span>(v, []);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加边</span></span><br><span class="line">  <span class="title function_">addEdge</span>(<span class="params">v: T, w: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">get</span>(v)?.<span class="title function_">push</span>(w);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">get</span>(w)?.<span class="title function_">push</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 显示图的结果</span></span><br><span class="line">  <span class="title function_">printEdges</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Edges：&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">verteces</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">vertex</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这个不能注释，现在注释是为了解决笔记里面下面代码变红，不好看的问题</span></span><br><span class="line">      <span class="comment">// console.log(`$&#123;vertex&#125; -&gt; $&#123;this.adjList.get(vertex)?.join(&quot; &quot;)&#125;`);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 广度优先搜索</span></span><br><span class="line">  <span class="title function_">bfs</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 1.判断是否有顶点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">verteces</span>.<span class="property">length</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建队列结构</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">queue</span>: T[] = [];</span><br><span class="line">    queue.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">verteces</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建Set结构，记录某一个顶点是否被访问过</span></span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;T&gt;();</span><br><span class="line">    visited.<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">verteces</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.遍历队列中每一个顶点</span></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 访问队列中的第一个顶点</span></span><br><span class="line">      <span class="keyword">const</span> vertes = queue.<span class="title function_">shift</span>()!;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(vertes);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 相邻的顶点</span></span><br><span class="line">      <span class="keyword">const</span> neighbors = <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">get</span>(vertes);</span><br><span class="line">      <span class="keyword">if</span> (!neighbors) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> nei <span class="keyword">of</span> neighbors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.<span class="title function_">has</span>(nei)) &#123;</span><br><span class="line">          visited.<span class="title function_">add</span>(nei);</span><br><span class="line">          queue.<span class="title function_">push</span>(nei);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 深度优先搜索</span></span><br><span class="line">  <span class="title function_">dfs</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 1.判断是否有顶点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">verteces</span>.<span class="property">length</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建一个栈结构</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">stack</span>: T[] = [];</span><br><span class="line">    stack.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">verteces</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建Set结构</span></span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;T&gt;();</span><br><span class="line">    visited.<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">verteces</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.从第一个顶点开始访问</span></span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> vertex = stack.<span class="title function_">pop</span>()!;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(vertex);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> neighbors = <span class="variable language_">this</span>.<span class="property">adjList</span>.<span class="title function_">get</span>(vertex);</span><br><span class="line">      <span class="keyword">if</span> (!neighbors) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// 反过来遍历邻接表</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = neighbors.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">const</span> nei = neighbors[i];</span><br><span class="line">        <span class="keyword">if</span> (!visited.<span class="title function_">has</span>(nei)) &#123;</span><br><span class="line">          visited.<span class="title function_">add</span>(nei);</span><br><span class="line">          stack.<span class="title function_">push</span>(nei);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-图结构的常见建模"><a href="#8-图结构的常见建模" class="headerlink" title="8. 图结构的常见建模"></a>8. 图结构的常见建模</h3><ul>
<li>交通流量建模<ul>
<li>顶点可以表示街道的十字路口，边可以表示街道</li>
<li>加权的边可以表示限速或者车道的数量或者街道的距离</li>
<li>建模人员可以用这个系统来判定最佳路线以及最可能堵车的街道</li>
</ul>
</li>
<li>对飞机航线建模<ul>
<li>航空公司可以用图来为其飞行系统建模</li>
<li>将每个机场看成顶点，将经过两个顶点的每条航线看作一条边</li>
<li>加权的边可以表示从一个机场到另一个机场的航班成本，或两个机场间的距离</li>
<li>建模人员可以利用这个系统有效的判断从一个城市到另一个城市的最小航行成本</li>
</ul>
</li>
</ul>
<h2 id="九-循环链表-–-双向链表"><a href="#九-循环链表-–-双向链表" class="headerlink" title="(九) 循环链表 – 双向链表"></a>(九) 循环链表 – 双向链表</h2><h3 id="1-循环链表结构介绍"><a href="#1-循环链表结构介绍" class="headerlink" title="1. 循环链表结构介绍"></a>1. 循环链表结构介绍</h3><ul>
<li>前面我们已经从零去封装了一个链表结构，其实我们还可以封装更灵活的链表结构：循环链表和双向链表</li>
<li>循环链表（Circular LinkedList）是一种特殊的链表数据结构：<ul>
<li>在普通链表的基础上，最后一个节点的下一个节点不再是 null，而是指向链表的第一个节点</li>
<li>这样形成了一个环，使得链表能够被无限遍历</li>
<li>这样，我们就可以在单向循环链表中<code>从任意一个节点出发，不断地遍历下一个节点，直到回到起点</code></li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751543340973.png" alt="75154334097"></p>
<ul>
<li>单向循环链表我们有两种实现方式：<ul>
<li>方式一：从零去实现一个新的链表，包括其中所有的属性和方法</li>
<li>方式二：继承自之前封装的LinkedList，只实现差异化的部分</li>
</ul>
</li>
</ul>
<h3 id="2-单向链表代码重构（方便继承）"><a href="#2-单向链表代码重构（方便继承）" class="headerlink" title="2. 单向链表代码重构（方便继承）"></a>2. 单向链表代码重构（方便继承）</h3><ul>
<li>修饰符改成protected（重构一）</li>
<li>新增属性tail指向尾部节点（重构二）<ul>
<li>append方法：（重构三）<ul>
<li>this.tail.next &#x3D; newNode</li>
<li>this.tail &#x3D; newNode</li>
</ul>
</li>
<li>insert方法：判断是否是插入最后一个节点（重构四）</li>
<li>removeAt方法：（重构五）<ul>
<li>this.length &#x3D;&#x3D;&#x3D; 1<ul>
<li>this.tail &#x3D; null</li>
</ul>
</li>
<li>position &#x3D;&#x3D;&#x3D; this.length – 1<ul>
<li>this.tail &#x3D; previous</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>新增判断最后节点方法：判断是否是最后一个节点（重构六）</li>
<li>重构traverse方法（重构七）</li>
<li>重构indexOf方法（重构八）</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ILinkedList</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">IList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">append</span>(<span class="attr">value</span>: T): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">traverse</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">insert</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">removeAt</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">get</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">update</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">indexOf</span>(<span class="attr">value</span>: T): <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">remove</span>(<span class="attr">value</span>: T): T | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建Node类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建LinkedList类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">ILinkedList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 重构一：属性修饰符由private改成protected</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">head</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">length</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重构二：新增属性tail，总是指向链表的尾部</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">tail</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取链表长度</span></span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回链表第一个元素</span></span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">head</span>?.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重构六：新增方法，判断是否是最后一个节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">isTail</span>(<span class="attr">node</span>: <span class="title class_">Node</span>&lt;T&gt;): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node === <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重构：属性修饰符由private改成protected</span></span><br><span class="line">  <span class="comment">// 根据position获取到当前的节点</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">getNode</span>(<span class="attr">position</span>: <span class="built_in">number</span>): <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position &amp;&amp; current) &#123;</span><br><span class="line">      current = current?.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重构三：append方法使用tail属性</span></span><br><span class="line">  <span class="comment">// 追加节点</span></span><br><span class="line">  <span class="title function_">append</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.根据value创建一个新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断this.head是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">head</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>!.<span class="property">next</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重构七：重构traverse方法</span></span><br><span class="line">  <span class="comment">// 遍历链表</span></span><br><span class="line">  <span class="title function_">traverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">values</span>: T[] = [];</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      values.<span class="title function_">push</span>(current.<span class="property">value</span>);</span><br><span class="line">      <span class="comment">// 判断current是否为最后一个节点</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">isTail</span>(current)) &#123;</span><br><span class="line">        current = current.<span class="property">next</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">tail</span>?.<span class="property">next</span> === <span class="variable language_">this</span>.<span class="property">head</span>) &#123;</span><br><span class="line">      values.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">head</span>!.<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(values.<span class="title function_">join</span>(<span class="string">&quot; -&gt; &quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重构四：判断是否是插入最后一个节点，改变tail指向</span></span><br><span class="line">  <span class="comment">// 根据位置插入节点</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 1.越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.根据value创建新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.判断是否需要插入头部</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      newNode.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position - <span class="number">1</span>);</span><br><span class="line">      newNode.<span class="property">next</span> = previous!.<span class="property">next</span>;</span><br><span class="line">      previous!.<span class="property">next</span> = newNode;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (position === <span class="variable language_">this</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重构五：removeAt方法修改tail指向</span></span><br><span class="line">  <span class="comment">// 根据位置删除节点</span></span><br><span class="line">  <span class="title function_">removeAt</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// 1.越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.定义变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">current</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.判断是否删除第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = current?.<span class="property">next</span> || <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position - <span class="number">1</span>);</span><br><span class="line">      current = previous!.<span class="property">next</span>;</span><br><span class="line">      previous!.<span class="property">next</span> = previous?.<span class="property">next</span>?.<span class="property">next</span> ?? <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (position === <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span> = previous;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line">    <span class="keyword">return</span> current?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取对应位置的元素</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// 1.越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.查找元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position)?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改某个位置的元素</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 1.越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.修改元素</span></span><br><span class="line">    <span class="keyword">const</span> currentNode = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position);</span><br><span class="line">    currentNode!.<span class="property">value</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重构八：重构indexOf方法</span></span><br><span class="line">  <span class="comment">// 根据元素获取它在链表中的位置</span></span><br><span class="line">  <span class="title function_">indexOf</span>(<span class="attr">value</span>: T): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// 从第一个节点开始遍历</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">value</span> === value) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">isTail</span>(current)) &#123;</span><br><span class="line">        current = current.<span class="property">next</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据值删除元素</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="attr">value</span>: T): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断链表是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-循环链表代码完整实现"><a href="#3-循环链表代码完整实现" class="headerlink" title="3. 循环链表代码完整实现"></a>3. 循环链表代码完整实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">LinkedList</span> <span class="keyword">from</span> <span class="string">&quot;./01.单向链表代码重构操作&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环链表 继承 单向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularLinkedList</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">LinkedList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 实现append方法</span></span><br><span class="line">  <span class="title function_">append</span>(<span class="attr">value</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">append</span>(value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span>!.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现insert方法</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isSuccess = <span class="variable language_">super</span>.<span class="title function_">insert</span>(value, position);</span><br><span class="line">    <span class="keyword">if</span> (isSuccess &amp;&amp; (position === <span class="number">0</span> || position === <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>!.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSuccess;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现removeAt方法</span></span><br><span class="line">  <span class="title function_">removeAt</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">super</span>.<span class="title function_">removeAt</span>(position);</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; <span class="variable language_">this</span>.<span class="property">tail</span> &amp;&amp; (position === <span class="number">0</span> || position === <span class="variable language_">this</span>.<span class="property">length</span>)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-双向链表结构介绍"><a href="#4-双向链表结构介绍" class="headerlink" title="4. 双向链表结构介绍"></a>4. 双向链表结构介绍</h3><h4 id="4-1-双向链表的结构"><a href="#4-1-双向链表的结构" class="headerlink" title="4.1 双向链表的结构"></a>4.1 双向链表的结构</h4><ul>
<li>双向链表:<ul>
<li>既可以<code>从头遍历到尾</code>, 又可以<code>从尾遍历到头</code></li>
<li>也就是链表相连的过程是<code>双向</code>的. 那么它的实现原理, 你能猜到吗?</li>
<li>一个节点既有<code>向前连接的引用prev</code>, 也有一个<code>向后连接的引用next</code></li>
</ul>
</li>
<li>双向链表有什么缺点呢?<ul>
<li>每次在<code>插入或删除</code>某个节点时, 需要处理四个引用, 而不是两个. 也就是实现起来要困难一些</li>
<li>并且相当于单向链表, 必然占用<code>内存空间更大</code>一些</li>
<li>但是这些缺点和我们使用起来的方便程度相比, 是微不足道的</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751693627424.png" alt="75169362742"></p>
<h4 id="4-2-双向链表的画图"><a href="#4-2-双向链表的画图" class="headerlink" title="4.2 双向链表的画图"></a>4.2 双向链表的画图</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751693671677.png" alt="75169367167"></p>
<h3 id="5-双向链表节点封装"><a href="#5-双向链表节点封装" class="headerlink" title="5. 双向链表节点封装"></a>5. 双向链表节点封装</h3><ul>
<li><p>双向链表的节点，需要进一步添加一个prev属性，用于指向前一个节点</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">LinkedList</span> <span class="keyword">from</span> <span class="string">&quot;./01.单向链表代码重构操作&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyNode</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">prev</span>: <span class="title class_">DoublyNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">DoublyNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表 继承 单向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">LinkedList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 重写属性</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">head</span>: <span class="title class_">DoublyNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">tail</span>: <span class="title class_">DoublyNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写方法</span></span><br><span class="line">  <span class="title function_">append</span>(<span class="attr">value</span>: T): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">  <span class="title function_">prepend</span>(<span class="attr">value</span>: T): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">  <span class="title function_">postTraverse</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">insert</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;&#125;</span><br><span class="line">  <span class="title function_">removeAt</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-双向链表方法实现"><a href="#6-双向链表方法实现" class="headerlink" title="6. 双向链表方法实现"></a>6. 双向链表方法实现</h3><ul>
<li>双向链表中添加、删除方法的实现和单向链表有较大的区别，所以我们可以对其方法进行重新实现<ul>
<li><code>append</code>方法：在尾部追加元素</li>
<li><code>prepend</code>方法：在头部添加元素</li>
<li><code>postTraverse</code>方法：从尾部遍历所有节点</li>
<li><code>insert</code>方法：根据索引插入元素</li>
<li><code>removeAt</code>方法：根据索引删除元素</li>
</ul>
</li>
<li>那么接下来我们就一个个实现这些方法，其他方法都是可以继承的</li>
</ul>
<h4 id="6-1-append方法"><a href="#6-1-append方法" class="headerlink" title="6.1 append方法"></a>6.1 append方法</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751698209204.png" alt="75169820920"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾部追加节点</span></span><br><span class="line"><span class="title function_">append</span>(<span class="attr">value</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">DoublyNode</span>(value);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">head</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span>!.<span class="property">next</span> = newNode;</span><br><span class="line">    <span class="comment">// 不能将一个父类的对象，赋值给一个子类的类型</span></span><br><span class="line">    <span class="comment">// 可以将一个子类的对象，赋值给一个父类的类型（多态）</span></span><br><span class="line">    newNode.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-prepend方法"><a href="#6-2-prepend方法" class="headerlink" title="6.2 prepend方法"></a>6.2 prepend方法</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751699984960.png" alt="75169998496"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部添加节点</span></span><br><span class="line"><span class="title function_">prepend</span>(<span class="attr">value</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">DoublyNode</span>&lt;T&gt;(value);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">head</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newNode.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prev</span> = newNode;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-postTraverse方法"><a href="#6-3-postTraverse方法" class="headerlink" title="6.3 postTraverse方法"></a>6.3 postTraverse方法</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反向遍历</span></span><br><span class="line"><span class="title function_">postTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">values</span>: T[] = [];</span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    values.<span class="title function_">push</span>(current.<span class="property">value</span>);</span><br><span class="line">    current = current.<span class="property">prev</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(values.<span class="title function_">join</span>(<span class="string">&quot; -&gt; &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-insert方法"><a href="#6-4-insert方法" class="headerlink" title="6.4 insert方法"></a>6.4 insert方法</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751700094327.png" alt="75170009432"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据索引插入元素</span></span><br><span class="line"><span class="title function_">insert</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">prepend</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="variable language_">this</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">append</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">DoublyNode</span>&lt;T&gt;(value);</span><br><span class="line">    <span class="keyword">const</span> current = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position) <span class="keyword">as</span> <span class="title class_">DoublyNode</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    current.<span class="property">prev</span>!.<span class="property">next</span> = newNode;</span><br><span class="line">    newNode.<span class="property">prev</span> = current.<span class="property">prev</span>;</span><br><span class="line">    current.<span class="property">prev</span> = newNode;</span><br><span class="line">    newNode.<span class="property">next</span> = current;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-5-removeAt方法"><a href="#6-5-removeAt方法" class="headerlink" title="6.5 removeAt方法"></a>6.5 removeAt方法</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751700130195.png" alt="75170013019"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据索引删除元素</span></span><br><span class="line"><span class="title function_">removeAt</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">head</span>!.<span class="property">next</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span>!.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">    current = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="variable language_">this</span>.<span class="property">tail</span>!.<span class="property">prev</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span>!.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    current = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position) <span class="keyword">as</span> <span class="title class_">DoublyNode</span>&lt;T&gt;;</span><br><span class="line">    current.<span class="property">prev</span>!.<span class="property">next</span> = current.<span class="property">next</span>;</span><br><span class="line">    current.<span class="property">next</span>!.<span class="property">prev</span> = current.<span class="property">prev</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> current?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-6-双向链表代码完整实现"><a href="#6-6-双向链表代码完整实现" class="headerlink" title="6.6 双向链表代码完整实现"></a>6.6 双向链表代码完整实现</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">LinkedList</span> <span class="keyword">from</span> <span class="string">&quot;./01.单向链表代码重构操作&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Node</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyNode</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">prev</span>: <span class="title class_">DoublyNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">DoublyNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表 继承 单向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">LinkedList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">head</span>: <span class="title class_">DoublyNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">tail</span>: <span class="title class_">DoublyNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尾部追加节点</span></span><br><span class="line">  <span class="title function_">append</span>(<span class="attr">value</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">DoublyNode</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">head</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>!.<span class="property">next</span> = newNode;</span><br><span class="line">      <span class="comment">// 不能将一个父类的对象，赋值给一个子类的类型</span></span><br><span class="line">      <span class="comment">// 可以将一个子类的对象，赋值给一个父类的类型（多态）</span></span><br><span class="line">      newNode.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 头部添加节点</span></span><br><span class="line">  <span class="title function_">prepend</span>(<span class="attr">value</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">DoublyNode</span>&lt;T&gt;(value);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">head</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newNode.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prev</span> = newNode;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反向遍历</span></span><br><span class="line">  <span class="title function_">postTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">values</span>: T[] = [];</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      values.<span class="title function_">push</span>(current.<span class="property">value</span>);</span><br><span class="line">      current = current.<span class="property">prev</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(values.<span class="title function_">join</span>(<span class="string">&quot; -&gt; &quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据索引插入元素</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="attr">value</span>: T, <span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">prepend</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="variable language_">this</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">append</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">DoublyNode</span>&lt;T&gt;(value);</span><br><span class="line">      <span class="keyword">const</span> current = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position) <span class="keyword">as</span> <span class="title class_">DoublyNode</span>&lt;T&gt;;</span><br><span class="line">      current.<span class="property">prev</span>!.<span class="property">next</span> = newNode;</span><br><span class="line">      newNode.<span class="property">prev</span> = current.<span class="property">prev</span>;</span><br><span class="line">      current.<span class="property">prev</span> = newNode;</span><br><span class="line">      newNode.<span class="property">next</span> = current;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据索引删除元素</span></span><br><span class="line">  <span class="title function_">removeAt</span>(<span class="attr">position</span>: <span class="built_in">number</span>): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">head</span>!.<span class="property">next</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span>!.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      current = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="variable language_">this</span>.<span class="property">tail</span>!.<span class="property">prev</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>!.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(position) <span class="keyword">as</span> <span class="title class_">DoublyNode</span>&lt;T&gt;;</span><br><span class="line">      current.<span class="property">prev</span>!.<span class="property">next</span> = current.<span class="property">next</span>;</span><br><span class="line">      current.<span class="property">next</span>!.<span class="property">prev</span> = current.<span class="property">prev</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十-堆结构（Heap）"><a href="#十-堆结构（Heap）" class="headerlink" title="(十) 堆结构（Heap）"></a>(十) 堆结构（Heap）</h2><h3 id="1-认识堆结构的特性"><a href="#1-认识堆结构的特性" class="headerlink" title="1. 认识堆结构的特性"></a>1. 认识堆结构的特性</h3><h4 id="1-1-什么是堆（Heap）结构？"><a href="#1-1-什么是堆（Heap）结构？" class="headerlink" title="1.1 什么是堆（Heap）结构？"></a>1.1 什么是堆（Heap）结构？</h4><ul>
<li>堆是也是一种非常常见的数据结构，但是相对于前面的数据结构来说，要稍微难理解一点</li>
<li>堆的本质是一种<code>特殊的树形数据结构</code>，使用<code>完全二叉树</code>来实现<ul>
<li>堆可以进行<code>很多分类</code>，但是平时使用的<code>基本都是二叉堆</code></li>
<li>二叉堆又可以划分为<code>最大堆和最小堆</code></li>
</ul>
</li>
<li>最大堆和最小堆<ul>
<li>最小堆：堆中每一个节点都<code>小于等于（&lt;=）</code>它的子节点</li>
<li>最大堆：堆中每一个节点都<code>大于等于（&gt;=）</code>它的子节点</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751704600399.png" alt="75170460039"></p>
<h4 id="1-2-为什么需要堆（Heap）结构？"><a href="#1-2-为什么需要堆（Heap）结构？" class="headerlink" title="1.2 为什么需要堆（Heap）结构？"></a>1.2 为什么需要堆（Heap）结构？</h4><ul>
<li>但是这个<code>堆东西</code>有什么意义呢？<ul>
<li>对于每一个新的数据结构，我们都需要搞清楚<code>为什么需要它</code>，这是我们能够<code>记住并且把握它的关键</code></li>
<li>它到底<code>帮助我们解决了什么问题</code>？</li>
</ul>
</li>
<li>如果有一个集合，我们希望获取其中的<code>最大值或者最小值</code>，有哪些方案呢？<ul>
<li><code>数组/链表</code>：获取最大或最小值是O(n)级别的<ul>
<li>可以进行排序，但是我们只是获取最大值或者最小值而已</li>
<li>排序本身就会消耗性能</li>
</ul>
</li>
<li><code>哈希表</code>：不需要考虑了</li>
<li><code>二叉搜索树</code>：获取最大或最小值是O(logn)级别的<ul>
<li>但是二叉搜索树操作较为复杂，并且还要维护树的平衡时才是O(logn)级别</li>
</ul>
</li>
</ul>
</li>
<li>这个时候需要一种数据结构来解决这个问题，就是<code>堆结构</code></li>
</ul>
<h4 id="1-3-认识堆（Heap）结构"><a href="#1-3-认识堆（Heap）结构" class="headerlink" title="1.3 认识堆（Heap）结构"></a>1.3 认识堆（Heap）结构</h4><ul>
<li><p>堆结构通常是用来解决Top K问题的：</p>
<ul>
<li>Top K问题是指在一组数据中，找出最前面的K个最大&#x2F;最小的元素</li>
<li>常用的解决方案有使用排序算法、快速选择算法、堆结构等</li>
</ul>
</li>
<li><p>但是我们还是不知道具体长什么样子，以及它是如何实现出来的：</p>
<ul>
<li>二叉堆用树形结构表示出来是<code>一颗完全二叉树</code></li>
<li>通常在实现的时候我们底层会<code>使用数组来实现</code></li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751705085097.png" alt="75170508509"> </p>
</li>
<li><p>每个节点在数组中对应的索引 i（index）有如下的规律：</p>
<ul>
<li>如果<code> i = 0</code> ，它是<code>根</code>节点</li>
<li>父节点的公式：<code>floor((i – 1) / 2)</code></li>
<li>左子节点：<code>2i + 1</code></li>
<li>右子节点：<code>2i + 2</code></li>
</ul>
</li>
</ul>
<h4 id="1-4-堆结构的性质"><a href="#1-4-堆结构的性质" class="headerlink" title="1.4 堆结构的性质"></a>1.4 堆结构的性质</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751704849928.png" alt="75170484992"></p>
<h3 id="2-堆结构的设计"><a href="#2-堆结构的设计" class="headerlink" title="2. 堆结构的设计"></a>2. 堆结构的设计</h3><ul>
<li>接下来，让我们对堆结构进行设计，看看需要有哪些属性和方法</li>
<li>常见的属性：<ul>
<li><code>data</code>：存储堆中的元素，通常使用数组来实现</li>
<li><code>size</code>：堆中当前元素的数量</li>
</ul>
</li>
<li>常见的方法：<ul>
<li><code>insert(value)</code>：在堆中插入一个新元素</li>
<li><code>extract/delete()</code>：从堆中删除最大&#x2F;最小元素</li>
<li><code>peek()</code>：返回堆中的最大&#x2F;最小元素</li>
<li><code>isEmpty()</code>：判断堆是否为空</li>
<li><code>build_heap(list)</code>：通过一个列表来构造堆</li>
</ul>
</li>
<li>那么接下来我们就来实现这个堆结构吧！</li>
</ul>
<h3 id="3-堆结构的封装"><a href="#3-堆结构的封装" class="headerlink" title="3. 堆结构的封装"></a>3. 堆结构的封装</h3><ul>
<li>封装Heap的类</li>
<li>这个堆结构里面只包含了两个属性：data和length<ul>
<li><code>data</code>是一个泛型数组，存储堆中的元素</li>
<li><code>length</code>是当前堆中元素的数量</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">data</span>: T[] = [];</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">length</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换数组中两个位置的元素</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">swap</span>(<span class="params">i: <span class="built_in">number</span>, j: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="variable language_">this</span>.<span class="property">data</span>[i];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>[i] = <span class="variable language_">this</span>.<span class="property">data</span>[j];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="title function_">traverse</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">value: T</span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">heapifyUp</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">delete</span>(): T | <span class="literal">undefined</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">heapifyDown</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">undefined</span> &#123;&#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;&#125;</span><br><span class="line">  <span class="title function_">buildHeap</span>(<span class="params">arr: T[]</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-最大堆结构方法实现"><a href="#4-最大堆结构方法实现" class="headerlink" title="4. 最大堆结构方法实现"></a>4. 最大堆结构方法实现</h3><h4 id="4-1-insert插入方法"><a href="#4-1-insert插入方法" class="headerlink" title="4.1 insert插入方法"></a>4.1 insert插入方法</h4><ul>
<li>如果你想<code>实现一个最大堆</code>，那么可以从实现<code>insert</code>方法开始<ul>
<li>因为每次插入元素后，检测是否符合最大堆的特性，需要对堆进行重构，以维护最大堆的性质</li>
<li>这种策略叫做<code>上滤</code>（percolate up， percolate [ˈpɜːkəleɪt] 是过滤的意思），上滤是有固定的步骤，我们需要将新插入的元素与父元素进行比较操作：<ul>
<li>新元素的索引index： <code>data.length - 1</code></li>
<li>父元素的索引index：<code>floor((index - 1) / 2)</code></li>
<li>如果当前新元素是小于等于父元素的，直接break跳出循环</li>
<li>如果当前新元素是大于父元素的，那么直接和父元素<code>交换位置</code></li>
<li>如果进行的是<code>交换操作</code>，那么将索引inde修改为父元素的索引，进行下一次循环</li>
<li>什么时候是循环结束条件：index &lt; 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入方法</span></span><br><span class="line"><span class="title function_">insert</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.将元素放到数组的尾部</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(value);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.维护最大堆的特性（最后位置的元素需要进行上滤操作）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">heapifyUp</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上滤操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">heapifyUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> parentIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>[index] &lt;= <span class="variable language_">this</span>.<span class="property">data</span>[parentIndex]) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">swap</span>(index, parentIndex);</span><br><span class="line">    index = parentIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>插入元素 insert：如果我们现在有这样一个结构的最大堆：插入120</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751780517901.png" alt="75178051790"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> heap = <span class="keyword">new</span> <span class="title class_">Heap</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">19</span>, <span class="number">100</span>, <span class="number">36</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  heap.<span class="title function_">insert</span>(item);</span><br><span class="line">&#125;</span><br><span class="line">heap.<span class="title function_">insert</span>(<span class="number">120</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据：[120, 100, 36, 17, 19, 25, 1, 2, 7, 3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可视化网站的推荐和使用：<ul>
<li><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html%EF%BC%88%E5%8A%A0%E5%88%A9%E7%A6%8F%E5%B0%BC%E4%BA%9A%E5%B7%9E%E7%9A%84%E6%97%A7%E9%87%91%E5%B1%B1%E5%A4%A7%E5%AD%A6%EF%BC%89">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html（加利福尼亚州的旧金山大学）</a></li>
<li><a target="_blank" rel="noopener" href="https://visualgo.net/en/heap?slide=1">https://visualgo.net/en/heap?slide=1</a></li>
<li><a target="_blank" rel="noopener" href="http://btv.melezinek.cz/binary-heap.html">http://btv.melezinek.cz/binary-heap.html</a></li>
</ul>
</li>
</ul>
<h4 id="4-2-delete删除方法"><a href="#4-2-delete删除方法" class="headerlink" title="4.2 delete删除方法"></a>4.2 delete删除方法</h4><ul>
<li>删除操作也需要考虑在删除元素后的操作<ul>
<li>因为每次删除元素后，需要对堆进行重构，以维护最大堆的性质</li>
<li>这种向下替换元素的策略叫作<code>下滤</code>（percolate down）<ul>
<li>数组中第一项(最大的也是要删除的元素)，和数组最后一个元素交换位置，然后删除最后一个元素</li>
<li>交换之后，数组中的第一项不符合最大堆的特性，进行下滤操作<ul>
<li>index &#x3D; 0</li>
<li>左子节点的索引leftChildIndex：<code>2 * index + 1</code></li>
<li>右子节点的索引rightChildIndex：<code>2 * index + 2</code></li>
</ul>
</li>
<li>比较leftChildIndex 和 rightChildIndex，找到较大的那个值，largeIndex设置为较大值的索引</li>
<li>停止条件：如果largeIndex索引的元素，小于index索引的元素，直接break停止</li>
<li>如果没有break停止操作，交换索引index和largeIndex位置的元素，index值设置为largeIndex</li>
<li>整个循环结束条件：2 * index + 1 &lt; this.length，没有左子节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从堆中删除最大元素</span></span><br><span class="line"><span class="title function_">delete</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 1.判断元素的个数为0或者1的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">pop</span>()!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.提取并且需要返回的最大值</span></span><br><span class="line">  <span class="keyword">const</span> topValue = <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">pop</span>()!;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.维护最大堆的特性，进行下滤操作</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> topValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下滤操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">heapifyDown</span>(<span class="params">start: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 1.定义索引位置</span></span><br><span class="line">  <span class="keyword">let</span> index = start;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; <span class="variable language_">this</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.找到左右子节点索引</span></span><br><span class="line">    <span class="keyword">let</span> leftChildIndex = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> rightChildIndex = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.找到左右子节点索引较大的值</span></span><br><span class="line">    <span class="keyword">let</span> largeIndex = leftChildIndex;</span><br><span class="line">    <span class="comment">// rightChildIndex对应索引有值，并且rightChildIndex对应值大于leftChildIndex对应值</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      rightChildIndex &lt; <span class="variable language_">this</span>.<span class="property">length</span> &amp;&amp;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span>[rightChildIndex] &gt; <span class="variable language_">this</span>.<span class="property">data</span>[leftChildIndex]</span><br><span class="line">    ) &#123;</span><br><span class="line">      largeIndex = rightChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.较大的值和index索引位置的值进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>[index] &gt;= <span class="variable language_">this</span>.<span class="property">data</span>[largeIndex]) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.交换位置</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">swap</span>(index, largeIndex);</span><br><span class="line">    index = largeIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除操作delete图解：</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751782295152.png" alt="75178229515"> </p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751782394485.png" alt="75178239448"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> heap = <span class="keyword">new</span> <span class="title class_">Heap</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">19</span>, <span class="number">100</span>, <span class="number">36</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  heap.<span class="title function_">insert</span>(item);</span><br><span class="line">&#125;</span><br><span class="line">heap.<span class="title function_">insert</span>(<span class="number">120</span>);</span><br><span class="line">heap.<span class="title function_">delete</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据：[100, 19, 36, 17, 3, 25, 1, 2, 7]</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-堆结构的其他方法"><a href="#4-3-堆结构的其他方法" class="headerlink" title="4.3 堆结构的其他方法"></a>4.3 堆结构的其他方法</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回堆中的最大元素</span></span><br><span class="line"><span class="title function_">peek</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>] ?? <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆的元素数量</span></span><br><span class="line"><span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断堆是否为空</span></span><br><span class="line"><span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-数组进行原地建堆"><a href="#4-4-数组进行原地建堆" class="headerlink" title="4.4 数组进行原地建堆"></a>4.4 数组进行原地建堆</h4><ul>
<li>“原地建堆” （In-place heap construction.）是指建立堆的过程中，不使用额外的内存空间，直接在原有数组上进行操作</li>
<li>这种原地建堆的方式，我们称之为<code>自下而上的下滤操作</code>，也可以使用自上而下的上滤操作，但是效率较低</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原地建堆</span></span><br><span class="line"><span class="title function_">buildHeap</span>(<span class="params">arr: T[]</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.使用arr的值：数组/长度</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = arr;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span> = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.从第一个非叶子节点开始，进行自下而上的下滤操作</span></span><br><span class="line">  <span class="comment">// 获取第一个非叶子节点的公式：Math.floor(this.length / 2 - 1)</span></span><br><span class="line">  <span class="keyword">const</span> start = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="variable language_">this</span>.<span class="property">length</span> / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 下滤操作</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heap = <span class="keyword">new</span> <span class="title class_">Heap</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"><span class="comment">// arr数组不是一个堆结构，通过调用buildHeap方法，将arr数组变成一个堆结构</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">9</span>, <span class="number">11</span>, <span class="number">20</span>, <span class="number">56</span>, <span class="number">23</span>, <span class="number">45</span>];</span><br><span class="line">heap.<span class="title function_">buildHeap</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);  <span class="comment">// 输出：[56, 23, 45, 11, 9, 20]</span></span><br></pre></td></tr></table></figure>

<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751788638666.png" alt="75178863866"></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751788658719.png" alt="75178865871"></p>
<h4 id="4-5-最大堆完整代码实现"><a href="#4-5-最大堆完整代码实现" class="headerlink" title="4.5 最大堆完整代码实现"></a>4.5 最大堆完整代码实现</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">data</span>: T[] = [];</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">length</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换数组中两个位置的元素</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">swap</span>(<span class="params">i: <span class="built_in">number</span>, j: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="variable language_">this</span>.<span class="property">data</span>[i];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>[i] = <span class="variable language_">this</span>.<span class="property">data</span>[j];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入方法</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.将元素放到数组的尾部</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.维护最大堆的特性（最后位置的元素需要进行上滤操作）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">heapifyUp</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上滤操作</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">heapifyUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> parentIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>[parentIndex] &gt;= <span class="variable language_">this</span>.<span class="property">data</span>[index]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">swap</span>(index, parentIndex);</span><br><span class="line">      index = parentIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从堆中删除最大元素</span></span><br><span class="line">  <span class="title function_">delete</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断元素的个数为0或者1的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">pop</span>()!;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.提取并且需要返回的最大值</span></span><br><span class="line">    <span class="keyword">const</span> topValue = <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">pop</span>()!;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.维护最大堆的特性，进行下滤操作</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> topValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下滤操作</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">heapifyDown</span>(<span class="params">start: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 1.定义索引位置</span></span><br><span class="line">    <span class="keyword">let</span> index = start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; <span class="variable language_">this</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.找到左右子节点索引</span></span><br><span class="line">      <span class="keyword">let</span> leftChildIndex = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> rightChildIndex = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3.找到左右子节点索引较大的值</span></span><br><span class="line">      <span class="keyword">let</span> largeIndex = leftChildIndex;</span><br><span class="line">      <span class="comment">// rightChildIndex对应索引有值，并且rightChildIndex对应值大于等于leftChildIndex对应值</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        rightChildIndex &lt; <span class="variable language_">this</span>.<span class="property">length</span> &amp;&amp;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>[rightChildIndex] &gt;= <span class="variable language_">this</span>.<span class="property">data</span>[leftChildIndex]</span><br><span class="line">      ) &#123;</span><br><span class="line">        largeIndex = rightChildIndex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4.较大的值和index索引位置的值进行比较</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>[index] &gt;= <span class="variable language_">this</span>.<span class="property">data</span>[largeIndex]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5.交换位置</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">swap</span>(index, largeIndex);</span><br><span class="line">      index = largeIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回堆中的最大元素</span></span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>] ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 堆的元素数量</span></span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断堆是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原地建堆</span></span><br><span class="line">  <span class="title function_">buildHeap</span>(<span class="params">arr: T[]</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.使用arr的值：数组/长度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = arr;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.从第一个非叶子节点开始，进行下滤操作</span></span><br><span class="line">    <span class="comment">// 获取第一个非叶子节点的公式：Math.floor(this.length / 2 - 1)</span></span><br><span class="line">    <span class="keyword">const</span> start = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="variable language_">this</span>.<span class="property">length</span> / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="comment">// 下滤操作</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-最小堆完整代码实现"><a href="#5-最小堆完整代码实现" class="headerlink" title="5.最小堆完整代码实现"></a>5.最小堆完整代码实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">data</span>: T[] = [];</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">length</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换数组中两个位置的元素</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">swap</span>(<span class="params">i: <span class="built_in">number</span>, j: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="variable language_">this</span>.<span class="property">data</span>[i];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>[i] = <span class="variable language_">this</span>.<span class="property">data</span>[j];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入方法</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.将元素放到数组的尾部</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.维护最小堆的特性（最后位置的元素需要进行上滤操作）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">heapifyUp</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上滤操作</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">heapifyUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> parentIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">      <span class="comment">// 修改一：大于等于 改为 小于等于</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>[parentIndex] &lt;= <span class="variable language_">this</span>.<span class="property">data</span>[index]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">swap</span>(index, parentIndex);</span><br><span class="line">      index = parentIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从堆中删除最小元素</span></span><br><span class="line">  <span class="title function_">delete</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断元素的个数为0或者1的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">pop</span>()!;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.提取并且需要返回的最小值</span></span><br><span class="line">    <span class="keyword">const</span> topValue = <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">pop</span>()!;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.维护最小堆的特性，进行下滤操作</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> topValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下滤操作</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">heapifyDown</span>(<span class="params">start: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 1.定义索引位置</span></span><br><span class="line">    <span class="keyword">let</span> index = start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; <span class="variable language_">this</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.找到左右子节点索引</span></span><br><span class="line">      <span class="keyword">let</span> leftChildIndex = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> rightChildIndex = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3.找到左右子节点索引较小的值</span></span><br><span class="line">      <span class="keyword">let</span> largeIndex = leftChildIndex;</span><br><span class="line">      <span class="comment">// 修改二：this.data[rightChildIndex] &lt;= this.data[leftChildIndex]，大于等于 变成 小于等于</span></span><br><span class="line">      <span class="comment">// rightChildIndex对应索引有值，并且rightChildIndex对应值小于leftChildIndex对应值</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        rightChildIndex &lt; <span class="variable language_">this</span>.<span class="property">length</span> &amp;&amp;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>[rightChildIndex] &lt;= <span class="variable language_">this</span>.<span class="property">data</span>[leftChildIndex]</span><br><span class="line">      ) &#123;</span><br><span class="line">        largeIndex = rightChildIndex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4.较小的值和index索引位置的值进行比较</span></span><br><span class="line">      <span class="comment">// 修改三：大于等于 改为 小于等于</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>[index] &lt;= <span class="variable language_">this</span>.<span class="property">data</span>[largeIndex]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5.交换位置</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">swap</span>(index, largeIndex);</span><br><span class="line">      index = largeIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回堆中的最小元素</span></span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>] ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 堆的元素数量</span></span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断堆是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原地建堆</span></span><br><span class="line">  <span class="title function_">buildHeap</span>(<span class="params">arr: T[]</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.使用arr的值：数组/长度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = arr;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.从第一个非叶子节点开始，进行下滤操作</span></span><br><span class="line">    <span class="comment">// 获取第一个非叶子节点的公式：Math.floor((this.length - 1) / 2)</span></span><br><span class="line">    <span class="keyword">const</span> start = <span class="title class_">Math</span>.<span class="title function_">floor</span>((<span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="comment">// 下滤操作</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heap1 = <span class="keyword">new</span> <span class="title class_">Heap</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">19</span>, <span class="number">100</span>, <span class="number">36</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">25</span>];</span><br><span class="line"><span class="comment">// 测试插入操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr1) &#123;</span><br><span class="line">  heap1.<span class="title function_">insert</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试删除操作</span></span><br><span class="line"><span class="keyword">while</span> (!heap1.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(heap1.<span class="title function_">delete</span>()); <span class="comment">// 输出：3 -&gt; 17 -&gt; 19 -&gt; 25 -&gt; 36 -&gt; 100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试原地建堆</span></span><br><span class="line"><span class="keyword">const</span> heap2 = <span class="keyword">new</span> <span class="title class_">Heap</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">19</span>, <span class="number">100</span>, <span class="number">36</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">25</span>];</span><br><span class="line">heap2.<span class="title function_">buildHeap</span>(arr2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// 输出：[3, 17, 25, 19, 100, 36];</span></span><br></pre></td></tr></table></figure>

<h3 id="6-最大堆和最小堆同时实现"><a href="#6-最大堆和最小堆同时实现" class="headerlink" title="6. 最大堆和最小堆同时实现"></a>6. 最大堆和最小堆同时实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; cbtPrint &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">data</span>: T[] = [];</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">length</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// isMax：true表示最大堆，false表示最小堆</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">isMax</span>: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">isMax: <span class="built_in">boolean</span> = <span class="literal">true</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isMax</span> = isMax;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换数组中两个位置的元素</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">swap</span>(<span class="params">i: <span class="built_in">number</span>, j: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="variable language_">this</span>.<span class="property">data</span>[i];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>[i] = <span class="variable language_">this</span>.<span class="property">data</span>[j];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最小堆/最大堆有3个地方的区别，比较的方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">compare</span>(<span class="attr">i</span>: <span class="built_in">number</span>, <span class="attr">j</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">isMax</span>) &#123;</span><br><span class="line">      <span class="comment">// 最大堆比较</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[i] &gt;= <span class="variable language_">this</span>.<span class="property">data</span>[j];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 最小堆比较</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[i] &lt;= <span class="variable language_">this</span>.<span class="property">data</span>[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历堆</span></span><br><span class="line">  <span class="title function_">traverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用coderwhy封装的hy-algokit库，遍历堆</span></span><br><span class="line">    <span class="title function_">cbtPrint</span>(<span class="variable language_">this</span>.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入方法</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.将元素放到数组的尾部</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.维护堆的特性（最后位置的元素需要进行上滤操作）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">heapifyUp</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上滤操作</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">heapifyUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> parentIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">      <span class="comment">// 最小堆：this.data[parentIndex] &lt;= this.data[index]</span></span><br><span class="line">      <span class="comment">// 最大堆：this.data[parentIndex] &gt;= this.data[index]</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">compare</span>(parentIndex, index)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">swap</span>(index, parentIndex);</span><br><span class="line">      index = parentIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从堆中删除最小/最大元素</span></span><br><span class="line">  <span class="title function_">delete</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断元素的个数为0或者1的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">pop</span>()!;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.提取并且需要返回的最小/最大值</span></span><br><span class="line">    <span class="keyword">const</span> topValue = <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">pop</span>()!;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.维护堆的特性，进行下滤操作</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> topValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下滤操作</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">heapifyDown</span>(<span class="params">start: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 1.定义索引位置</span></span><br><span class="line">    <span class="keyword">let</span> index = start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; <span class="variable language_">this</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.找到左右子节点索引</span></span><br><span class="line">      <span class="keyword">let</span> leftChildIndex = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> rightChildIndex = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3.找到左右子节点索引较小/较大的值</span></span><br><span class="line">      <span class="keyword">let</span> largeIndex = leftChildIndex;</span><br><span class="line">      <span class="comment">// 最小堆：this.data[rightChildIndex] &lt;= this.data[leftChildIndex]</span></span><br><span class="line">      <span class="comment">// 最大堆：this.data[rightChildIndex] &gt;= this.data[leftChildIndex]</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        rightChildIndex &lt; <span class="variable language_">this</span>.<span class="property">length</span> &amp;&amp;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">compare</span>(rightChildIndex, leftChildIndex)</span><br><span class="line">      ) &#123;</span><br><span class="line">        largeIndex = rightChildIndex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4.较小/较大的值和index索引位置的值进行比较</span></span><br><span class="line">      <span class="comment">// 最小堆：this.data[index] &lt;= this.data[largeIndex]</span></span><br><span class="line">      <span class="comment">// 最大堆：this.data[index] &gt;= this.data[largeIndex]</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">compare</span>(index, largeIndex)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5.交换位置</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">swap</span>(index, largeIndex);</span><br><span class="line">      index = largeIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回堆中的最小/最大元素</span></span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>] ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 堆的元素数量</span></span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断堆是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原地建堆</span></span><br><span class="line">  <span class="title function_">buildHeap</span>(<span class="params">arr: T[]</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.使用arr的值：数组/长度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = arr;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.从第一个非叶子节点开始，进行下滤操作</span></span><br><span class="line">    <span class="comment">// 获取第一个非叶子节点的公式：Math.floor(this.length / 2 - 1)</span></span><br><span class="line">    <span class="keyword">const</span> start = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="variable language_">this</span>.<span class="property">length</span> / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="comment">// 下滤操作</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">19</span>, <span class="number">100</span>, <span class="number">36</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> minHeap = <span class="keyword">new</span> <span class="title class_">Heap</span>&lt;<span class="built_in">number</span>&gt;(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> maxHeap = <span class="keyword">new</span> <span class="title class_">Heap</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  minHeap.<span class="title function_">insert</span>(item);</span><br><span class="line">  maxHeap.<span class="title function_">insert</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">minHeap.<span class="title function_">traverse</span>();</span><br><span class="line">maxHeap.<span class="title function_">traverse</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751793341550.png" alt="75179334155"></p>
<h2 id="十一-双端队列-Deque-–-优先队列-Priority-Queue"><a href="#十一-双端队列-Deque-–-优先队列-Priority-Queue" class="headerlink" title="(十一) 双端队列(Deque) – 优先队列(Priority Queue)"></a>(十一) 双端队列(Deque) – 优先队列(Priority Queue)</h2><h3 id="1-认识双端队列的特性（Deque）"><a href="#1-认识双端队列的特性（Deque）" class="headerlink" title="1. 认识双端队列的特性（Deque）"></a>1. 认识双端队列的特性（Deque）</h3><ul>
<li><p>前面我们已经学习了队列（Queue）结构，它是一种受限的线性结构，并且限制非常的严格</p>
</li>
<li><p>双端队列在单向队列的基础上解除了一部分限制：允许在队列的两端添加（入队）和删除（出队）元素</p>
<ul>
<li>因为解除了一部分限制，所以在解决一些特定问题时会更加的方便</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751793613995.png" alt="75179361399"></p>
<ul>
<li>比如滑动窗口问题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/description/">https://leetcode.cn/problems/sliding-window-maximum/description/</a></li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751793599455.png" alt="75179359945"></p>
<h3 id="2-双端队列的代码实现"><a href="#2-双端队列的代码实现" class="headerlink" title="2. 双端队列的代码实现"></a>2. 双端队列的代码实现</h3><ul>
<li>普通队列(前面实现过)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口继承接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IQueue</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">IList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="attr">element</span>: T): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">dequeue</span>(): T | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">IQueue</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">data</span>: T[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enqueue方法：向队列尾部添加一个（或多个）新的项</span></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="attr">element</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dequeue方法：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素</span></span><br><span class="line">  <span class="title function_">dequeue</span>(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// peek方法：返回队列队列的第一的元素，不对队列做任何修改</span></span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isEmpty方法：判断队列是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size方法：返回队列里的元素个数</span></span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ArrayQueue</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>双端队列</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ArrayQueue</span> <span class="keyword">from</span> <span class="string">&quot;./00.普通队列&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ArrayQueue</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 头部追加元素</span></span><br><span class="line">  <span class="title function_">addFront</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">unshift</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尾部移移除元素</span></span><br><span class="line">  <span class="title function_">removeBack</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">pop</span>() ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-认识优先级队列结构（Priority-Queue）"><a href="#3-认识优先级队列结构（Priority-Queue）" class="headerlink" title="3. 认识优先级队列结构（Priority Queue）"></a>3. 认识优先级队列结构（Priority Queue）</h3><ul>
<li>优先级队列(Priority Queue)是一种比普通队列更加高效的数据结构<ul>
<li>它每次出队的元素都是具有最高优先级的，可以理解为元素按照关键字进行排序</li>
<li>优先级队列可以用数组、链表等数据结构来实现，但是堆是最常用的实现方式</li>
</ul>
</li>
<li>优先级队列的应用</li>
<li>一个现实的例子就是机场<code>登机的顺序</code><ul>
<li>头等舱和商务舱乘客的优先级要高于经济舱乘客</li>
<li>在有些国家，老年人和孕妇（或带小孩的妇女）登机时也享有高于其他乘客的优先级</li>
</ul>
</li>
<li>另一个现实中的例子是医院的（<code>急诊科</code>）候诊室<ul>
<li>医生会优先处理病情比较严重的患者</li>
<li>当然，一般情况下是按照排号的顺序</li>
</ul>
</li>
<li>计算机中，我们也可以通过<code>优先级队列</code>来重新排序队列中任务的顺序<ul>
<li>比如每个线程处理的任务重要性不同，我们可以通过优先级的大小，来决定该线程在队列中被处理的次序</li>
</ul>
</li>
</ul>
<h3 id="4-优先级队列的实现一"><a href="#4-优先级队列的实现一" class="headerlink" title="4. 优先级队列的实现一"></a>4. 优先级队列的实现一</h3><ul>
<li>优先级队列的实现方式一：创建优先级的节点，保存在堆结构中(一般情况下使用最大堆)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Heap</span> <span class="keyword">from</span> <span class="string">&quot;../09_堆结构（Heap）/03.最大堆和最小堆同时实现&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级node的节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityNode</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">priority</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T, priority: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">priority</span> = priority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">priority</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">priorityQueue</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">heap</span>: <span class="title class_">Heap</span>&lt;<span class="title class_">PriorityNode</span>&lt;T&gt;&gt; = <span class="keyword">new</span> <span class="title class_">Heap</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enqueue方法：向队列尾部添加一个新的项</span></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="attr">value</span>: T, <span class="attr">priority</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">PriorityNode</span>(value, priority);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">insert</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dequeue方法：移除队列的优先级最高的项，并返回被移除的元素</span></span><br><span class="line">  <span class="title function_">dequeue</span>(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">delete</span>()?.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// peek方法：返回队列的优先级最高的元素，不对队列做任何修改</span></span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">peek</span>()?.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isEmpty方法：判断队列是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">isEmpty</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size方法：返回队列里的元素个数</span></span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pQueue = <span class="keyword">new</span> priorityQueue&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">pQueue.<span class="title function_">enqueue</span>(<span class="string">&quot;why&quot;</span>, <span class="number">98</span>);</span><br><span class="line">pQueue.<span class="title function_">enqueue</span>(<span class="string">&quot;kobe&quot;</span>, <span class="number">90</span>);</span><br><span class="line">pQueue.<span class="title function_">enqueue</span>(<span class="string">&quot;james&quot;</span>, <span class="number">105</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pQueue.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pQueue.<span class="title function_">dequeue</span>()); <span class="comment">// 输出：james -&gt; why -&gt; kobe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-优先级队列的实现二"><a href="#5-优先级队列的实现二" class="headerlink" title="5. 优先级队列的实现二"></a>5. 优先级队列的实现二</h3><ul>
<li>优先级队列的实现方式二：数据自身返回优先级的比较值</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Heap</span> <span class="keyword">from</span> <span class="string">&quot;../09_堆结构（Heap）/03.最大堆和最小堆同时实现&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">priorityQueue</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">heap</span>: <span class="title class_">Heap</span>&lt;T&gt; = <span class="keyword">new</span> <span class="title class_">Heap</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enqueue方法：向队列尾部添加一个新的项</span></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="attr">value</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">insert</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dequeue方法：移除队列的优先级最高的项，并返回被移除的元素</span></span><br><span class="line">  <span class="title function_">dequeue</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">delete</span>() ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// peek方法：返回队列的优先级最高的元素，不对队列做任何修改</span></span><br><span class="line">  <span class="title function_">peek</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">peek</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isEmpty方法：判断队列是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">isEmpty</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size方法：返回队列里的元素个数</span></span><br><span class="line">  <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 数据自身返回优先级的比较值</span></span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pQueue = <span class="keyword">new</span> priorityQueue&lt;<span class="title class_">Person</span>&gt;();</span><br><span class="line">pQueue.<span class="title function_">enqueue</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;why&quot;</span>, <span class="number">98</span>));</span><br><span class="line">pQueue.<span class="title function_">enqueue</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;kobe&quot;</span>, <span class="number">90</span>));</span><br><span class="line">pQueue.<span class="title function_">enqueue</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;james&quot;</span>, <span class="number">105</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pQueue.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pQueue.<span class="title function_">dequeue</span>());</span><br><span class="line">  <span class="comment">// 依次输出：</span></span><br><span class="line">  <span class="comment">// Person &#123; name: &#x27;james&#x27;, age: 105 &#125;</span></span><br><span class="line">  <span class="comment">// Person &#123; name: &#x27;why&#x27;, age: 98 &#125;</span></span><br><span class="line">  <span class="comment">// Person &#123; name: &#x27;kobe&#x27;, age: 90 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十二-平衡二叉树（AVL树）"><a href="#十二-平衡二叉树（AVL树）" class="headerlink" title="(十二) 平衡二叉树（AVL树）"></a>(十二) 平衡二叉树（AVL树）</h2><h3 id="1-平衡的二叉搜索树"><a href="#1-平衡的二叉搜索树" class="headerlink" title="1. 平衡的二叉搜索树"></a>1. 平衡的二叉搜索树</h3><h4 id="1-1-平衡树（Balanced-Tree）"><a href="#1-1-平衡树（Balanced-Tree）" class="headerlink" title="1.1 平衡树（Balanced Tree）"></a>1.1 平衡树（Balanced Tree）</h4><ul>
<li>平衡树（Balanced Tree）是一种特殊的二叉搜索树：<ul>
<li>其目的是通过一些<code>特殊的技巧</code>来维护<code>树的高度平衡</code></li>
<li>从而保证树的搜索、插入、删除等操作的时间复杂度都较低</li>
</ul>
</li>
<li>为什么需要平衡树呢？<ul>
<li>如果一棵树<code>退化成链状结构</code>，那么<code>搜索、插入、删除等操作的时间复杂度</code>就会达到最坏情况，即<code>O(n)</code>，因此不能满足要求</li>
<li>平衡树通过不断调整树的结构，使得<code>树的高度尽量平衡</code>，从而保证搜索、插入、删除等操作的时间复杂度都较低，通常为<code>O(logn)</code></li>
<li>因此，如果我们需要高效地处理大量的数据，那么<code>平衡树</code>就显得非常重要了</li>
</ul>
</li>
<li>平衡树的应用非常广泛，如<code>索引、内存管理、图形学</code>等领域均有广泛使用</li>
<li>比如我们连续的插入1、2、3、4、5、6的数字，那么前面的二叉搜索树最终形成的结构如下</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751892540811.png" alt="75189254081"></p>
<ul>
<li>事实上不只是添加会导致树的不平衡，删除元素也可能会导致树的不平衡</li>
</ul>
<h4 id="1-2-如何让树可以更加平衡呢？"><a href="#1-2-如何让树可以更加平衡呢？" class="headerlink" title="1.2 如何让树可以更加平衡呢？"></a>1.2 如何让树可以更加平衡呢？</h4><ul>
<li>方式一：限制插入、删除的节点（比如在树特性的状态下，不允许插入或者删除某些节点，不现实）</li>
<li>方式二：在随机插入或者删除元素后，通过某种方式观察树是否平衡，如果不平衡通过特定的方式（比如旋转），让树保持平衡</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751892709015.png" alt="75189270901"></p>
<h4 id="1-3-常见的平衡二叉搜索树"><a href="#1-3-常见的平衡二叉搜索树" class="headerlink" title="1.3 常见的平衡二叉搜索树"></a>1.3 常见的平衡二叉搜索树</h4><ul>
<li>常见的平衡二叉搜索树有哪些呢？<ul>
<li><code>AVL树</code>：这是一种最早的平衡二叉搜索树，在1962年由G.M. Adelson-Velsky和E.M. Landis发明</li>
<li><code>红黑树</code>：这是一种比较流行的平衡二叉搜索树，由R. Bayer在1972年发明</li>
<li><code>Splay树</code>：这是一种动态平衡二叉搜索树，通过旋转操作对树进行平衡</li>
<li><code>Treap</code>：这是一种随机化的平衡二叉搜索树，是<code>二叉搜索树和堆</code>的结合</li>
<li><code>B-树</code>：这是一种适用于磁盘或其他外存存储设备的多路平衡查找树</li>
</ul>
</li>
<li>这些平衡二叉搜索树都用于保证搜索树的平衡，从而在插入、删除、查找操作时保证了较低的时间复杂度</li>
<li>红黑树和AVL树是应用最广泛的平衡二叉搜索树<ul>
<li>红黑树：红黑树被广泛应用于实现诸如操作系统内核、数据库、编译器等软件中的数据结构，其原因在于它在插入、删除、查找操作时都具有较低的时间复杂度</li>
<li>AVL树：AVL树被用于实现各种需要<code>高效查询的数据结构</code>，如计算机图形学、数学计算和计算机科学研究中的一些特定算法</li>
</ul>
</li>
</ul>
<h3 id="2-AVL树介绍和特性"><a href="#2-AVL树介绍和特性" class="headerlink" title="2. AVL树介绍和特性"></a>2. AVL树介绍和特性</h3><h4 id="2-1-AVL树"><a href="#2-1-AVL树" class="headerlink" title="2.1 AVL树"></a>2.1 AVL树</h4><ul>
<li>AVL树（Adelson-Velsky and Landis Tree）是由G.M. Adelson-Velsky和E.M. Landis在1962年发明的<ul>
<li>它是一种<code>自（Self）平衡二叉搜索树</code></li>
<li>它是二叉搜索树的一个变体，在保证二叉搜索树性质的同时，通过<code>旋转操作保证树的平衡</code></li>
</ul>
</li>
<li>在AVL树中，每个节点都有一个<code>权值</code>，该权值代表了以<code>该节点为根节点的子树的高度差</code><ul>
<li>在AVL树中，<code>任意节点的权值只有1或-1或0</code>，因此AVL树也被称为<code>高度平衡树</code></li>
<li>对于每个节点，它的左子树和右子树的高度差不超过1</li>
<li>这使得AVL树具有比普通的二叉搜索树更高的查询效率</li>
<li>当插入或删除节点时，AVL树可以通过旋转操作来重新平衡树，从而保证其平衡性</li>
</ul>
</li>
<li>AVL树的插入和删除操作与普通的二叉搜索树类似，但是在插入或者删除之后，需要继续保持树的平衡<ul>
<li>AVL树需要通过<code>旋转操作</code>来维护平衡</li>
<li>有四种情况旋转操作：左左情况、右右情况、左右情况和右左情况双旋</li>
<li>具体使用哪一种旋转，要根据不同的情况来进行区分和判断</li>
</ul>
</li>
<li>由于AVL树具有自平衡性，因此其最坏情况下的时间复杂度仅O(log n)</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751893476964.png" alt="75189347696"></p>
<h4 id="2-2-AVL树的旋转情况"><a href="#2-2-AVL树的旋转情况" class="headerlink" title="2.2 AVL树的旋转情况"></a>2.2 AVL树的旋转情况</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1751893534080.png" alt="75189353408"></p>
<h4 id="2-3-AVL树结构的封装过程"><a href="#2-3-AVL树结构的封装过程" class="headerlink" title="2.3 AVL树结构的封装过程"></a>2.3 AVL树结构的封装过程</h4><ul>
<li>手写实现AVL树本身的过程是相当的复杂的，所以对于它的学习路线我进行了专门的设计</li>
<li>我们如何学习呢？<ul>
<li>步骤一：学习AVL树节点的封装</li>
<li>步骤二：学习AVL树的旋转情况下如何编写代码</li>
<li>步骤三：写出不同情况下进行的不同旋转操作</li>
<li>步骤四：写出插入操作后，树的再平衡操作</li>
<li>步骤五：写出删除操作后，树的再平衡操作</li>
</ul>
</li>
<li>我们可以通过分治的思想，一步步实现上面的功能，再将功能组合在一起就完成了AVL树的编写过程</li>
</ul>
<h3 id="3-步骤一：AVL树节点的封装（AVLTreeNode）"><a href="#3-步骤一：AVL树节点的封装（AVLTreeNode）" class="headerlink" title="3. 步骤一：AVL树节点的封装（AVLTreeNode）"></a>3. 步骤一：AVL树节点的封装（AVLTreeNode）</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增属性</span></span><br><span class="line">  <span class="comment">// 当前节点的父节点</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 当前节点是父节点的左子节点</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isLeft</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="variable language_">this</span>.<span class="property">parent</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">left</span> === <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前节点是父节点的右子节点</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isRight</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="variable language_">this</span>.<span class="property">parent</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">right</span> === <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTreeNode</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">TreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 保证获取到的left/right节点的类型是AVLTreeNode</span></span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">AVLTreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">AVLTreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">AVLTreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取每个节点的高度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getHeight</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> leftHeight = <span class="variable language_">this</span>.<span class="property">left</span> ? <span class="variable language_">this</span>.<span class="property">left</span>.<span class="title function_">getHeight</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> rightHeight = <span class="variable language_">this</span>.<span class="property">right</span> ? <span class="variable language_">this</span>.<span class="property">right</span>.<span class="title function_">getHeight</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 权重：平衡因子(左边height - 右边height)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getBalanceFactor</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> leftHeight = <span class="variable language_">this</span>.<span class="property">left</span> ? <span class="variable language_">this</span>.<span class="property">left</span>.<span class="title function_">getHeight</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> rightHeight = <span class="variable language_">this</span>.<span class="property">right</span> ? <span class="variable language_">this</span>.<span class="property">right</span>.<span class="title function_">getHeight</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> leftHeight - rightHeight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接判断当前节点是否平衡</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isBalanced</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> factor = <span class="variable language_">this</span>.<span class="title function_">getBalanceFactor</span>();</span><br><span class="line">    <span class="keyword">return</span> factor &gt;= -<span class="number">1</span> &amp;&amp; factor &lt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取更高子节点：不平衡的节点轴心，是去寻找左右子节点中更高的子节点</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title function_">higherChild</span>(): <span class="title class_">AVLTreeNode</span>&lt;T&gt; | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> leftHeight = <span class="variable language_">this</span>.<span class="property">left</span> ? <span class="variable language_">this</span>.<span class="property">left</span>.<span class="title function_">getHeight</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> rightHeight = <span class="variable language_">this</span>.<span class="property">right</span> ? <span class="variable language_">this</span>.<span class="property">right</span>.<span class="title function_">getHeight</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftHeight &gt; rightHeight) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">left</span>;</span><br><span class="line">    <span class="keyword">if</span> (leftHeight &lt; rightHeight) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">right</span>;</span><br><span class="line">    <span class="comment">// 高度一样：当前节点是父节点的左节点，就返回左节点；当前节点是父节点的右节点，就返回右节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isLeft</span> ? <span class="variable language_">this</span>.<span class="property">left</span> : <span class="variable language_">this</span>.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旋转操作：右旋转</span></span><br><span class="line">  <span class="title function_">rightRotation</span>(): <span class="title class_">AVLTreeNode</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旋转操作：左旋转</span></span><br><span class="line">  <span class="title function_">leftRotation</span>(): <span class="title class_">AVLTreeNode</span>&lt;T&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-步骤二：AVL左旋转右旋转"><a href="#4-步骤二：AVL左旋转右旋转" class="headerlink" title="4. 步骤二：AVL左旋转右旋转"></a>4. 步骤二：AVL左旋转右旋转</h3><h4 id="4-1-AVL树的旋转-–-右旋转"><a href="#4-1-AVL树的旋转-–-右旋转" class="headerlink" title="4.1 AVL树的旋转 – 右旋转"></a>4.1 AVL树的旋转 – 右旋转</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752294283898.png" alt="75229428389"></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752294309024.png" alt="75229430902"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旋转操作：右旋转</span></span><br><span class="line"><span class="title function_">rightRotation</span>(): <span class="title class_">AVLTreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 判断是父节点的左节点还是右节点</span></span><br><span class="line">  <span class="keyword">const</span> isLeft = <span class="variable language_">this</span>.<span class="property">isLeft</span>;</span><br><span class="line">  <span class="keyword">const</span> isRight = <span class="variable language_">this</span>.<span class="property">isRight</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.处理pivot节点</span></span><br><span class="line">  <span class="keyword">const</span> pivot = <span class="variable language_">this</span>.<span class="property">left</span>!;</span><br><span class="line">  pivot.<span class="property">parent</span> = <span class="variable language_">this</span>.<span class="property">parent</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.处理pivot的right</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">left</span> = pivot.<span class="property">right</span>;</span><br><span class="line">  <span class="keyword">if</span> (pivot.<span class="property">right</span>) &#123;</span><br><span class="line">    pivot.<span class="property">right</span>.<span class="property">parent</span> = <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.处理this</span></span><br><span class="line">  pivot.<span class="property">right</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parent</span> = pivot;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.挂载pivot</span></span><br><span class="line">  <span class="keyword">if</span> (!pivot.<span class="property">parent</span>) &#123;</span><br><span class="line">    <span class="comment">// pivot直接作为tree的根</span></span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">    <span class="comment">// pivot直接作为父节点的左子节点</span></span><br><span class="line">    pivot.<span class="property">parent</span>.<span class="property">left</span> = pivot;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRight) &#123;</span><br><span class="line">    <span class="comment">// pivot直接作为父节点的右子节点</span></span><br><span class="line">    pivot.<span class="property">parent</span>.<span class="property">right</span> = pivot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现步骤分析<ul>
<li>处理pivot的位置：<ul>
<li>1.选择当前节点的左子节点作为旋转轴心(pivot)</li>
<li>2.pivot的父节点指向this(root)当前节点的父节点</li>
</ul>
</li>
<li>处理pivot右节点的位置：<ul>
<li>3.this(root)当前节点的左节点，指向pivot的右节点</li>
<li>4.如果右节点有值，那么右节点的父节点指向this节点</li>
</ul>
</li>
<li>处理this节点的位置：<ul>
<li>5.pivot的右节点指向this</li>
<li>6.this节点的父节点指向pivot</li>
</ul>
</li>
<li>挂载pivot节点<ul>
<li>7.判断是否有父节点，父节点的left&#x2F;right指向pivot</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-2-AVL树的旋转-–-左旋转"><a href="#4-2-AVL树的旋转-–-左旋转" class="headerlink" title="4.2 AVL树的旋转 – 左旋转"></a>4.2 AVL树的旋转 – 左旋转</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752294473987.png" alt="75229447398"></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752294493809.png" alt="75229449380"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旋转操作：左旋转</span></span><br><span class="line"><span class="title function_">leftRotation</span>(): <span class="title class_">AVLTreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 判断是父节点的左节点还是右节点</span></span><br><span class="line">  <span class="keyword">const</span> isLeft = <span class="variable language_">this</span>.<span class="property">isLeft</span>;</span><br><span class="line">  <span class="keyword">const</span> isRight = <span class="variable language_">this</span>.<span class="property">isRight</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.处理pivot节点</span></span><br><span class="line">  <span class="keyword">const</span> pivot = <span class="variable language_">this</span>.<span class="property">right</span>!;</span><br><span class="line">  pivot.<span class="property">parent</span> = <span class="variable language_">this</span>.<span class="property">parent</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.处理pivot的left</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">right</span> = pivot.<span class="property">left</span>;</span><br><span class="line">  <span class="keyword">if</span> (pivot.<span class="property">left</span>) &#123;</span><br><span class="line">    pivot.<span class="property">left</span>.<span class="property">parent</span> = <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.处理this</span></span><br><span class="line">  pivot.<span class="property">left</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parent</span> = pivot;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.挂载pivot</span></span><br><span class="line">  <span class="keyword">if</span> (!pivot.<span class="property">parent</span>) &#123;</span><br><span class="line">    <span class="comment">// pivot直接作为tree的根</span></span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">    <span class="comment">// pivot直接作为父节点的左子节点</span></span><br><span class="line">    pivot.<span class="property">parent</span>.<span class="property">left</span> = pivot;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRight) &#123;</span><br><span class="line">    <span class="comment">// pivot直接作为父节点的右子节点</span></span><br><span class="line">    pivot.<span class="property">parent</span>.<span class="property">right</span> = pivot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现步骤分析<ul>
<li>1.选择当前节点的右子节点作为旋转轴心(pivot)</li>
<li>2.pivot的父节点指向this(root)当前节点的父节点</li>
<li>3.this(root)当前节点的右节点，指向pivot的左节点</li>
<li>4.如果左节点有值，那么左节点的父节点指向this节点</li>
<li>5.pivot的左节点指向this</li>
<li>6.this节点的父节点指向pivot</li>
<li>7.判断是否有父节点，父节点的left&#x2F;right指向pivot</li>
</ul>
</li>
</ul>
<h3 id="5-封装AVLTree"><a href="#5-封装AVLTree" class="headerlink" title="5. 封装AVLTree"></a>5. 封装AVLTree</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BSTree</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./00.二叉搜索树BSTree&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AVLTreeNode</span> <span class="keyword">from</span> <span class="string">&quot;./01.封装AVLTreeNode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AVLTree 继承 二叉搜索树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BSTree</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">createNode</span>(<span class="attr">value</span>: T): <span class="title class_">TreeNode</span>&lt;T&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">checkBanalce</span>(<span class="params">node: AVLTreeNode&lt;T&gt;, isAdd: <span class="built_in">boolean</span> = <span class="literal">true</span></span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据不平衡节点的情况(LL/RR/LR/RL)让子树平衡</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> root 找到不平衡节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="title function_">rebalance</span>(<span class="params">root: AVLTreeNode&lt;T&gt;</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-步骤三：不同情况旋转代码"><a href="#6-步骤三：不同情况旋转代码" class="headerlink" title="6. 步骤三：不同情况旋转代码"></a>6. 步骤三：不同情况旋转代码</h3><h4 id="6-1-旋转的四种情况-分析"><a href="#6-1-旋转的四种情况-分析" class="headerlink" title="6.1 旋转的四种情况 - 分析"></a>6.1 旋转的四种情况 - 分析</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752386700221.png" alt="75238670022"></p>
<ul>
<li>如何对AVL树进行旋转呢？</li>
<li>首先，我们需要先找到失衡的节点：<ul>
<li>失衡的节点称之为root</li>
<li>失衡节点的儿子（更高的儿子）称之为pivot</li>
<li>失衡节点的孙子（更高的孙子）称之为current</li>
</ul>
</li>
<li>如果从root到current的是：<ul>
<li>LL：左左情况，那么右旋转</li>
<li>RR：右右情况，那么左旋转</li>
<li>LR：左右情况，那么先对pivot进行左旋转，再对root进行右旋转</li>
<li>RL：右左情况，那么先对pivot进行右旋转，再对root进行左旋转</li>
</ul>
</li>
</ul>
<h4 id="6-2-旋转的四种情况-代码实现"><a href="#6-2-旋转的四种情况-代码实现" class="headerlink" title="6.2 旋转的四种情况 - 代码实现"></a>6.2 旋转的四种情况 - 代码实现</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据不平衡节点的情况(LL/RR/LR/RL)让子树平衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 找到不平衡节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">rebalance</span>(<span class="params">root: AVLTreeNode&lt;T&gt;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> pivot = root.<span class="property">higherChild</span>;</span><br><span class="line">  <span class="keyword">const</span> current = pivot?.<span class="property">higherChild</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">resultNode</span>: <span class="title class_">AVLTreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pivot?.<span class="property">isLeft</span>) &#123;</span><br><span class="line">    <span class="comment">// 左边L</span></span><br><span class="line">    <span class="keyword">if</span> (current?.<span class="property">isLeft</span>) &#123;</span><br><span class="line">      <span class="comment">// LL左左：root右旋转</span></span><br><span class="line">      resultNode = root.<span class="title function_">rightRotation</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// LR左右：先对pivot进行左旋转，再对root进行右旋转</span></span><br><span class="line">      pivot.<span class="title function_">leftRotation</span>();</span><br><span class="line">      resultNode = root.<span class="title function_">rightRotation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 右边R</span></span><br><span class="line">    <span class="keyword">if</span> (current?.<span class="property">isLeft</span>) &#123;</span><br><span class="line">      <span class="comment">// RL右左：先对pivot进行右旋转，再对root进行左旋转</span></span><br><span class="line">      pivot?.<span class="title function_">rightRotation</span>();</span><br><span class="line">      resultNode = root.<span class="title function_">leftRotation</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// RR右右：root左旋转</span></span><br><span class="line">      resultNode = root.<span class="title function_">leftRotation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (resultNode.<span class="property">parent</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = resultNode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-步骤四：AVL插入时的调整"><a href="#7-步骤四：AVL插入时的调整" class="headerlink" title="7. 步骤四：AVL插入时的调整"></a>7. 步骤四：AVL插入时的调整</h3><h4 id="7-1-插入的案例演示"><a href="#7-1-插入的案例演示" class="headerlink" title="7.1 插入的案例演示"></a>7.1 插入的案例演示</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752390266125.png" alt="75239026612"></p>
<h4 id="7-2-insert的调整和再平衡"><a href="#7-2-insert的调整和再平衡" class="headerlink" title="7.2 insert的调整和再平衡"></a>7.2 insert的调整和再平衡</h4><ul>
<li>细节一：Node节点的类型<ul>
<li>这里有一个小细节 - BSTree插入的节点类型 TreeNode</li>
<li>我们可以封装一个模板方法，让子类来进行重写即可</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752391398998.png" alt="75239139899"></p>
<ul>
<li>细节二：Node节点需要保存父节点<ul>
<li>因为之后我们需要从当前节点中寻找parent节点，所以最好让每一个节点都保存一份parent节点（之前代码是不需要的）</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752391486243.png" alt="75239148624"></p>
<ul>
<li><p>我们可以继续使用之前的插入操作，在插入完成后去检查树的平衡：</p>
<ul>
<li>BSTree二叉搜索树里面的代码</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设计模式：模板模式(创建节点)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">createNode</span>(<span class="attr">value</span>: T): <span class="title class_">TreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测节点是否平衡</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">checkBanalce</span>(<span class="params">node: TreeNode&lt;T&gt;</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据的操作</span></span><br><span class="line"><span class="title function_">insert</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.创建新节点</span></span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="variable language_">this</span>.<span class="title function_">createNode</span>(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.判断是否有根节点</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.检测节点是否平衡</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">checkBanalce</span>(newNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入非根节点</span></span><br><span class="line"><span class="title function_">insertNode</span>(<span class="params">node: TreeNode&lt;T&gt;, newNode: TreeNode&lt;T&gt;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (newNode.<span class="property">value</span> &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 向左子树插入</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.<span class="property">left</span> = newNode;</span><br><span class="line">      newNode.<span class="property">parent</span> = node; <span class="comment">// 设置父节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 向右子树插入</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.<span class="property">right</span> = newNode;</span><br><span class="line">      newNode.<span class="property">parent</span> = node; <span class="comment">// 设置父节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>AVLBSTree里面的代码</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写调用的createNode方法</span></span><br><span class="line"><span class="comment">// 多态：父类引用指向子类对象，AVLTreeNode 继承 TreeNode</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">createNode</span>(<span class="attr">value</span>: T): <span class="title class_">TreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AVLTreeNode</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测节点是否平衡</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">checkBanalce</span>(<span class="params">node: AVLTreeNode&lt;T&gt;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> current = node.<span class="property">parent</span>;</span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!current.<span class="property">isBalanced</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">rebalance</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.<span class="property">parent</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>我们可以随机一些数字，插入到AVLTree中来查看树是否平衡：</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> avlTree = <span class="keyword">new</span> <span class="title class_">AVLTree</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> num = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">200</span>);</span><br><span class="line">  avlTree.<span class="title function_">insert</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avlTree.<span class="title function_">print</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752393103810.png" alt="75239310381"></p>
<h3 id="8-步骤五：AVL删除时的调整"><a href="#8-步骤五：AVL删除时的调整" class="headerlink" title="8. 步骤五：AVL删除时的调整"></a>8. 步骤五：AVL删除时的调整</h3><h4 id="8-1-删除的案例演示"><a href="#8-1-删除的案例演示" class="headerlink" title="8.1 删除的案例演示"></a>8.1 删除的案例演示</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752393299924.png" alt="75239329992"></p>
<h4 id="8-2-remove的调整和再平衡"><a href="#8-2-remove的调整和再平衡" class="headerlink" title="8.2 remove的调整和再平衡"></a>8.2 remove的调整和再平衡</h4><ul>
<li>问题 – checkBalance传入谁？<ul>
<li>思考： checkBalance传入谁？<ul>
<li>很明显应该是删除的节点</li>
<li>但是如果有两个子节点的情况，需要找的是前期和后继，最终是将前驱和后继位置的节点删除掉的</li>
<li>寻找的应该是从AVL树中被移除位置的节点</li>
</ul>
</li>
<li>情况一：删除节点本身是叶子节点<ul>
<li>传入current节点即可，并且需要根据current节点的parent去寻找失衡节点</li>
</ul>
</li>
<li>情况二：删除节点只有一个子节点<ul>
<li>传入current节点即可，并且需要根据current节点的parent去寻找失衡节点</li>
</ul>
</li>
<li>情况三：删除节点有两个子节点：<ul>
<li>找到后继节点successor原来的位置，并且需要根据successor节点去寻找失衡节点</li>
</ul>
</li>
<li>这里的关键点是两个：<ul>
<li>关键点一：必须要找到检测位置的节点</li>
<li>关键点二：检测位置的节点必须有父节点</li>
</ul>
</li>
</ul>
</li>
<li>关键点一：寻找delNode节点</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752394082486.png" alt="75239408248"></p>
<ul>
<li>关键点二：delNode节点的父节点，delNode节点有正确的父节点，但是后面的替换节点会失去正确的父节点</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752394152918.png" alt="75239415291"></p>
<ul>
<li>关键点三：delNode节点的父节点<ul>
<li>如果需要找后继节点，那么父节点的操作会比较复杂</li>
<li>我们可以利用我之前提到的第二种方案，来减少一些父节点的设置操作</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752394234166.png" alt="75239423416"></p>
<ul>
<li>BSTree代码修改</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752399922510.png" alt="75239992251"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现删除操作</span></span><br><span class="line"><span class="comment">// 之前：将后继节点替换到被删除节点的位置</span></span><br><span class="line"><span class="comment">// 现在：将被删除节点的value，换成后继节点的value</span></span><br><span class="line"><span class="comment">// 好处：平衡的时候，减少了多个节点修改parent指向</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">getSuccessor</span>(<span class="attr">delNode</span>: <span class="title class_">TreeNode</span>&lt;T&gt;): <span class="title class_">TreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取右子树</span></span><br><span class="line">  <span class="keyword">let</span> current = delNode.<span class="property">right</span>;</span><br><span class="line">  <span class="comment">// 后继节点</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">successor</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找右子树的最小节点</span></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    successor = current;</span><br><span class="line">    current = current.<span class="property">left</span>;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">      current.<span class="property">parent</span> = successor;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (successor !== delNode.<span class="property">right</span>) &#123;</span><br><span class="line">    successor!.<span class="property">parent</span>!.<span class="property">left</span> = successor!.<span class="property">right</span>;</span><br><span class="line">    <span class="comment">// successor!.right = delNode.right;</span></span><br><span class="line">    <span class="keyword">if</span> (successor?.<span class="property">right</span>) &#123;</span><br><span class="line">      successor.<span class="property">right</span>.<span class="property">parent</span> = successor.<span class="property">parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    delNode.<span class="property">right</span> = successor!.<span class="property">right</span>;</span><br><span class="line">    <span class="keyword">if</span> (successor?.<span class="property">right</span>) &#123;</span><br><span class="line">      successor.<span class="property">right</span>.<span class="property">parent</span> = delNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将删除节点的left，赋值给后继节点的left</span></span><br><span class="line">  <span class="comment">// successor!.left = delNode.left;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到了后继节点</span></span><br><span class="line">  <span class="keyword">return</span> successor!;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="title function_">remove</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="comment">// 1.搜索：当前是否有这个value</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(value);</span><br><span class="line">  <span class="keyword">if</span> (!current) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">delNode</span>: <span class="title class_">TreeNode</span>&lt;T&gt; = current;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.获取三个属性：当前节点、父节点、当前节点是父节点的左子节点还是右子节点</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">replaceNode</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.1.如果删除的是叶子节点</span></span><br><span class="line">  <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    replaceNode = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.2.只有一个子节点：只有左子节点</span></span><br><span class="line">    replaceNode = current.<span class="property">left</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.2.只有一个子节点：只有右子节点</span></span><br><span class="line">    replaceNode = current.<span class="property">right</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 2.2.有两个子节点</span></span><br><span class="line">    <span class="keyword">const</span> successor = <span class="variable language_">this</span>.<span class="title function_">getSuccessor</span>(current);</span><br><span class="line">    <span class="comment">// 现在：将被删除节点的value，换成后继节点的value</span></span><br><span class="line">    current.<span class="property">value</span> = successor.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是successor</span></span><br><span class="line">    delNode = successor;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">checkBanalce</span>(delNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = replaceNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">isLeft</span>) &#123;</span><br><span class="line">    current.<span class="property">parent</span>!.<span class="property">left</span> = replaceNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    current.<span class="property">parent</span>!.<span class="property">right</span> = replaceNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断replaceNode，设置父节点</span></span><br><span class="line">  <span class="keyword">if</span> (replaceNode &amp;&amp; current.<span class="property">parent</span>) &#123;</span><br><span class="line">    replaceNode.<span class="property">parent</span> = current.<span class="property">parent</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除完成后，检测节点是否平衡</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">checkBanalce</span>(delNode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以随机一些数字，插入，再删除，AVLTree中来查看树是否平衡</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> avlTree = <span class="keyword">new</span> <span class="title class_">AVLTree</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">nums</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> num = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">200</span>);</span><br><span class="line">  <span class="comment">// 测试的时候，可以多删除一点数据</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">2</span>) nums.<span class="title function_">push</span>(num);</span><br><span class="line">  avlTree.<span class="title function_">insert</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avlTree.<span class="title function_">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> nums) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除节点：&quot;</span>, item);</span><br><span class="line">  avlTree.<span class="title function_">remove</span>(item);</span><br><span class="line">  avlTree.<span class="title function_">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752399322177.png" alt="75239932217"></p>
<h3 id="9-AVL再平衡的优化"><a href="#9-AVL再平衡的优化" class="headerlink" title="9. AVL再平衡的优化"></a>9. AVL再平衡的优化</h3><ul>
<li><p>rebalance的优化</p>
<ul>
<li>目前我们rebalance的操作是哪些节点会执行呢？<ul>
<li><code>插入节点</code>的所有父节点（一直向上查找父节点）</li>
<li><code>删除节点</code>的所有父节点（一直向上查找父节点）</li>
</ul>
</li>
<li>但是 是否需要每次插入、删除都需要将所有的父节点都rebalance操作呢？<ul>
<li>这个取决于在<code>插入</code>一个节点后后，是否改变了祖父节点的高度</li>
<li>这个取决于在<code>删除</code>一个节点后后，是否改变了祖父节点的高度</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752399661331.png" alt="75239966133"></p>
<ul>
<li>我们得出结论：<ul>
<li>插入节点，再平衡rebalance后不需要继续后续节点的再平衡rebalance </li>
<li>删除节点，再平衡rebalance后需要继续后续节点的再平衡rebalance</li>
</ul>
</li>
</ul>
</li>
<li><p>如何优化代码呢？</p>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752399805699.png" alt="75239980569"></p>
<h3 id="10-AVL树完整代码"><a href="#10-AVL树完整代码" class="headerlink" title="10. AVL树完整代码"></a>10. AVL树完整代码</h3><ul>
<li>00.二叉搜索树BSTree.ts</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; btPrint &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增属性</span></span><br><span class="line">  <span class="comment">// 当前节点的父节点</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 当前节点是父节点的左子节点</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isLeft</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="variable language_">this</span>.<span class="property">parent</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">left</span> === <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前节点是父节点的右子节点</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isRight</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="variable language_">this</span>.<span class="property">parent</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">right</span> === <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">root</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印树的方法</span></span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用coderwhy老师封装的库hy-algokit，查看树的结构</span></span><br><span class="line">    <span class="comment">// 传入树的根节点</span></span><br><span class="line">    <span class="title function_">btPrint</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">searchNode</span>(<span class="attr">value</span>: T): <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">parent</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      <span class="comment">// 1.如果找到current，直接返回即可</span></span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">value</span> === value) &#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.继续向下找</span></span><br><span class="line">      parent = current;</span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">value</span> &lt; value) &#123;</span><br><span class="line">        current = current.<span class="property">right</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current = current.<span class="property">left</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果current有值，那么current保存自己的父节点</span></span><br><span class="line">      <span class="keyword">if</span> (current) current.<span class="property">parent</span> = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设计模式：模板模式</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">createNode</span>(<span class="attr">value</span>: T): <span class="title class_">TreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测节点是否平衡</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">checkBanalce</span>(<span class="params">node: TreeNode&lt;T&gt;, isAdd: <span class="built_in">boolean</span> = <span class="literal">true</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入数据的操作</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.创建新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="variable language_">this</span>.<span class="title function_">createNode</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断是否有根节点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.检测节点是否平衡</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">checkBanalce</span>(newNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入非根节点</span></span><br><span class="line">  <span class="title function_">insertNode</span>(<span class="params">node: TreeNode&lt;T&gt;, newNode: TreeNode&lt;T&gt;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newNode.<span class="property">value</span> &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">      <span class="comment">// 向左子树插入</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">left</span> = newNode;</span><br><span class="line">        newNode.<span class="property">parent</span> = node; <span class="comment">// 设置父节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 向右子树插入</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">right</span> = newNode;</span><br><span class="line">        newNode.<span class="property">parent</span> = node; <span class="comment">// 设置父节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先序遍历</span></span><br><span class="line">  <span class="title function_">preOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">preOrderTraverseNode</span>(<span class="params">node: TreeNode&lt;T&gt; | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中序遍历</span></span><br><span class="line">  <span class="title function_">inOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">inOrderTraverseNode</span>(<span class="params">node: TreeNode&lt;T&gt; | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后序遍历</span></span><br><span class="line">  <span class="title function_">postOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">postOrderTraverseNode</span>(<span class="params">node: TreeNode&lt;T&gt; | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 层序遍历</span></span><br><span class="line">  <span class="title function_">levelOrderTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 没有根节点，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个队列</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">TreeNode</span>&lt;T&gt;[] = [];</span><br><span class="line">    queue.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = queue.<span class="title function_">shift</span>()!;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(current?.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(current.<span class="property">left</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (current.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(current.<span class="property">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最小值</span></span><br><span class="line">  <span class="title function_">getMinValue</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current.<span class="property">left</span>) &#123;</span><br><span class="line">      current = current.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大值</span></span><br><span class="line">  <span class="title function_">getMaxValue</span>(): T | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current.<span class="property">right</span>) &#123;</span><br><span class="line">      current = current.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current?.<span class="property">value</span> ?? <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索</span></span><br><span class="line">  <span class="title function_">search</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!<span class="variable language_">this</span>.<span class="title function_">searchNode</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现删除操作</span></span><br><span class="line">  <span class="comment">// 之前：将后继节点替换到被删除节点的位置</span></span><br><span class="line">  <span class="comment">// 现在：将被删除节点的value，换成后继节点的value</span></span><br><span class="line">  <span class="comment">// 好处：平衡的时候，减少了多个节点修改parent指向</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getSuccessor</span>(<span class="attr">delNode</span>: <span class="title class_">TreeNode</span>&lt;T&gt;): <span class="title class_">TreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取右子树</span></span><br><span class="line">    <span class="keyword">let</span> current = delNode.<span class="property">right</span>;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">successor</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找右子树的最小节点</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      successor = current;</span><br><span class="line">      current = current.<span class="property">left</span>;</span><br><span class="line">      <span class="keyword">if</span> (current) &#123;</span><br><span class="line">        current.<span class="property">parent</span> = successor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (successor !== delNode.<span class="property">right</span>) &#123;</span><br><span class="line">      successor!.<span class="property">parent</span>!.<span class="property">left</span> = successor!.<span class="property">right</span>;</span><br><span class="line">      <span class="comment">// successor!.right = delNode.right;</span></span><br><span class="line">      <span class="keyword">if</span> (successor?.<span class="property">right</span>) &#123;</span><br><span class="line">        successor.<span class="property">right</span>.<span class="property">parent</span> = successor.<span class="property">parent</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      delNode.<span class="property">right</span> = successor!.<span class="property">right</span>;</span><br><span class="line">      <span class="keyword">if</span> (successor?.<span class="property">right</span>) &#123;</span><br><span class="line">        successor.<span class="property">right</span>.<span class="property">parent</span> = delNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将删除节点的left，赋值给后继节点的left</span></span><br><span class="line">    <span class="comment">// successor!.left = delNode.left;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到了后继节点</span></span><br><span class="line">    <span class="keyword">return</span> successor!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="title function_">remove</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 1.搜索：当前是否有这个value</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (!current) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">delNode</span>: <span class="title class_">TreeNode</span>&lt;T&gt; = current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取三个属性：当前节点、父节点、当前节点是父节点的左子节点还是右子节点</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">replaceNode</span>: <span class="title class_">TreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1.如果删除的是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      replaceNode = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.2.只有一个子节点：只有左子节点</span></span><br><span class="line">      replaceNode = current.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.2.只有一个子节点：只有右子节点</span></span><br><span class="line">      replaceNode = current.<span class="property">right</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 2.2.有两个子节点</span></span><br><span class="line">      <span class="keyword">const</span> successor = <span class="variable language_">this</span>.<span class="title function_">getSuccessor</span>(current);</span><br><span class="line">      <span class="comment">// 现在：将被删除节点的value，换成后继节点的value</span></span><br><span class="line">      current.<span class="property">value</span> = successor.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里是successor</span></span><br><span class="line">      delNode = successor;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">checkBanalce</span>(delNode, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current === <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = replaceNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="property">isLeft</span>) &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">left</span> = replaceNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current.<span class="property">parent</span>!.<span class="property">right</span> = replaceNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断replaceNode，设置父节点</span></span><br><span class="line">    <span class="keyword">if</span> (replaceNode &amp;&amp; current.<span class="property">parent</span>) &#123;</span><br><span class="line">      replaceNode.<span class="property">parent</span> = current.<span class="property">parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除完成后，检测节点是否平衡</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">checkBanalce</span>(delNode, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">TreeNode</span>, <span class="title class_">BSTree</span> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>01.封装AVLTreeNode.ts</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TreeNode</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./00.二叉搜索树BSTree&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTreeNode</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">TreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 保证获取到的left/right节点的类型是AVLTreeNode</span></span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">AVLTreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">AVLTreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">AVLTreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取每个节点的高度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getHeight</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> leftHeight = <span class="variable language_">this</span>.<span class="property">left</span> ? <span class="variable language_">this</span>.<span class="property">left</span>.<span class="title function_">getHeight</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> rightHeight = <span class="variable language_">this</span>.<span class="property">right</span> ? <span class="variable language_">this</span>.<span class="property">right</span>.<span class="title function_">getHeight</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 权重：平衡因子(左边height - 右边height)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getBalanceFactor</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> leftHeight = <span class="variable language_">this</span>.<span class="property">left</span> ? <span class="variable language_">this</span>.<span class="property">left</span>.<span class="title function_">getHeight</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> rightHeight = <span class="variable language_">this</span>.<span class="property">right</span> ? <span class="variable language_">this</span>.<span class="property">right</span>.<span class="title function_">getHeight</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> leftHeight - rightHeight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接判断当前节点是否平衡</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isBalanced</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> factor = <span class="variable language_">this</span>.<span class="title function_">getBalanceFactor</span>();</span><br><span class="line">    <span class="keyword">return</span> factor &gt;= -<span class="number">1</span> &amp;&amp; factor &lt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取更高子节点：不平衡的节点轴心，是去寻找左右子节点中更高的子节点</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title function_">higherChild</span>(): <span class="title class_">AVLTreeNode</span>&lt;T&gt; | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> leftHeight = <span class="variable language_">this</span>.<span class="property">left</span> ? <span class="variable language_">this</span>.<span class="property">left</span>.<span class="title function_">getHeight</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> rightHeight = <span class="variable language_">this</span>.<span class="property">right</span> ? <span class="variable language_">this</span>.<span class="property">right</span>.<span class="title function_">getHeight</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftHeight &gt; rightHeight) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">left</span>;</span><br><span class="line">    <span class="keyword">if</span> (leftHeight &lt; rightHeight) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">right</span>;</span><br><span class="line">    <span class="comment">// 高度一样：当前节点是父节点的左节点，就返回左节点；当前节点是父节点的右节点，就返回右节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isLeft</span> ? <span class="variable language_">this</span>.<span class="property">left</span> : <span class="variable language_">this</span>.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旋转操作：右旋转</span></span><br><span class="line">  <span class="title function_">rightRotation</span>(): <span class="title class_">AVLTreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断是父节点的左节点还是右节点</span></span><br><span class="line">    <span class="keyword">const</span> isLeft = <span class="variable language_">this</span>.<span class="property">isLeft</span>;</span><br><span class="line">    <span class="keyword">const</span> isRight = <span class="variable language_">this</span>.<span class="property">isRight</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.处理pivot节点</span></span><br><span class="line">    <span class="keyword">const</span> pivot = <span class="variable language_">this</span>.<span class="property">left</span>!;</span><br><span class="line">    pivot.<span class="property">parent</span> = <span class="variable language_">this</span>.<span class="property">parent</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.处理pivot的right</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = pivot.<span class="property">right</span>;</span><br><span class="line">    <span class="keyword">if</span> (pivot.<span class="property">right</span>) &#123;</span><br><span class="line">      pivot.<span class="property">right</span>.<span class="property">parent</span> = <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.处理this</span></span><br><span class="line">    pivot.<span class="property">right</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.挂载pivot</span></span><br><span class="line">    <span class="keyword">if</span> (!pivot.<span class="property">parent</span>) &#123;</span><br><span class="line">      <span class="comment">// pivot直接作为tree的根</span></span><br><span class="line">      <span class="keyword">return</span> pivot;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">      <span class="comment">// pivot直接作为父节点的左子节点</span></span><br><span class="line">      pivot.<span class="property">parent</span>.<span class="property">left</span> = pivot;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRight) &#123;</span><br><span class="line">      <span class="comment">// pivot直接作为父节点的右子节点</span></span><br><span class="line">      pivot.<span class="property">parent</span>.<span class="property">right</span> = pivot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旋转操作：左旋转</span></span><br><span class="line">  <span class="title function_">leftRotation</span>(): <span class="title class_">AVLTreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断是父节点的左节点还是右节点</span></span><br><span class="line">    <span class="keyword">const</span> isLeft = <span class="variable language_">this</span>.<span class="property">isLeft</span>;</span><br><span class="line">    <span class="keyword">const</span> isRight = <span class="variable language_">this</span>.<span class="property">isRight</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.处理pivot节点</span></span><br><span class="line">    <span class="keyword">const</span> pivot = <span class="variable language_">this</span>.<span class="property">right</span>!;</span><br><span class="line">    pivot.<span class="property">parent</span> = <span class="variable language_">this</span>.<span class="property">parent</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.处理pivot的left</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = pivot.<span class="property">left</span>;</span><br><span class="line">    <span class="keyword">if</span> (pivot.<span class="property">left</span>) &#123;</span><br><span class="line">      pivot.<span class="property">left</span>.<span class="property">parent</span> = <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.处理this</span></span><br><span class="line">    pivot.<span class="property">left</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.挂载pivot</span></span><br><span class="line">    <span class="keyword">if</span> (!pivot.<span class="property">parent</span>) &#123;</span><br><span class="line">      <span class="comment">// pivot直接作为tree的根</span></span><br><span class="line">      <span class="keyword">return</span> pivot;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">      <span class="comment">// pivot直接作为父节点的左子节点</span></span><br><span class="line">      pivot.<span class="property">parent</span>.<span class="property">left</span> = pivot;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRight) &#123;</span><br><span class="line">      <span class="comment">// pivot直接作为父节点的右子节点</span></span><br><span class="line">      pivot.<span class="property">parent</span>.<span class="property">right</span> = pivot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">AVLTreeNode</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>02.封装AVLTree.ts</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BSTree</span>, <span class="title class_">TreeNode</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./00.二叉搜索树BSTree&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AVLTreeNode</span> <span class="keyword">from</span> <span class="string">&quot;./01.封装AVLTreeNode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AVLTree 继承 二叉搜索树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BSTree</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 重写调用的createNode方法</span></span><br><span class="line">  <span class="comment">// 多态：父类引用指向子类对象，AVLTreeNode 继承 TreeNode</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">createNode</span>(<span class="attr">value</span>: T): <span class="title class_">TreeNode</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AVLTreeNode</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测节点是否平衡</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">checkBanalce</span>(<span class="params">node: AVLTreeNode&lt;T&gt;, isAdd: <span class="built_in">boolean</span> = <span class="literal">true</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = node.<span class="property">parent</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!current.<span class="property">isBalanced</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">rebalance</span>(current);</span><br><span class="line">        <span class="comment">// 添加的情况是不需要进一步向上查找的，直接break</span></span><br><span class="line">        <span class="comment">// 删除的情况是需要进一步向上查找的，不break</span></span><br><span class="line">        <span class="keyword">if</span> (isAdd) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      current = current.<span class="property">parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据不平衡节点的情况(LL/RR/LR/RL)让子树平衡</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> root 找到不平衡节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">rebalance</span>(<span class="params">root: AVLTreeNode&lt;T&gt;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> pivot = root.<span class="property">higherChild</span>;</span><br><span class="line">    <span class="keyword">const</span> current = pivot?.<span class="property">higherChild</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">resultNode</span>: <span class="title class_">AVLTreeNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pivot?.<span class="property">isLeft</span>) &#123;</span><br><span class="line">      <span class="comment">// 左边L</span></span><br><span class="line">      <span class="keyword">if</span> (current?.<span class="property">isLeft</span>) &#123;</span><br><span class="line">        <span class="comment">// LL左左：root右旋转</span></span><br><span class="line">        resultNode = root.<span class="title function_">rightRotation</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// LR左右：先对pivot进行左旋转，再对root进行右旋转</span></span><br><span class="line">        pivot.<span class="title function_">leftRotation</span>();</span><br><span class="line">        resultNode = root.<span class="title function_">rightRotation</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 右边R</span></span><br><span class="line">      <span class="keyword">if</span> (current?.<span class="property">isLeft</span>) &#123;</span><br><span class="line">        <span class="comment">// RL右左：先对pivot进行右旋转，再对root进行左旋转</span></span><br><span class="line">        pivot?.<span class="title function_">rightRotation</span>();</span><br><span class="line">        resultNode = root.<span class="title function_">leftRotation</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// RR右右：root左旋转</span></span><br><span class="line">        resultNode = root.<span class="title function_">leftRotation</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resultNode.<span class="property">parent</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = resultNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="十三-平衡二叉树（红黑树）"><a href="#十三-平衡二叉树（红黑树）" class="headerlink" title="(十三) 平衡二叉树（红黑树）"></a>(十三) 平衡二叉树（红黑树）</h2><h3 id="1-红黑树介绍和特性"><a href="#1-红黑树介绍和特性" class="headerlink" title="1. 红黑树介绍和特性"></a>1. 红黑树介绍和特性</h3><h4 id="1-1-邂逅红黑树"><a href="#1-1-邂逅红黑树" class="headerlink" title="1.1 邂逅红黑树"></a>1.1 邂逅红黑树</h4><ul>
<li>首先，红黑树是数据结构中很难的一个知识点，难到什么程度呢?<ul>
<li>基本你跟别人聊数据结构的时候，他不会和你聊红黑树, 因为它是数据结构中<code>一个难点中的难点</code></li>
<li>数据结构的学习本来就比较难了，红黑树是又将难度<code>上升一个档次</code>的知识点</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752401310312.png" alt="75240131031"></p>
<ul>
<li>面试的时候经常出现这个场景：<ul>
<li>面试官：你知道红黑树吗？</li>
<li>面试者：知道啊</li>
<li>面试官：知道原理吗？</li>
<li>面试者：不知道啊</li>
<li>面试官：那你让“不”过来面试我们公司吧，你先回去等通知吧</li>
</ul>
</li>
<li>哪些面试会出现红黑树呢？<ul>
<li>在面试时基本不会让手写红黑树（即使是面试Google、Apple这样的公司，也很少会出现）</li>
<li>通常是这样问题的（比如腾讯的一次面试题）：为什么已经有平衡二叉树（比如AVL树）了，还需要红黑树呢？</li>
</ul>
</li>
</ul>
<h4 id="1-2-红黑树的介绍"><a href="#1-2-红黑树的介绍" class="headerlink" title="1.2 红黑树的介绍"></a>1.2 红黑树的介绍</h4><ul>
<li>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构<ul>
<li>它在1972年由<code>鲁道夫·贝尔</code>发明，被称为“对称二叉B树”，它现代的名字源于Leo J. Guibas和<code>罗伯特·塞奇威克</code>于<code>1978年</code>写的一篇论文</li>
</ul>
</li>
<li>红黑树，除了符合二叉搜索树的基本规则外，还添加了一下特性：<ul>
<li><code>1.节点是红色或黑色</code></li>
<li><code>2.根节点是黑色</code></li>
<li><code>3.每个叶子节点都是黑色的空节点（NIL节点，空节点）</code><ul>
<li>第三条性质要求每个叶节点（空节点）是黑色的</li>
<li>这是因为在红黑树中，黑色节点的数量表示从根节点到叶子节点的黑色节点数量</li>
</ul>
</li>
<li><code>4.每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</code><ul>
<li>第四条性质保证了红色节点的颜色不会影响树的平衡，同时保证了红色节点的出现不会导致连续的红色节点</li>
</ul>
</li>
<li><code>5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</code><ul>
<li>第五条性质是最重要的性质，保证了红黑树的平衡性</li>
</ul>
</li>
</ul>
</li>
<li>这些规则会让人一头雾水<ul>
<li>完成搞不懂规则叠加起来，怎么让一棵树平衡的</li>
<li>但是它们还是被一些聪明的人发明出来了</li>
</ul>
</li>
</ul>
<h4 id="1-3-红黑树的图例"><a href="#1-3-红黑树的图例" class="headerlink" title="1.3 红黑树的图例"></a>1.3 红黑树的图例</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752401864946.png" alt="75240186494"></p>
<h3 id="2-红黑树的相对平衡"><a href="#2-红黑树的相对平衡" class="headerlink" title="2. 红黑树的相对平衡"></a>2. 红黑树的相对平衡</h3><ul>
<li>前面的性质约束，确保了红黑树的关键特性：<ul>
<li>从<code>根到叶子</code>的<code>最长可能路径</code>，不会超过<code>最短可能路径</code>的<code>两倍长</code></li>
<li>结果就是这个树<code>基本</code>是平衡的</li>
<li>虽然<code>没有做到绝对的平衡</code>，但是<code>可以保证在最坏的情况下，依然是高效</code>的</li>
</ul>
</li>
<li>为什么可以做到 <code>最长路径不超过最短路径的两倍</code> 呢？<ul>
<li>性质五决定了最短路径和最长路径必须有相同的黑色节点</li>
<li>路径最短的情况：全部是黑色节点n</li>
<li>路径最长的情况：黑色节点的数量也是n，中间全部是红色节点n – 1<ul>
<li>性质二：根节点是黑节点</li>
<li>性质三：叶子节点都是黑节点</li>
<li>性质四：两个红色节点不能相连</li>
</ul>
</li>
<li>最短路径为 n – 1（边的数量）</li>
<li>长路径为 (n + n – 1) - 1 &#x3D; 2n – 2</li>
<li>所以 最长路径 <code>一定不超过</code> 最短路径的2倍</li>
</ul>
</li>
</ul>
<h3 id="3-红黑树的代码思路"><a href="#3-红黑树的代码思路" class="headerlink" title="3. 红黑树的代码思路"></a>3. 红黑树的代码思路</h3><ul>
<li>手写一个 TypeScript 红黑树的详细步骤：<ul>
<li><code>定义红黑树的节点</code>：定义一个带有键、值、颜色、左子节点、右子节点和父节点的类</li>
<li><code>实现左旋操作</code>：将一个节点向左旋转，保持红黑树的性质</li>
<li><code>实现右旋操作</code>：将一个节点向右旋转，保持红黑树的性质</li>
<li><code>实现插入操作</code>：在红黑树中插入一个新的节点，并保持红黑树的性质</li>
<li><code>实现删除操作</code>：从红黑树中删除一个节点，并保持红黑树的性质</li>
<li><code>实现修复红黑树性质</code>：在插入或删除操作后，通过旋转和变色来修复红黑树的性质</li>
<li>其他方法较为简单，可以自行实现</li>
</ul>
</li>
<li>具体代码参考我的Markdown笔记</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红黑树：此代码给出了主要是左旋、右旋、插入、搜索节点的方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; btPrint, <span class="title class_">PrintableNode</span> &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="variable constant_">RED</span>,</span><br><span class="line">  <span class="variable constant_">BLACK</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedBlackNode</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">PrintableNode</span> &#123;</span><br><span class="line">  <span class="attr">data</span>: T;</span><br><span class="line">  <span class="attr">color</span>: <span class="title class_">Color</span>;</span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">RedBlackNode</span>&lt;T&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">RedBlackNode</span>&lt;T&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">RedBlackNode</span>&lt;T&gt; | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.data&#125;</span>-<span class="subst">$&#123;Color[<span class="variable language_">this</span>.color]&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    data: T,</span></span><br><span class="line"><span class="params">    color: Color = Color.RED,</span></span><br><span class="line"><span class="params">    parent: RedBlackNode&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    left: RedBlackNode&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    right: RedBlackNode&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = parent;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = left;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedBlackTree</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="title class_">RedBlackNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 插入一个新节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> data 待插入节点的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">data: T</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个新节点</span></span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> <span class="title class_">RedBlackNode</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果红黑树为空，将该节点作为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = newNode;</span><br><span class="line">      <span class="comment">// 根节点为黑色</span></span><br><span class="line">      newNode.<span class="property">color</span> = <span class="title class_">Color</span>.<span class="property">BLACK</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化搜索变量current和parent</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">current</span>: <span class="title class_">RedBlackNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">parent</span>: <span class="title class_">RedBlackNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索合适的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      parent = current;</span><br><span class="line">      <span class="comment">// 如果data小于当前节点，则继续往左子树搜索</span></span><br><span class="line">      <span class="keyword">if</span> (data &lt; current.<span class="property">data</span>) &#123;</span><br><span class="line">        current = current.<span class="property">left</span>;</span><br><span class="line">        <span class="comment">// 否则继续往右子树搜索</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current = current.<span class="property">right</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新节点的父节点设置为搜索到的父节点</span></span><br><span class="line">    newNode.<span class="property">parent</span> = parent;</span><br><span class="line">    <span class="comment">// 将新节点插入到合适的位置</span></span><br><span class="line">    <span class="keyword">if</span> (data &lt; parent!.<span class="property">data</span>) &#123;</span><br><span class="line">      parent!.<span class="property">left</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent!.<span class="property">right</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修复插入导致的红黑树性质破坏</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">fixInsertion</span>(newNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修复红黑树性质</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">fixInsertion</span>(<span class="params">node: RedBlackNode&lt;T&gt;</span>) &#123;</span><br><span class="line">    <span class="comment">// 当父节点存在且颜色为红时</span></span><br><span class="line">    <span class="keyword">while</span> (node.<span class="property">parent</span> &amp;&amp; node.<span class="property">parent</span>.<span class="property">color</span> === <span class="title class_">Color</span>.<span class="property">RED</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取祖父节点</span></span><br><span class="line">      <span class="keyword">let</span> grandParent = node.<span class="property">parent</span>.<span class="property">parent</span>!;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 父节点是祖父节点的左子节点</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">parent</span> === grandParent.<span class="property">left</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取叔叔节点</span></span><br><span class="line">        <span class="keyword">let</span> uncle = grandParent.<span class="property">right</span>;</span><br><span class="line">        <span class="comment">// 叔叔节点存在且颜色为红</span></span><br><span class="line">        <span class="keyword">if</span> (uncle &amp;&amp; uncle.<span class="property">color</span> === <span class="title class_">Color</span>.<span class="property">RED</span>) &#123;</span><br><span class="line">          <span class="comment">// 将父节点颜色改为黑，叔叔节点颜色改为黑，祖父节点颜色改为红，node节点变为祖父节点，继续循环</span></span><br><span class="line">          node.<span class="property">parent</span>.<span class="property">color</span> = <span class="title class_">Color</span>.<span class="property">BLACK</span>;</span><br><span class="line">          uncle.<span class="property">color</span> = <span class="title class_">Color</span>.<span class="property">BLACK</span>;</span><br><span class="line">          grandParent.<span class="property">color</span> = <span class="title class_">Color</span>.<span class="property">RED</span>;</span><br><span class="line">          node = grandParent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 当前节点是父节点的右子节点</span></span><br><span class="line">          <span class="keyword">if</span> (node === node.<span class="property">parent</span>.<span class="property">right</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前节点变为父节点，进行左旋操作</span></span><br><span class="line">            node = node.<span class="property">parent</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">leftRotate</span>(node);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将父节点颜色改为黑，祖父节点颜色改为红，进行右旋操作</span></span><br><span class="line">          node.<span class="property">parent</span>!.<span class="property">color</span> = <span class="title class_">Color</span>.<span class="property">BLACK</span>;</span><br><span class="line">          grandParent.<span class="property">color</span> = <span class="title class_">Color</span>.<span class="property">RED</span>;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">rightRotate</span>(grandParent);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父节点是祖父节点的右子节点，与上面的同理</span></span><br><span class="line">        <span class="keyword">let</span> uncle = grandParent.<span class="property">left</span>;</span><br><span class="line">        <span class="comment">// 如果叔叔节点是红色的</span></span><br><span class="line">        <span class="keyword">if</span> (uncle &amp;&amp; uncle.<span class="property">color</span> === <span class="title class_">Color</span>.<span class="property">RED</span>) &#123;</span><br><span class="line">          <span class="comment">// 父节点设置为黑色</span></span><br><span class="line">          node.<span class="property">parent</span>.<span class="property">color</span> = <span class="title class_">Color</span>.<span class="property">BLACK</span>;</span><br><span class="line">          <span class="comment">// 叔叔节点设置为黑色</span></span><br><span class="line">          uncle.<span class="property">color</span> = <span class="title class_">Color</span>.<span class="property">BLACK</span>;</span><br><span class="line">          <span class="comment">// 祖父节点设置为红色</span></span><br><span class="line">          grandParent.<span class="property">color</span> = <span class="title class_">Color</span>.<span class="property">RED</span>;</span><br><span class="line">          <span class="comment">// 将当前节点设置为祖父节点</span></span><br><span class="line">          node = grandParent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果当前节点是父节点的左节点</span></span><br><span class="line">          <span class="keyword">if</span> (node === node.<span class="property">parent</span>.<span class="property">left</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前节点设置为父节点</span></span><br><span class="line">            node = node.<span class="property">parent</span>;</span><br><span class="line">            <span class="comment">// 右旋父节点</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">rightRotate</span>(node);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 父节点设置为黑色</span></span><br><span class="line">          node.<span class="property">parent</span>!.<span class="property">color</span> = <span class="title class_">Color</span>.<span class="property">BLACK</span>;</span><br><span class="line">          <span class="comment">// 祖父节点设置为红色</span></span><br><span class="line">          grandParent.<span class="property">color</span> = <span class="title class_">Color</span>.<span class="property">RED</span>;</span><br><span class="line">          <span class="comment">// 左旋祖父节点</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">leftRotate</span>(grandParent);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点设置为黑色节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span>!.<span class="property">color</span> = <span class="title class_">Color</span>.<span class="property">BLACK</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 左旋操作</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node 要进行左旋的结点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">leftRotate</span>(<span class="params">node: RedBlackNode&lt;T&gt;</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取 node 的右子节点</span></span><br><span class="line">    <span class="keyword">let</span> rightChild = node.<span class="property">right</span>!;</span><br><span class="line">    <span class="comment">// 将右子节点的左子节点赋值给 node 的右子节点</span></span><br><span class="line">    node.<span class="property">right</span> = rightChild.<span class="property">left</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点的左子节点不为空，则将右子节点的左子节点的父节点指向 node</span></span><br><span class="line">    <span class="keyword">if</span> (rightChild.<span class="property">left</span>) &#123;</span><br><span class="line">      rightChild.<span class="property">left</span>.<span class="property">parent</span> = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将右子节点的父节点指向 node 的父节点</span></span><br><span class="line">    rightChild.<span class="property">parent</span> = node.<span class="property">parent</span>;</span><br><span class="line">    <span class="comment">// 如果 node 的父节点为空，则将右子节点设为根结点</span></span><br><span class="line">    <span class="keyword">if</span> (!node.<span class="property">parent</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 node 是它父节点的左子节点，则将右子节点设为 node 父节点的左子节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node === node.<span class="property">parent</span>.<span class="property">left</span>) &#123;</span><br><span class="line">      node.<span class="property">parent</span>.<span class="property">left</span> = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，将右子节点设为 node 父节点的右子节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      node.<span class="property">parent</span>.<span class="property">right</span> = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 node 的父节点指向 rightChild，并将 rightChild 的左子节点指向 node</span></span><br><span class="line">    rightChild.<span class="property">left</span> = node;</span><br><span class="line">    node.<span class="property">parent</span> = rightChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 右旋转</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node 旋转节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">rightRotate</span>(<span class="params">node: RedBlackNode&lt;T&gt;</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取旋转节点的左子节点</span></span><br><span class="line">    <span class="keyword">let</span> leftChild = node.<span class="property">left</span>!;</span><br><span class="line">    <span class="comment">// 将旋转节点的左子节点的右子节点，接到旋转节点的左边</span></span><br><span class="line">    node.<span class="property">left</span> = leftChild.<span class="property">right</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点的右子节点不为空，设置它的父节点为旋转节点</span></span><br><span class="line">    <span class="keyword">if</span> (leftChild.<span class="property">right</span>) &#123;</span><br><span class="line">      leftChild.<span class="property">right</span>.<span class="property">parent</span> = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将左子节点的父节点设为旋转节点的父节点</span></span><br><span class="line">    leftChild.<span class="property">parent</span> = node.<span class="property">parent</span>;</span><br><span class="line">    <span class="comment">// 如果旋转节点的父节点不存在，说明左子节点变成根节点</span></span><br><span class="line">    <span class="keyword">if</span> (!node.<span class="property">parent</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = leftChild;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node === node.<span class="property">parent</span>.<span class="property">right</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果旋转节点是它父节点的右子节点，将父节点的右子节点设为左子节点</span></span><br><span class="line">      node.<span class="property">parent</span>.<span class="property">right</span> = leftChild;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果旋转节点是它父节点的左子节点，将父节点的左子节点设为左子节点</span></span><br><span class="line">      node.<span class="property">parent</span>.<span class="property">left</span> = leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将旋转节点设为左子节点的右子节点</span></span><br><span class="line">    leftChild.<span class="property">right</span> = node;</span><br><span class="line">    <span class="comment">// 将旋转节点的父节点设为左子节点</span></span><br><span class="line">    node.<span class="property">parent</span> = leftChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找红黑树中的最小值</span></span><br><span class="line">  <span class="title function_">minimum</span>(<span class="attr">node</span>: <span class="title class_">RedBlackNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="variable language_">this</span>.<span class="property">root</span>): <span class="title class_">RedBlackNode</span>&lt;T&gt; | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = node;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current.<span class="property">left</span>) &#123;</span><br><span class="line">      current = current.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找红黑树中的某个节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">search</span>(<span class="attr">data</span>: T): <span class="title class_">RedBlackNode</span>&lt;T&gt; | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">parent</span>: <span class="title class_">RedBlackNode</span>&lt;T&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">data</span> === data) &#123;</span><br><span class="line">        node.<span class="property">parent</span> = parent;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line">      parent = node;</span><br><span class="line">      <span class="keyword">if</span> (data &lt; node.<span class="property">data</span>) &#123;</span><br><span class="line">        node = node.<span class="property">left</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node = node.<span class="property">right</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rbtree = <span class="keyword">new</span> <span class="title class_">RedBlackTree</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">rbtree.<span class="title function_">insert</span>(<span class="number">10</span>);</span><br><span class="line">rbtree.<span class="title function_">insert</span>(<span class="number">20</span>);</span><br><span class="line">rbtree.<span class="title function_">insert</span>(<span class="number">30</span>);</span><br><span class="line">rbtree.<span class="title function_">insert</span>(<span class="number">40</span>);</span><br><span class="line">rbtree.<span class="title function_">insert</span>(<span class="number">50</span>);</span><br><span class="line">rbtree.<span class="title function_">insert</span>(<span class="number">60</span>);</span><br><span class="line">rbtree.<span class="title function_">insert</span>(<span class="number">70</span>);</span><br><span class="line">rbtree.<span class="title function_">insert</span>(<span class="number">80</span>);</span><br><span class="line">rbtree.<span class="title function_">insert</span>(<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="title function_">btPrint</span>(rbtree.<span class="property">root</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752894658434.png" alt="75289465843"></p>
<h3 id="4-红黑树的性能分析"><a href="#4-红黑树的性能分析" class="headerlink" title="4. 红黑树的性能分析"></a>4. 红黑树的性能分析</h3><ul>
<li>事实上，红黑树的性能在搜索上是不如AVL树的，为什么呢？</li>
<li>我们来看一下下面的红黑树：<ul>
<li>首先，它符合是一颗红黑树吗？符合</li>
<li>这个时候我们插入 节点30，会被插入到哪里呢？<ul>
<li>27的右边，并且节点30是红色节点时，依然符合红黑树的性质</li>
</ul>
</li>
<li>也就是对于红黑树来说，它不需要进行任何操作</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752403142326.png" alt="75240314232"></p>
<ul>
<li>那么AVL树会怎么样呢？<ul>
<li>如果是AVL树必然要对17、25、27节点进行右旋转</li>
<li>事实上左旋转是一系列的操作</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/1752403223756.png" alt="75240322375"></p>
<ul>
<li>但是红黑树的高度比AVL树要高：<ul>
<li>所以如果同样是搜索30，那么红黑树需要搜索4次，AVL树搜索3次</li>
<li>所以红黑树相当于牺牲了一点点的搜索性能，来提高了插入和删除的性能</li>
</ul>
</li>
</ul>
<h3 id="5-AVL树和红黑树的选择"><a href="#5-AVL树和红黑树的选择" class="headerlink" title="5. AVL树和红黑树的选择"></a>5. AVL树和红黑树的选择</h3><ul>
<li>AVL树和红黑树的性能对比<ul>
<li>AVL树是一种平衡度更高的二叉搜索树，所以在<code>搜索效率</code>上会更高</li>
<li>但是AVL树为了维护这种平衡性，在<code>插入和删除操作</code>时，通常会进行更多的旋转操作，所以<code>效率相对红黑树较低</code></li>
<li>红黑树在平衡度上相较于AVL树没有那么严格，所以<code>搜索效率上会低一些</code></li>
<li>但是红黑树在<code>插入和删除操作</code>时，通常需要更少的旋转操作，所以<code>效率相对AVL树较高</code></li>
<li>它们的搜索、添加、删除时间复杂度都是O(logn)，但是细节上会有一些差异</li>
</ul>
</li>
<li>开发中如何进行选择呢？<ul>
<li>选择AVL树还是红黑树，取决于具体的应用需求</li>
<li>如果需要保证每个节点的高度尽可能地平衡，可以选择AVL树</li>
<li>如果需要保证删除操作的效率，可以选择红黑树</li>
</ul>
</li>
<li>在早期的时候，很多场景会选择AVL树，目前选择红黑树的越来越多（AVL树依然是一种重要的平衡树）<ul>
<li>比如操作系统内核中的内存管理</li>
<li>比如Java的TreeMap、TreeSet底层的源码</li>
</ul>
</li>
</ul>
<h1 id="JavaScript算法和面试题"><a href="#JavaScript算法和面试题" class="headerlink" title="JavaScript算法和面试题"></a>JavaScript算法和面试题</h1><h2 id="（一）排序算法（Sorting-algorithm）"><a href="#（一）排序算法（Sorting-algorithm）" class="headerlink" title="（一）排序算法（Sorting algorithm）"></a>（一）排序算法（Sorting algorithm）</h2><h3 id="1-排序算法的介绍"><a href="#1-排序算法的介绍" class="headerlink" title="1. 排序算法的介绍"></a>1. 排序算法的介绍</h3><ul>
<li>什么是排序？<ul>
<li>排序（Sorting）是一个非常 非常 非常 常见的功能，在平时生活中也是随处可见的</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752583375998.png" alt="75258337599"></p>
<h3 id="2-人和计算机区别"><a href="#2-人和计算机区别" class="headerlink" title="2. 人和计算机区别"></a>2. 人和计算机区别</h3><h4 id="2-1-如何排序？-人来排序"><a href="#2-1-如何排序？-人来排序" class="headerlink" title="2.1 如何排序？ 人来排序"></a>2.1 如何排序？ 人来排序</h4><ul>
<li>如何排序？<ul>
<li>需求：对一组身高不等的10个人进行排序</li>
</ul>
</li>
<li>人来排序：<ul>
<li>如果是人来排序事情会非常简单，因为人<code>只要扫过去一眼</code>就能看出来谁最高谁最低</li>
<li>然后让最低（或者最高）的站在前面，其他人依次后移</li>
<li>按照这这样的方法，依次类推就可以了</li>
</ul>
</li>
<li>人排序的特点：<ul>
<li>可以<code>统筹全局</code>，直接获取到最高或者最低的结果</li>
<li><code>不需要考虑空间</code>的问题，因为通常情况下都有足够的空间来<code>相互推嚷</code></li>
</ul>
</li>
<li>人排序的缺点：<ul>
<li>容易出错</li>
<li>数据量非常庞大时，很难进行排序（比如有1000000的数据量）</li>
</ul>
</li>
</ul>
<h4 id="2-2-如何排序？-计算机来排序"><a href="#2-2-如何排序？-计算机来排序" class="headerlink" title="2.2 如何排序？ 计算机来排序"></a>2.2 如何排序？ 计算机来排序</h4><ul>
<li>计算机来排序：<ul>
<li>计算机有些笨拙，它只能<code>执行指令</code>，所以没办法一眼扫过去</li>
<li>计算机也很聪明，只要你写出了正确的指令，可以让它帮你做<code>无数次</code>类似的事情而不用担心<code>出现错误</code></li>
<li>并且计算机排序也无需担心<code>数据量的大小</code>，想象一下，让人排序10000个，甚至更大的数据项你还能一眼扫过去吗?</li>
<li>人在排序时不一定要固定<code>特有的空间</code>，他们可以相互推推嚷嚷就腾出了位置，还能互相前后站立</li>
<li>但是计算机必须有<code>严密的逻辑</code>和<code>特定的指令</code></li>
</ul>
</li>
<li>计算机排序的特点：<ul>
<li>计算机不能像人一样，一眼扫过去这样通览所有的数据</li>
<li>它只能根据计算机的<code>比较操作原理</code>，在<code>同一个时间对两个队员进行比较</code></li>
<li>在人类看来很简单的事情，计算机的算法却不能看到全景</li>
<li>因此，它只<code>能一步步解决具体问题和遵循一些简单的规则</code></li>
</ul>
</li>
</ul>
<h3 id="3-常见的排序算法"><a href="#3-常见的排序算法" class="headerlink" title="3. 常见的排序算法"></a>3. 常见的排序算法</h3><h4 id="3-1-认识排序算法"><a href="#3-1-认识排序算法" class="headerlink" title="3.1 认识排序算法"></a>3.1 认识排序算法</h4><ul>
<li>排序算法就是研究如何对一个集合进行高效排序的算法，也是在面试时非常常见的面试题型之一</li>
<li>维基百科堆排序算法的解释：<ul>
<li>在计算机科学与数学中，一个<code>排序算法</code>（英语：Sorting algorithm）是一种能将<code>一串资料</code>依照特定排序方式排列的算法</li>
<li>虽然排序算法从名称来看非常容易理解，但是从计算机科学发展以来，在此问题上已经有大量的研究</li>
</ul>
</li>
<li>由于排序非常重要而且可能非常耗时，所以它已经成为一个计算机科学中广泛研究的课题<ul>
<li>而且人们已经研究出一套<code>成熟的方案</code>来实现排序</li>
<li>因此，幸运的是你<code>并不需要是发明某种排序算法</code>，而是站在巨人的肩膀上即可</li>
</ul>
</li>
<li>在计算机科学所使用的排序算法通常依以下标准分类：<ul>
<li><code>计算的时间复杂度</code>：使用大O表示法，也可以实际测试消耗的时间</li>
<li><code>内存使用量</code>（甚至是其他电脑资源）：比如外部排序，使用磁盘来存储排序的数据</li>
<li><code>稳定性</code>：稳定排序算法会让原本有相等键值的纪录维持相对次序</li>
<li>排序的方法：插入、交换、选择、合并等等</li>
</ul>
</li>
</ul>
<h4 id="3-2-常见的排序算法"><a href="#3-2-常见的排序算法" class="headerlink" title="3.2 常见的排序算法"></a>3.2 常见的排序算法</h4><ul>
<li>常见的排序算法非常多：<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li><code>归并排序</code></li>
<li><code>快速排序</code></li>
<li><code>堆排序</code></li>
<li>希尔排序</li>
<li>计数排序</li>
<li>桶排序</li>
<li>基数排序</li>
<li>内省排序</li>
<li>平滑排序</li>
</ul>
</li>
</ul>
<h4 id="3-3-排序算法的时间复杂度"><a href="#3-3-排序算法的时间复杂度" class="headerlink" title="3.3 排序算法的时间复杂度"></a>3.3 排序算法的时间复杂度</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752584359021.png" alt="75258435902"></p>
<h3 id="4-排序的学习思路"><a href="#4-排序的学习思路" class="headerlink" title="4. 排序的学习思路"></a>4. 排序的学习思路</h3><ul>
<li>因为我们要学习多种排序算法，所以我对他们的学习思路进行了统一的安排：<ul>
<li>① 介绍某种排序算法：如果该排序算法有一些历史背景或者故事，我们也会一起介绍</li>
<li>② 分析某种排序算法的思路步骤</li>
<li>③ 某种排序算法的图解</li>
<li>④ 排序算法的代码实现过程（一步步手写实现）</li>
<li>⑤ 排序算法的复杂度分析</li>
<li>⑥ 排序算法的小结</li>
</ul>
</li>
</ul>
<h3 id="5-冒泡排序"><a href="#5-冒泡排序" class="headerlink" title="5. 冒泡排序"></a>5. 冒泡排序</h3><h4 id="5-1-冒泡排序的定义"><a href="#5-1-冒泡排序的定义" class="headerlink" title="5.1 冒泡排序的定义"></a>5.1 冒泡排序的定义</h4><ul>
<li>我们要学习非常多种类的排序算法，那么我们可以先从一个最简单的排序算法入手：冒泡排序</li>
<li>冒泡排序（Bubble Sort）是一种简单的排序方法<ul>
<li>基本思路是通过<code>两两比较相邻的元素并交换它们的位置</code>，从而使整个序列按照顺序排列</li>
<li>该算法一趟排序后，<code>最大值总是会移到数组最后面</code>，那么接下来就不用再考虑这个最大值</li>
<li>一直重复这样的操作，最终就可以得到排序完成的数组</li>
</ul>
</li>
<li>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数组的尾端，故名 “冒泡排序”</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752586799868.png" alt="75258679986"></p>
<h4 id="5-2-冒泡排序的流程"><a href="#5-2-冒泡排序的流程" class="headerlink" title="5.2 冒泡排序的流程"></a>5.2 冒泡排序的流程</h4><ul>
<li>冒泡排序的流程如下：<ul>
<li>从第一个元素开始，逐一比较相邻元素的大小</li>
<li>如果前一个元素比后一个元素大，则交换位置</li>
<li>在第一轮比较结束后，最大的元素被移动到了最后一个位置</li>
<li>在下一轮比较中，不再考虑最后一个位置的元素，重复上述操作</li>
<li>每轮比较结束后，需要排序的元素数量减一，直到没有需要排序的元素，排序结束</li>
<li>这个流程会一直循环，直到所有元素都有序排列为止</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752586880551.png" alt="75258688055"></p>
<h4 id="5-3-冒泡排序的图解"><a href="#5-3-冒泡排序的图解" class="headerlink" title="5.3 冒泡排序的图解"></a>5.3 冒泡排序的图解</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752586919222.png" alt="75258691922"></p>
<h4 id="5-4-冒泡排序的代码"><a href="#5-4-冒泡排序的代码" class="headerlink" title="5.4 冒泡排序的代码"></a>5.4 冒泡排序的代码</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">arr: <span class="built_in">number</span>[], i: <span class="built_in">number</span>, j: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> temp = arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="comment">// 1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">const</span> n = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.外层循环</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 看内层循环某一次是否交换</span></span><br><span class="line">    <span class="keyword">let</span> swapped = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.内层循环，比较两个相邻的元素，将较大值交换到右侧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="title function_">swap</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        swapped = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 某一次内层循环没有交换，说明已经排序好了</span></span><br><span class="line">    <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">18</span>, <span class="number">45</span>, <span class="number">27</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">88</span>, <span class="number">65</span>];</span><br><span class="line"><span class="comment">// 输出：[9, 15, 18, 27, 45, 65, 88]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bubbleSort</span>(nums));</span><br></pre></td></tr></table></figure>

<ul>
<li>测试数组排序的自动化函数：utils.ts</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.ts</span></span><br><span class="line"><span class="comment">// 交换数组元素位置</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">arr: <span class="built_in">number</span>[], i: <span class="built_in">number</span>, j: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> temp = arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序的顺序对不对</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isSorted</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个工具，直接测试排序方法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SortAlgoFn</span> = <span class="function">(<span class="params">arr: <span class="built_in">number</span>[]</span>) =&gt;</span> <span class="built_in">number</span>[];</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">testSort</span>(<span class="params">sortFn: SortAlgoFn</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.初始化一个长度为10的数组，值是随机200以内的数字</span></span><br><span class="line">  <span class="keyword">const</span> nums = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">200</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.使用排序方法，对数组进行排序</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;排序前的原数组：&quot;</span>, nums);</span><br><span class="line">  <span class="keyword">const</span> newNums = <span class="title function_">sortFn</span>(nums);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;排序后的新数组：&quot;</span>, newNums);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;是否排序后有正确的顺序：&quot;</span>, <span class="title function_">isSorted</span>(newNums));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：testSort里面会随机个长度为10的数组，然后调用排序算法</span></span><br><span class="line"><span class="comment">// 排序前的原数组：[87, 6, 159, 53, 108, 187, 66, 75, 69, 190]</span></span><br><span class="line"><span class="comment">// 排序后的新数组：[6, 53, 66, 69, 75, 87, 108, 159, 187, 190]</span></span><br><span class="line"><span class="comment">// 是否排序后有正确的顺序： true</span></span><br><span class="line"><span class="title function_">testSort</span>(bubbleSort);</span><br></pre></td></tr></table></figure>

<h4 id="5-5-冒泡排序的时间复杂度"><a href="#5-5-冒泡排序的时间复杂度" class="headerlink" title="5.5 冒泡排序的时间复杂度"></a>5.5 冒泡排序的时间复杂度</h4><ul>
<li>在冒泡排序中，每次比较两个相邻的元素，并交换他们的位置，如果左边的元素比右边的元素大，则交换它们的位置。这样的比较和交换的过程可以用一个循环实现</li>
<li><code>最好情况：O(n)</code><ul>
<li>即待排序的序列已经是有序的</li>
<li>此时仅需遍历一遍序列，不需要进行交换操作</li>
</ul>
</li>
<li><code>最坏情况：O(n^2)</code><ul>
<li>即待排序的序列是逆序的</li>
<li>需要进行n-1轮排序，每一轮中需要进行n-i-1次比较和交换操作</li>
</ul>
</li>
<li><code>平均情况：O(n^2)</code><ul>
<li>即待排序的序列是随机排列的</li>
<li>每一对元素的比较和交换都有1&#x2F;2的概率发生，因此需要进行n-1轮排序，每一轮中需要进行n-i-1次比较和交换操作</li>
</ul>
</li>
<li>由此可见，冒泡排序的时间复杂度主要取决于数据的初始顺序，最坏情况下时间复杂度是O(n^2)，不适用于大规模数据的排序</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用coderwhy整个库里面的工具，测试冒泡排序的时间</span></span><br><span class="line"><span class="keyword">import</span> &#123; measureSort &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入冒泡排序的函数</span></span><br><span class="line"><span class="comment">// 输出：使用 bubbleSort 算法 排序 100000 个元素 消耗时间为 14238.68 毫秒.</span></span><br><span class="line"><span class="title function_">measureSort</span>(bubbleSort);</span><br></pre></td></tr></table></figure>

<h4 id="5-6-冒泡排序的总结"><a href="#5-6-冒泡排序的总结" class="headerlink" title="5.6 冒泡排序的总结"></a>5.6 冒泡排序的总结</h4><ul>
<li>冒泡排序适用于数据规模较小的情况，因为它的时间复杂度为O(n^2)，对于<code>大数据量的排序会变得很慢</code></li>
<li>同时，它的实现简单，代码实现也容易理解，适用于学习排序算法的初学者</li>
<li>但是，在实际的应用中，冒泡排序并不常用，因为它的效率较低</li>
<li>因此，在实际应用中，冒泡排序通常被更高效的排序算法代替，如快速排序、归并排序等</li>
</ul>
<h3 id="6-选择排序"><a href="#6-选择排序" class="headerlink" title="6. 选择排序"></a>6. 选择排序</h3><h4 id="6-1-选择排序的定义"><a href="#6-1-选择排序的定义" class="headerlink" title="6.1 选择排序的定义"></a>6.1 选择排序的定义</h4><ul>
<li>选择排序（Selection Sort）是一种简单的排序算法</li>
<li>它的基本思想是：<ul>
<li>首先在<code>未排序的数列中找到最小（大）元素</code>，然后<code>将其存放到数列的起始位置</code></li>
<li>接着，再从剩余未排序的元素中<code>继续寻找最小（大）元素</code>，然后<code>放到已排序序列的末尾</code></li>
<li>以此类推，<code>直到所有元素均排序完毕</code></li>
</ul>
</li>
<li>选择排序的主要优点与数据移动有关<ul>
<li>如果<code>某个元素位于正确的最终位置</code>，则它<code>不会被移动</code></li>
<li>选择排序<code>每次交换一对元素</code>，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行<code>至多n-1次交换</code></li>
<li>在所有的完全<code>依靠交换去移动元素的排序方法</code>中，<code>选择排序属于非常好</code>的一种</li>
</ul>
</li>
<li>选择排序的实现方式很简单，并且容易理解，因此它是学习排序算法的很好的选择</li>
</ul>
<h4 id="6-2-选择排序的流程"><a href="#6-2-选择排序的流程" class="headerlink" title="6.2 选择排序的流程"></a>6.2 选择排序的流程</h4><ul>
<li>选择排序的实现思路可以分为以下几个步骤：</li>
<li>遍历数组，找到未排序部分的最小值<ul>
<li>① 首先，将未排序部分的第一个元素标记为最小值</li>
<li>② 然后，从未排序部分的第二个元素开始遍历，依次和已知的最小值进行比较</li>
<li>③ 如果找到了比最小值更小的元素，就更新最小值的位置</li>
</ul>
</li>
<li>将未排序部分的最小值放置到已排序部分的后面<ul>
<li>① 首先，用解构赋值的方式交换最小值和已排序部分的末尾元素的位置</li>
<li>② 然后，已排序部分的长度加一，未排序部分的长度减一</li>
</ul>
</li>
<li>重复执行步骤 1 和 2，直到所有元素都有序</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752895338012.png" alt="75289533801"></p>
<h4 id="6-3-选择排序的图解"><a href="#6-3-选择排序的图解" class="headerlink" title="6.3 选择排序的图解"></a>6.3 选择排序的图解</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752895143355.png" alt="75289514335"></p>
<h4 id="6-4-选择排序的代码"><a href="#6-4-选择排序的代码" class="headerlink" title="6.4 选择排序的代码"></a>6.4 选择排序的代码</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; measureSort &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; swap, testSort &#125; <span class="keyword">from</span> <span class="string">&quot;./utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">selectionSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> n = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 外层循环：经过多少次找最小值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 记录未排序部分最小值的索引</span></span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="comment">// 内层循环：每次找出最小值的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换位置</span></span><br><span class="line">    <span class="keyword">if</span> (i !== minIndex) &#123;</span><br><span class="line">      <span class="title function_">swap</span>(arr, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序前的原数组： [167, 121, 134, 125, 14, 5, 194, 2, 20, 157]</span></span><br><span class="line"><span class="comment">// 排序后的新数组： [2, 5, 14, 20, 121, 125, 134, 157, 167, 194]</span></span><br><span class="line"><span class="comment">// 是否排序后有正确的顺序： true</span></span><br><span class="line"><span class="title function_">testSort</span>(selectionSort);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：使用 selectionSort 算法 排序 100000 个元素 消耗时间为 3122.97 毫秒.</span></span><br><span class="line"><span class="title function_">measureSort</span>(selectionSort);</span><br></pre></td></tr></table></figure>

<h4 id="6-5-选择排序的时间复杂度"><a href="#6-5-选择排序的时间复杂度" class="headerlink" title="6.5 选择排序的时间复杂度"></a>6.5 选择排序的时间复杂度</h4><ul>
<li>选择排序的时间复杂度是比较容易分析的</li>
<li><code>最好情况时间复杂度：O(n^2)</code><ul>
<li>最好情况是指待排序的数组本身就是有序的</li>
<li>在这种情况下，内层循环每次都需要比较 n-1 次，因此比较次数为 n(n-1)&#x2F;2，交换次数为 0</li>
<li>所以，选择排序的时间复杂度为 O(n^2)</li>
</ul>
</li>
<li><code>最坏情况时间复杂度：O(n^2)</code><ul>
<li>最坏情况是指待排序的数组是倒序排列的</li>
<li>在这种情况下，每次内层循环都需要比较 n-i-1 次，因此比较次数为 n(n-1)&#x2F;2，交换次数也为 n(n-1)&#x2F;2</li>
<li>所以，选择排序的时间复杂度为 O(n^2)</li>
</ul>
</li>
<li><code>平均情况时间复杂度：O(n^2)</code><ul>
<li>平均情况是指待排序的数组是随机排列的</li>
<li>这种情况下，每个元素在内层循环中的位置是等概率的，因此比较次数和交换次数的期望值都是 n(n-1)&#x2F;4</li>
<li>所以，选择排序的时间复杂度为 O(n^2)</li>
</ul>
</li>
</ul>
<h4 id="6-6-选择排序的总结"><a href="#6-6-选择排序的总结" class="headerlink" title="6.6 选择排序的总结"></a>6.6 选择排序的总结</h4><ul>
<li>虽然选择排序的实现非常简单，但是它的时间复杂度较高，对于大规模的数据排序效率较低<ul>
<li>如果需要对大规模的数据进行排序，通常会选择其他更为高效的排序算法，例如快速排序、归并排序等</li>
</ul>
</li>
<li>总的来说，选择排序适用于小规模数据的排序和排序算法的入门学习，对于需要高效排序的场合，可以选择其他更为高效的排序算法</li>
</ul>
<h3 id="7-插入排序"><a href="#7-插入排序" class="headerlink" title="7. 插入排序"></a>7. 插入排序</h3><h4 id="7-1-插入排序的定义"><a href="#7-1-插入排序的定义" class="headerlink" title="7.1 插入排序的定义"></a>7.1 插入排序的定义</h4><ul>
<li>插入排序就像我们打扑克牌时，摸到一张新牌需要插入到手牌中的合适位置一样<ul>
<li>我们<code>会将新牌和手牌中已有的牌进行比较</code>，找到一个<code>合适的位置插入新牌</code></li>
<li>如果<code>新牌比某张牌小</code>，那么<code>我们就把这张牌向右移动一位，为新牌腾出位置</code></li>
<li><code>一直比较直到找到一个合适的位置将新牌插入</code>，这样就完成了一次插入操作</li>
</ul>
</li>
<li>与打牌类似，插入排序（Insertion sort）的实现方法是：<ul>
<li>首先假设第一个数据是已经排好序的，接着取出下一个数据，在已经排好序的数据中从后往前扫描，<code>找到比它小的数的位置</code>，将<code>该位置之后的数整体后移一个单位，然后再将该数插入到该位置</code></li>
<li>不断重复上述操作，直到所有的数据都插入到已经排好序的数据中，排序完成</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752896295416.png" alt="75289629541"></p>
<h4 id="7-2-插入排序的流程"><a href="#7-2-插入排序的流程" class="headerlink" title="7.2 插入排序的流程"></a>7.2 插入排序的流程</h4><ul>
<li>插入排序的流程如下：<ul>
<li>① 首先，假设数组的第一个元素已经排好序了，因为它只有一个元素，所以可以认为是有序的</li>
<li>② 然后，从第二个元素开始，不断与前面的有序数组元素进行比较</li>
<li>③ 如果当前元素小于前面的有序数组元素，则把当前元素插入到前面的合适位置</li>
<li>④ 否则，继续与前面的有序数组元素进行比较</li>
<li>⑤ 以此类推，直到整个数组都有序</li>
<li>⑥ 循环步骤2~5，直到最后一个元素</li>
<li>⑦ 完成排序</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752896193323.png" alt="75289619332"></p>
<h4 id="7-3-插入排序的图解"><a href="#7-3-插入排序的图解" class="headerlink" title="7.3 插入排序的图解"></a>7.3 插入排序的图解</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752896142062.png" alt="75289614206"></p>
<h4 id="7-4-插入排序的代码"><a href="#7-4-插入排序的代码" class="headerlink" title="7.4 插入排序的代码"></a>7.4 插入排序的代码</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; measureSort &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; testSort &#125; <span class="keyword">from</span> <span class="string">&quot;./utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> n = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 记录要排序的数据</span></span><br><span class="line">    <span class="keyword">const</span> temp = arr[i];</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 不确定循环次数的情况下，使用while循环</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序前的原数组： [159, 49, 183, 145, 41, 85, 117, 85, 80, 71]</span></span><br><span class="line"><span class="comment">// 排序后的新数组： [41, 49, 71, 80, 85, 85, 117, 145, 159, 183]</span></span><br><span class="line"><span class="comment">// 是否排序后有正确的顺序： true</span></span><br><span class="line"><span class="title function_">testSort</span>(insertionSort);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：使用 insertionSort 算法 排序 100000 个元素 消耗时间为 2151.10 毫秒.</span></span><br><span class="line"><span class="title function_">measureSort</span>(insertionSort);</span><br></pre></td></tr></table></figure>

<h4 id="7-5-插入排序的时间复杂度"><a href="#7-5-插入排序的时间复杂度" class="headerlink" title="7.5 插入排序的时间复杂度"></a>7.5 插入排序的时间复杂度</h4><ul>
<li><p>插入排序的时间复杂度的分析</p>
</li>
<li><p><code>最好情况： O(n)</code></p>
<ul>
<li>如果待排序数组已经排好序</li>
<li>那么每个元素只需要比较一次就可以确定它的位置，因此比较的次数为 n-1，移动的次数为 0</li>
<li>所以最好情况下，插入排序的时间复杂度为线性级别，即 O(n)</li>
</ul>
</li>
<li><p><code>最坏情况： O(n^2)</code></p>
<ul>
<li>如果待排序数组是倒序排列的</li>
<li>那么每个元素都需要比较和移动 i 次，其中 i 是元素在数组中的位置</li>
<li>因此比较的次数为 n(n-1)&#x2F;2，移动的次数也为 n(n-1)&#x2F;2</li>
<li>所以最坏情况下，插入排序的时间复杂度为平方级别，即 O(n^2)</li>
</ul>
</li>
<li><p><code>平均情况：O(n^2)</code></p>
<ul>
<li>对于一个随机排列的数组，插入排序的时间复杂度也为平方级别，即 O(n^2)</li>
</ul>
</li>
<li><p>总而言之，如果数组部分有序，插入排序可以比冒泡排序和选择排序更快</p>
<ul>
<li>但是如果数组完全逆序，则插入排序的时间复杂度比较高，不如快速排序或归并排序</li>
</ul>
</li>
</ul>
<h4 id="7-6-插入排序的总结"><a href="#7-6-插入排序的总结" class="headerlink" title="7.6 插入排序的总结"></a>7.6 插入排序的总结</h4><ul>
<li>插入排序是一种简单直观的排序算法，它的基本思想就是将待排序数组分为已排序部分和未排序部分，然后将未排序部分的每个元素插入到已排序部分的合适位置</li>
<li>插入排序的时间复杂度为 O(n^2)，虽然这个复杂度比较高，但是插入排序的实现非常简单，而且在某些情况下性能表现也很好<ul>
<li>比如，如果待排序数组的大部分元素已经排好序，那么插入排序的性能就会比较优秀</li>
</ul>
</li>
<li>总之，插入排序虽然没有快速排序和归并排序等高级排序算法的复杂性和高效性，但是它的实现非常简单，而且在一些特定的场景下表现也很好</li>
</ul>
<h3 id="8-归并排序"><a href="#8-归并排序" class="headerlink" title="8. 归并排序"></a>8. 归并排序</h3><h4 id="8-1-归并排序的定义"><a href="#8-1-归并排序的定义" class="headerlink" title="8.1 归并排序的定义"></a>8.1 归并排序的定义</h4><ul>
<li>归并排序（merge sort）是一种常见的排序算法：<ul>
<li>它的基本思想是将<code>待排序数组分成若干个子数组</code></li>
<li>然后将相邻的<code>子数组归并成一个有序数组</code></li>
<li>最后再将这些有序数组<code>归并（merge）成一个整体有序的数组</code></li>
</ul>
</li>
<li>这个算法最早出现在1945年，由<code>约翰·冯·诺伊曼</code>（John von Neumann）（又一个天才，现代计算机之父，冯·诺依曼结构、普林斯顿结构）首次提出<ul>
<li>当时他在为美国政府工作，研究原子弹的问题</li>
<li>由于当时计算机，他在研究中提出了一种高效计算的方法，这个方法就是<code>归并排序</code></li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752907728128.png" alt="75290772812"></p>
<ul>
<li>归并排序的基本思路是先将待排序数组递归地拆分成两个子数组，然后对每个子数组进行排序，最后将两个有序子数组合并成一个有序数组<ul>
<li>在实现中，我们可以<code>使用“分治法”来完成这个过程，即将大问题分解成小问题</code>来解决</li>
</ul>
</li>
<li>归并排序的算法复杂度为 **O(nlogn)**，是一种比较高效的排序算法，因此在实际应用中被广泛使用</li>
<li>虽然归并排序看起来比较复杂，但是只要理解了基本思路，实现起来并不困难，而且它还是一个非常有趣的算法</li>
</ul>
<h4 id="8-2-归并排序的思路"><a href="#8-2-归并排序的思路" class="headerlink" title="8.2 归并排序的思路"></a>8.2 归并排序的思路</h4><ul>
<li>归并排序是一种基于分治思想的排序算法，其基本思路可以分为三个步骤</li>
<li>步骤一：<strong>分解（Divide）</strong>：归并排序使用<code>递归算法</code>来实现分解过程，具体实现中可以分为以下几个步骤：<ul>
<li>① 如果待排序数组长度为1，认为这个数组已经有序，直接返回</li>
<li>② 将待排序数组分成两个长度相等的子数组，分别对这两个子数组进行递归排序</li>
<li>③ 将两个排好序的子数组合并成一个有序数组，返回这个有序数组</li>
</ul>
</li>
<li>步骤二：<strong>合并（Merge）</strong>：合并过程中，需要比较每个子数组的元素并将它们有序地合并成一个新的数组：<ul>
<li>① 可以使用两个指针 i 和 j 分别指向两个子数组的开头，比较它们的元素大小，并将小的元素插入到新的有序数组中</li>
<li>② 如果其中一个子数组已经遍历完，就将另一个子数组的剩余部分直接插入到新的有序数组中</li>
<li>③ 最后返回这个有序数组。</li>
</ul>
</li>
<li>步骤三：归并排序的递归终止条件：<ul>
<li>归并排序使用递归算法来实现分解过程，当子数组的长度为1时，认为这个子数组已经有序，递归结束</li>
</ul>
</li>
<li>总体来看，归并排序的基本思路是分治法，分成子问题分别解决，然后将子问题的解合并成整体的解</li>
</ul>
<h4 id="8-3-归并排序的图解"><a href="#8-3-归并排序的图解" class="headerlink" title="8.3 归并排序的图解"></a>8.3 归并排序的图解</h4><ul>
<li><p>图解一：</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752907965184.png" alt="75290796518"></p>
</li>
<li><p>图解二：</p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752907990447.png" alt="75290799044"></p>
</li>
</ul>
<h4 id="8-4-归并排序的代码"><a href="#8-4-归并排序的代码" class="headerlink" title="8.4 归并排序的代码"></a>8.4 归并排序的代码</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; measureSort &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; testSort &#125; <span class="keyword">from</span> <span class="string">&quot;./utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.分解(divide)：对数字进行分解(分解成两个小数组)</span></span><br><span class="line">  <span class="comment">// 1.1.切割数组</span></span><br><span class="line">  <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> leftArr = arr.<span class="title function_">slice</span>(<span class="number">0</span>, mid);</span><br><span class="line">  <span class="keyword">const</span> rightArr = arr.<span class="title function_">slice</span>(mid);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.2.递归切割leftArr和rightArr</span></span><br><span class="line">  <span class="keyword">const</span> newLeftArr = <span class="title function_">mergeSort</span>(leftArr);</span><br><span class="line">  <span class="keyword">const</span> newRightArr = <span class="title function_">mergeSort</span>(rightArr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.合并(merge)：对两个子数组进行合并(双指针)</span></span><br><span class="line">  <span class="comment">// 2.1.定义双指针</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">newArr</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; newLeftArr.<span class="property">length</span> &amp;&amp; j &lt; newRightArr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newLeftArr[i] &lt;= newRightArr[j]) &#123;</span><br><span class="line">      newArr.<span class="title function_">push</span>(newLeftArr[i]);</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newArr.<span class="title function_">push</span>(newRightArr[j]);</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2.判断是否某一个数组中还有剩余</span></span><br><span class="line">  <span class="comment">// 循环完左边还有剩余</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt; newLeftArr.<span class="property">length</span>) &#123;</span><br><span class="line">    newArr.<span class="title function_">push</span>(...newLeftArr.<span class="title function_">slice</span>(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环完右边还有剩余</span></span><br><span class="line">  <span class="keyword">if</span> (j &lt; newRightArr.<span class="property">length</span>) &#123;</span><br><span class="line">    newArr.<span class="title function_">push</span>(...newRightArr.<span class="title function_">slice</span>(j));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序前的原数组： [53, 36, 7, 188, 49, 1, 189, 93, 144, 137]</span></span><br><span class="line"><span class="comment">// 排序后的新数组： [1, 7, 36, 49, 53, 93, 137, 144, 188, 189]</span></span><br><span class="line"><span class="comment">// 是否排序后有正确的顺序： true</span></span><br><span class="line"><span class="title function_">testSort</span>(mergeSort);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：使用 mergeSort 算法 排序 100000 个元素 消耗时间为 24.36 毫秒.</span></span><br><span class="line"><span class="title function_">measureSort</span>(mergeSort);</span><br></pre></td></tr></table></figure>

<h4 id="8-5-归并排序的时间复杂度"><a href="#8-5-归并排序的时间复杂度" class="headerlink" title="8.5 归并排序的时间复杂度"></a>8.5 归并排序的时间复杂度</h4><ul>
<li>复杂度的分析过程：<ul>
<li>假设数组长度为 n，需要进行 logn 次归并操作</li>
<li>每次归并操作需要 O(n) 的时间复杂度</li>
<li>因此，归并排序的时间复杂度为 O(nlogn)</li>
</ul>
</li>
<li><code>最好情况： O(log n)</code><ul>
<li>最好情况下，待排序数组已经是有序的，那么每个子数组都只需要合并一次，即只需要进行一次归并操作</li>
<li>因此，此时的时间复杂度是 O(log n)</li>
</ul>
</li>
<li><code>最坏情况： O(nlogn)</code><ul>
<li>最坏情况下，待排序数组是逆序的，那么每个子数组都需要进行多次合并</li>
<li>因此，此时的时间复杂度为 O(nlogn)</li>
</ul>
</li>
<li><code>平均情况： O(nlogn)</code><ul>
<li>在平均情况下，我们假设待排序数组中任意两个元素都是等概率出现的</li>
<li>此时，可以证明归并排序的时间复杂度为 O(nlogn)</li>
</ul>
</li>
</ul>
<h4 id="8-6-归并排序的总结"><a href="#8-6-归并排序的总结" class="headerlink" title="8.6 归并排序的总结"></a>8.6 归并排序的总结</h4><ul>
<li>归并排序是一种非常高效的排序算法，它的核心思想是分治，即将待排序数组分成若干个子数组，分别对这些子数组进行排序，最后将排好序的子数组合并成一个有序数组</li>
<li>归并排序的时间复杂度为 O(nlogn)，并且在最好、最坏和平均情况下都可以达到这个时间复杂度</li>
<li>虽然归并排序看起来比较复杂，但是只要理解了基本思路，实现起来并不困难，而且它是一种非常高效的排序算法</li>
</ul>
<h3 id="9-快速排序"><a href="#9-快速排序" class="headerlink" title="9. 快速排序"></a>9. 快速排序</h3><h4 id="9-1-快速排序的介绍"><a href="#9-1-快速排序的介绍" class="headerlink" title="9.1 快速排序的介绍"></a>9.1 快速排序的介绍</h4><ul>
<li>快速排序（ Quicksort ）是一种经典的排序算法，有时也被称为“划分交换排序”（partition-exchange sort） ，它的发明人是一位名叫 Tony Hoare （东尼·霍尔）的计算机科学家<ul>
<li>Tony Hoare 在1960年代初期发明了<code>快速排序</code>，是在一份<code>ALGOL60 （一种编程语言，作者也是）手稿</code>中</li>
<li>为了<code>让稿件更具可读性</code>，他采用了这种<code>新的排序算法</code></li>
<li>当时，快速排序还没有正式命名，后来被 Tony Hoare 命名为<code> quicksort</code>，也就是快速排序的意思</li>
<li>由于快速排序的思想非常巧妙，因此在计算机科学中得到了广泛的应用</li>
</ul>
</li>
<li>虽然它的名字叫做“快速排序”，但并不意味着它总是最快的排序算法，它的实际运行速度取决于很多因素，如输入数据的分布情况、待排序数组的长度等等</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752915636016.png" alt="75291563601"></p>
<h4 id="9-2-快速排序的定义"><a href="#9-2-快速排序的定义" class="headerlink" title="9.2 快速排序的定义"></a>9.2 快速排序的定义</h4><ul>
<li>快速排序（Quick Sort）是一种基于分治思想的排序算法：<ul>
<li>基本思路是将<code>一个大数组分成两个小数组</code>，然后<code>递归地对两个小数组进行排序</code></li>
<li>具体实现方式是通过<code>选择一个基准元素（pivot）</code>，将<code>数组分成左右两部分，左部分的元素都小于或等于基准元素，右部分的元素都大于基准元素</code></li>
<li>然后，对<code>左右两部分分别进行递归调用快速排序</code>，最终<code>将整个数组排序</code></li>
</ul>
</li>
<li>快速排序是一种原地排序算法，不需要额外的数组空间<ul>
<li>同时，快速排序的时间复杂度是<code> O(nlogn)</code>，在最坏情况下是<code> O(n^2)</code></li>
<li>但是这种情况出现的概率非常小，因此快速排序通常被认为是一种<code>非常高效</code>的排序算法</li>
</ul>
</li>
<li>虽然快速排序看起来比较复杂，但是只要理解了基本思路，实现起来并不困难</li>
</ul>
<h4 id="9-3-快速排序的思路分析"><a href="#9-3-快速排序的思路分析" class="headerlink" title="9.3 快速排序的思路分析"></a>9.3 快速排序的思路分析</h4><ul>
<li>快速排序的思路可以分解成以下几个步骤：<ul>
<li>① 首先，我们需要选择一个基准元素，通常选择第一个或最后一个元素作为基准元素</li>
<li>② 然后，我们定义两个指针 i 和 j，分别指向数组的左右两端</li>
<li>③ 接下来，我们从右侧开始，向左移动 j 指针，直到找到一个小于或等于基准元素的值</li>
<li>④ 然后，我们从左侧开始，向右移动 i 指针，直到找到一个大于或等于基准元素的值</li>
<li>⑤ 如果 i 指针小于或等于 j 指针，交换 i 和 j 指针所指向的元素</li>
<li>⑥ 重复步骤 3-5，直到 i 指针大于 j 指针，这时，我们将基准元素与 j 指针所指向的元素交换位置，将基准元素放到中间位置</li>
<li>⑦ 接着，我们将数组分为两部分，左侧部分包含小于或等于基准元素的元素，右侧部分包含大于基准元素的元素</li>
<li>⑧ 然后，对左右两部分分别进行递归调用快速排序，直到左右两部分只剩下一个元素</li>
<li>⑨ 最终，整个数组就变得有序了。</li>
</ul>
</li>
</ul>
<h4 id="9-4-快速排序的图解"><a href="#9-4-快速排序的图解" class="headerlink" title="9.4 快速排序的图解"></a>9.4 快速排序的图解</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752915467597.png" alt="75291546759"></p>
<h4 id="9-5-快速排序的代码"><a href="#9-5-快速排序的代码" class="headerlink" title="9.5 快速排序的代码"></a>9.5 快速排序的代码</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; measureSort &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; swap, testSort &#125; <span class="keyword">from</span> <span class="string">&quot;./utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">left: <span class="built_in">number</span>, right: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.找到基准元素(pivot轴心)</span></span><br><span class="line">    <span class="keyword">const</span> pivot = arr[right];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.双指针进行交换操作(左边都是pivot小的数字，右边都是pivot大的数字)</span></span><br><span class="line">    <span class="keyword">let</span> i = left;</span><br><span class="line">    <span class="keyword">let</span> j = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">      <span class="comment">// 找到一个比pivot大的元素</span></span><br><span class="line">      <span class="keyword">while</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 找到一个比pivot小的元素</span></span><br><span class="line">      <span class="keyword">while</span> (arr[j] &gt; pivot) &#123;</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 说明我们已经找到了</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="title function_">swap</span>(arr, i, j);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将基准元素和i位置的元素交换位置</span></span><br><span class="line">    <span class="title function_">swap</span>(arr, i, right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归的对左右两个子数组进行快速排序</span></span><br><span class="line">    <span class="title function_">partition</span>(left, j);</span><br><span class="line">    <span class="title function_">partition</span>(i + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">partition</span>(<span class="number">0</span>, arr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序前的原数组： [17, 83, 1, 128, 39, 98, 63, 176, 104, 8]</span></span><br><span class="line"><span class="comment">// 排序后的新数组： [1, 8, 17, 39, 63, 83, 98, 104, 128, 176]</span></span><br><span class="line"><span class="comment">// 是否排序后有正确的顺序： true</span></span><br><span class="line"><span class="title function_">testSort</span>(quickSort);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：使用 quickSort 算法 排序 100000 个元素 消耗时间为 16.57 毫秒.</span></span><br><span class="line"><span class="title function_">measureSort</span>(quickSort);</span><br></pre></td></tr></table></figure>

<h4 id="9-6-快速排序的复杂度分析"><a href="#9-6-快速排序的复杂度分析" class="headerlink" title="9.6 快速排序的复杂度分析"></a>9.6 快速排序的复杂度分析</h4><ul>
<li>快速排序的时间复杂度主要取决于基准元素的选择、数组的划分、递归深度等因素</li>
<li>下面是快速排序的复杂度算法分析过程：</li>
<li><code>最好情况： O(nlogn)</code><ul>
<li>当每次划分后，两部分的大小都相等，即基准元素恰好位于数组的中间位置，此时递归的深度为 O(log n)</li>
<li>每一层需要进行 n 次比较，因此最好情况下的时间复杂度为 O(nlogn)</li>
</ul>
</li>
<li><code>最坏情况： O(n^2)</code><ul>
<li>当每次划分后，其中一部分为空，即基准元素是数组中的最大或最小值，此时递归的深度为 O(n)</li>
<li>每一层需要进行 n 次比较，因此最坏情况下的时间复杂度为 O(n^2)</li>
<li>需要注意的是，采用三数取中法或随机选择基准元素可以有效避免最坏情况的发生</li>
</ul>
</li>
<li><code>平均情况： O(nlogn)</code><ul>
<li>在平均情况下，每次划分后，两部分的大小大致相等，此时递归的深度为 O(log n)</li>
<li>每一层需要进行大约 n 次比较，因此平均情况下的时间复杂度为 O(nlogn)</li>
</ul>
</li>
<li>需要注意的是，快速排序是一个原地排序算法，不需要额外的数组空间</li>
</ul>
<h4 id="9-7-快速排序的总结"><a href="#9-7-快速排序的总结" class="headerlink" title="9.7 快速排序的总结"></a>9.7 快速排序的总结</h4><ul>
<li>快速排序的性能优于许多其他排序算法，因为它具有良好的局部性和使用原地排序的优点<ul>
<li>它在大多数情况下的时间复杂度为 O(n log n)，但在最坏情况下会退化到 O(n^2)</li>
<li>为了避免最坏情况的发生，可以使用一些优化策略，比如随机选择基准元素和三数取中法</li>
</ul>
</li>
<li>总之，快速排序是一种高效的排序算法，它在实践中被广泛使用</li>
</ul>
<h3 id="10-堆排序"><a href="#10-堆排序" class="headerlink" title="10. 堆排序"></a>10. 堆排序</h3><h4 id="10-1-堆排序的定义"><a href="#10-1-堆排序的定义" class="headerlink" title="10.1 堆排序的定义"></a>10.1 堆排序的定义</h4><ul>
<li>堆排序（Heap Sort）是堆排序是一种基于比较的排序算法，它的核心思想是使用<code>二叉堆</code>来维护一个有序序列<ul>
<li>二叉堆是一种完全二叉树，其中<code>每个节点都满足父节点比子节点大（或小）的条件</code></li>
<li>在堆排序中，我们<code>使用最大堆来进行排序</code>，也就是<code>保证每个节点都比它的子节点大</code></li>
</ul>
</li>
<li>在堆排序中，我们首先构建一个最大堆<ul>
<li>然后，我们<code>将堆的根节点（也就是最大值）与堆的最后一个元素交换</code>，这样<code>最大值就被放在了正确的位置</code>上</li>
<li>接着，我们<code>将堆的大小减小一，并将剩余的元素重新构建成一个最大堆</code></li>
<li>我们不断重复这个过程，直到堆的大小为 1</li>
<li>这样，我们就得到了一个有序的序列</li>
</ul>
</li>
<li>堆排序和选择排序有一定的关系，因为它们都利用了“选择”这个基本操作<ul>
<li>选择排序的基本思想是<code>在待排序的序列中选出最小（或最大）的元素</code>，然后将其放置到序列的起始位置</li>
<li>堆排序也是一种选择排序算法，它<code>使用最大堆来维护一个有序序列，然后不断选择出最大的值</code></li>
</ul>
</li>
<li>堆排序的时间复杂度为 O(nlogn)</li>
<li>注意：学习堆排序之前最好先理解堆结构，这样更有利于对堆排序的理解</li>
</ul>
<h4 id="10-2-堆排序的思路分析"><a href="#10-2-堆排序的思路分析" class="headerlink" title="10.2 堆排序的思路分析"></a>10.2 堆排序的思路分析</h4><ul>
<li>堆排序可以分成两大步骤：构建最大堆和排序</li>
<li>构建最大堆：<ul>
<li>① 遍历待排序序列，从最后一个非叶子节点开始，依次对每个节点进行调整</li>
<li>② 假设当前节点的下标为 i，左子节点的下标为 2i+1，右子节点的下标为 2i+2，父节点的下标为 (i-1)&#x2F;2</li>
<li>③ 对于每个节点 i，比较它和左右子节点的值，找出其中最大的值，并将其与节点 i 进行交换</li>
<li>④ 重复进行这个过程，直到节点 i 满足最大堆的性质</li>
<li>⑤ 依次对每个非叶子节点进行上述操作，直到根节点，这样我们就得到了一个最大堆</li>
</ul>
</li>
<li>排序：<ul>
<li>① 将堆的根节点（也就是最大值）与堆的最后一个元素交换，这样最大值就被放在了正确的位置上</li>
<li>② 将堆的大小减小一，并将剩余的元素重新构建成一个最大堆</li>
<li>③ 重复进行步骤 ① 和步骤 ②，直到堆的大小为 1，这样我们就得到了一个有序的序列</li>
</ul>
</li>
</ul>
<h4 id="10-3-堆排序的图解"><a href="#10-3-堆排序的图解" class="headerlink" title="10.3 堆排序的图解"></a>10.3 堆排序的图解</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1752999937111.png" alt="75299993711"></p>
<h4 id="10-4-堆排序的代码实现"><a href="#10-4-堆排序的代码实现" class="headerlink" title="10.4 堆排序的代码实现"></a>10.4 堆排序的代码实现</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; measureSort &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; swap, testSort &#125; <span class="keyword">from</span> <span class="string">&quot;./utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下滤操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 下滤操作的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 从哪一个位置开始下滤操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapifyDown</span>(<span class="params">arr: <span class="built_in">number</span>[], n: <span class="built_in">number</span>, index: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">    <span class="comment">// 1.找到左右子节点索引</span></span><br><span class="line">    <span class="keyword">let</span> leftChildIndex = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> rightChildIndex = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.找到左右子节点索引较大的值</span></span><br><span class="line">    <span class="keyword">let</span> largeIndex = leftChildIndex;</span><br><span class="line">    <span class="comment">// rightChildIndex对应索引有值，并且rightChildIndex对应值大于leftChildIndex对应值</span></span><br><span class="line">    <span class="keyword">if</span> (rightChildIndex &lt; n &amp;&amp; arr[rightChildIndex] &gt; arr[leftChildIndex]) &#123;</span><br><span class="line">      largeIndex = rightChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.较大的值和index索引位置的值进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (arr[index] &gt;= arr[largeIndex]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.交换位置</span></span><br><span class="line">    <span class="title function_">swap</span>(arr, index, largeIndex);</span><br><span class="line">    index = largeIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="comment">// 1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">const</span> n = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.原地建堆：从非叶子节点开始进行下滤操作</span></span><br><span class="line">  <span class="keyword">const</span> start = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">heapifyDown</span>(arr, n, i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.依次取出堆顶元素，并且放到正确的位置上</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 0位置和最后位置交换</span></span><br><span class="line">    <span class="title function_">swap</span>(arr, <span class="number">0</span>, i);</span><br><span class="line">    <span class="title function_">heapifyDown</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序前的原数组： [54, 29, 164, 4, 27, 57, 195, 11, 136, 57]</span></span><br><span class="line"><span class="comment">// 排序后的新数组： [4, 11, 27, 29, 54, 57, 57, 136, 164, 195]</span></span><br><span class="line"><span class="comment">// 是否排序后有正确的顺序： true</span></span><br><span class="line"><span class="title function_">testSort</span>(heapSort);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：使用 heapSort 算法 排序 100000 个元素 消耗时间为 10.96 毫秒.</span></span><br><span class="line"><span class="title function_">measureSort</span>(heapSort);</span><br></pre></td></tr></table></figure>

<h4 id="10-5-堆排序的复杂度分析"><a href="#10-5-堆排序的复杂度分析" class="headerlink" title="10.5 堆排序的复杂度分析"></a>10.5 堆排序的复杂度分析</h4><ul>
<li>堆排序的时间复杂度分析较为复杂，因为它既涉及到堆的建立过程，也涉及到排序过程</li>
<li>下面我们分别对这两个步骤的时间复杂度进行分析</li>
<li>步骤一：堆的建立过程<ul>
<li>堆的建立过程包括<code>n/2 次堆的向下调整操作</code>，因此它的<code>时间复杂度为 O(n)</code></li>
</ul>
</li>
<li>步骤二：排序过程<ul>
<li>排序过程<code>需要执行 n 次堆的删除最大值操作</code>，每次操作都需要<code>将堆的最后一个元素与堆顶元素交换</code>，然后<code>向下调整堆</code></li>
<li>每次<code>向下调整操作的时间复杂度为 O(log n)</code>，因此<code>整个排序过程的时间复杂度为 O(nlog n)</code></li>
</ul>
</li>
<li>综合起来，堆排序的<code>时间复杂度为 O(nlog n)</code></li>
<li>需要注意的是，堆排序的空间复杂度为 O(1)，因为它只使用了常数个辅助变量来存储堆的信息</li>
</ul>
<h4 id="10-6-堆排序的总结"><a href="#10-6-堆排序的总结" class="headerlink" title="10.6 堆排序的总结"></a>10.6 堆排序的总结</h4><ul>
<li>堆排序是一种高效的排序算法，它利用堆这种数据结构来实现排序</li>
<li>堆排序具有时间复杂度为 O(n log n) 的优秀性能，并且由于它只使用了常数个辅助变量来存储堆的信息，因此空间复杂度为 O(1)</li>
<li>但是，由于堆排序的过程是不稳定的，即相同元素的相对位置可能会发生变化，因此在某些情况下可能会导致排序结果不符合要求</li>
<li>总的来说，堆排序是一种高效的、通用的排序算法，它适用于各种类型的数据，并且可以应用于大规模数据的排序</li>
</ul>
<h3 id="11-希尔排序"><a href="#11-希尔排序" class="headerlink" title="11. 希尔排序"></a>11. 希尔排序</h3><h4 id="11-1-希尔排序的介绍"><a href="#11-1-希尔排序的介绍" class="headerlink" title="11.1 希尔排序的介绍"></a>11.1 希尔排序的介绍</h4><ul>
<li>希尔排序（ Shell Sort ）是一种<code>创新的排序算法</code>，它的名字来源于它的发明者Donald Shell（<code>唐纳德·希尔</code>），1959年，希尔排序算法诞生了</li>
<li>在简单排序算法诞生后的很长一段时间内，人们不断尝试发明各种各样的排序算法，但是当时的排序算法的时间复杂度都是O(N²)，看起来很难超越<ul>
<li>当时计算机学术界充满了<code>“排序算法不可能突破O(N²)”</code> 的声音，这与人类100米短跑不可能突破10秒大关的想法一样</li>
<li>这是因为很多著名的排序算法，如冒泡排序、选择排序、插入排序等，<code>它们的时间复杂度都是 O(N²) 级别的</code></li>
<li>因此，人们普遍认为，除非发生突破性的创新，<code>否则排序算法的时间复杂度是不可能达到O(Nlog N) 级别的</code></li>
</ul>
</li>
<li>在这种情况下，希尔排序的提出成为了一种重要的突破<ul>
<li>希尔排序<code>利用了分组和插入排序的思想</code>，通过<code>不断缩小间隔的方式</code>，让数据不断地接近有序状态，从而达到了较高的排序效率</li>
<li>希尔排序的<code>时间复杂度不仅低于 O(N²)</code>，而且<code>可以通过调整步长序列来进一步优化</code>。这一突破性的创新引起了广泛的关注和研究，也为后来的排序算法研究提供了重要的借鉴</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753271700980.png" alt="75327170098"></p>
<h4 id="11-2-插入排序的回顾"><a href="#11-2-插入排序的回顾" class="headerlink" title="11.2 插入排序的回顾"></a>11.2 插入排序的回顾</h4><ul>
<li>回顾插入排序的过程：<ul>
<li>由于希尔排序基于插入排序，所以有必须回顾一下前面的插入排序</li>
<li>我们设想一下，在插入排序执行到一半的时候，标记符左边这部分数据项都是排好序的，而标识符右边的数据项是没有排序的</li>
<li>这个时候，取出指向的那个数据项，把它存储在一个临时变量中，接着，从刚刚移除的位置左边第一个单元开始，每次把有序的数据项向右移动一个单元，直到存储在临时变量中的数据项可以成功插入</li>
</ul>
</li>
<li>插入排序的问题：<ul>
<li>假设一个很小的数据项在很靠近右端的位置上，这里本来应该是较大的数据项的位置</li>
<li>把这个小数据项移动到左边的正确位置，所有的中间数据项都必须向右移动一位</li>
<li>如果每个步骤对数据项都进行N次移动，平均下来是移动N&#x2F;2，N个元素就是 N*N&#x2F;2 &#x3D; N²&#x2F;2</li>
<li>所以我们通常认为插入排序的效率是O(N²)</li>
<li>如果有某种方式，不需要一个个移动所有中间的数据项，就能把较小的数据项移动到左边，那么这个算法的执行效率就会有很大的改进</li>
</ul>
</li>
</ul>
<h4 id="11-3-希尔排序的思路"><a href="#11-3-希尔排序的思路" class="headerlink" title="11.3 希尔排序的思路"></a>11.3 希尔排序的思路</h4><ul>
<li>希尔排序的做法：<ul>
<li>比如下面的数字，81，94，11，96，12，35，17，95，28，58，41，75，15</li>
<li>我们先让间隔为5，进行排序。 (35，81)，(94，17)，(11，95)，(96，28)，(12，58)，(35，41)，(17，75)，(95，15)<ul>
<li>排序后的新序列，一定可以让数字离自己的正确位置更近一步</li>
</ul>
</li>
<li>我们再让间隔位3，进行排序。 (35，28，75，58，95)，(17，12，15，81)，(11，41，96，94)<ul>
<li>排序后的新序列，一定可以让数字离自己的正确位置又近了一步</li>
</ul>
</li>
<li>最后，我们让间隔为1，也就是正确的插入排序。 这个时候数字都离自己的位置更近，那么需要复制的次数一定会减少很多</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753271522840.png" alt="75327152284"></p>
<h4 id="11-4-希尔排序的增量"><a href="#11-4-希尔排序的增量" class="headerlink" title="11.4 希尔排序的增量"></a>11.4 希尔排序的增量</h4><ul>
<li>希尔排序的基本思想是利用<code>分组插入排序</code>的思想，通过<code>不断缩小间隔</code>来让数据逐步趋于有序。步骤思路如下：<ul>
<li>① 定义一个增量序列 d1, d2, …, dk，一般选择增量序列最后一个元素为1，即 dk&#x3D;1</li>
<li>② 以 dk 为间隔将待排序的序列分成 dk 个子序列，对每个子序列进行插入排序</li>
<li>③ 缩小增量，对缩小后的每个子序列进行插入排序，直到增量为1</li>
</ul>
</li>
<li>其中，第一步的增量序列的选择比较重要，增量序列的不同选择会影响到排序效率的好坏。目前比较常用的增量序列有<code>希尔增量</code>、<code>Hibbard增量</code>、<code>Knuth增量</code>等</li>
<li>以希尔增量为例，希尔增量的计算方法为：dk &#x3D; floor(n&#x2F;2^k)，其中，k 为增量序列的元素下标，n 为待排序序列的长度。当 k&#x3D;0 时，dk&#x3D;1</li>
</ul>
<h4 id="11-5-希尔排序的代码实现（希尔增量）"><a href="#11-5-希尔排序的代码实现（希尔增量）" class="headerlink" title="11.5 希尔排序的代码实现（希尔增量）"></a>11.5 希尔排序的代码实现（希尔增量）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; measureSort &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; testSort &#125; <span class="keyword">from</span> <span class="string">&quot;./utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> n = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择不同的增量(步长/间隔)</span></span><br><span class="line">  <span class="keyword">let</span> gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.第一层循环：不断改变步长的过程</span></span><br><span class="line">  <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.第二层循环：找到不同的数列集合进行插入排序的操作</span></span><br><span class="line">    <span class="comment">// 获取到不同的gap，使用gap进行插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> j = i;</span><br><span class="line">      <span class="keyword">const</span> num = arr[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3.第三层循环：while循环，对数列结合进行插入排序的过程</span></span><br><span class="line">      <span class="comment">// while循环，使用num向前去找到一个比num小的值</span></span><br><span class="line">      <span class="keyword">while</span> (j &gt; gap - <span class="number">1</span> &amp;&amp; arr[j - gap] &gt; num) &#123;</span><br><span class="line">        arr[j] = arr[j - gap];</span><br><span class="line">        j -= gap;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(gap / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序前的原数组： [168, 133, 67, 93, 132, 15, 59, 143, 26, 188]</span></span><br><span class="line"><span class="comment">// 排序后的新数组： [15, 26, 59, 67, 93, 132, 133, 143, 168, 188]</span></span><br><span class="line"><span class="comment">// 是否排序后有正确的顺序： true</span></span><br><span class="line"><span class="title function_">testSort</span>(shellSort);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：使用 shellSort 算法 排序 100000 个元素 消耗时间为 18.04 毫秒.</span></span><br><span class="line"><span class="title function_">measureSort</span>(shellSort);</span><br></pre></td></tr></table></figure>

<h4 id="11-6-希尔排序的复杂度"><a href="#11-6-希尔排序的复杂度" class="headerlink" title="11.6 希尔排序的复杂度"></a>11.6 希尔排序的复杂度</h4><ul>
<li><strong>希尔排序的效率</strong><ul>
<li>希尔排序的效率和<code>增量</code>是有关系的</li>
<li>但是，它的效率证明非常困难，甚至某些增量的效率到目前依然没有被证明出来</li>
<li>但是经过统计，希尔排序使用原始增量，最坏的情况下时间复杂度为O(N²)，通常情况下都要好于O(N²)</li>
</ul>
</li>
<li><strong>Hibbard 增量序列</strong><ul>
<li>增量的算法为2^k - 1。 也就是为1 3 5 7。。。等等</li>
<li>这种增量的最坏复杂度为O(N^3&#x2F;2)，猜想的平均复杂度为O(N^5&#x2F;4)，目前尚未被证明</li>
</ul>
</li>
<li><strong>Sedgewick增量序列</strong><ul>
<li>{1，5，19，41，109，… }，该序列中的项或者是9*4^i - 9*2^i + 1或者是4^i - 32^i + 1</li>
<li>这种增量的最坏复杂度为O(N^4&#x2F;3)，平均复杂度为O(N^7&#x2F;6)，但是均未被证明</li>
</ul>
</li>
<li>总之，我们使用希尔排序大多数情况下效率都高于简单排序</li>
</ul>
<h4 id="11-7-希尔排序的代码实现（Hibbard-增量）"><a href="#11-7-希尔排序的代码实现（Hibbard-增量）" class="headerlink" title="11.7 希尔排序的代码实现（Hibbard 增量）"></a>11.7 希尔排序的代码实现（Hibbard 增量）</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753501176163.png" alt="75350117616"> </p>
<h4 id="11-8-希尔排序的总结"><a href="#11-8-希尔排序的总结" class="headerlink" title="11.8 希尔排序的总结"></a>11.8 希尔排序的总结</h4><ul>
<li>希尔排序是一种改进版的插入排序，从历史的角度来看，它是一种非常非常重要的排序算法，因为它解除了人们对原有排序的固有认知</li>
<li>希尔排序的时间复杂度取决于步长序列的选择，目前最优的步长序列还没有被证明，因此希尔排序的时间复杂度依然是一个开放的问题</li>
<li>但是现在已经有很多更加优秀的排序算法：归并排序、快速排序等，所以从实际的应用角度来说，希尔排序已经使用的非常非常少了</li>
<li>因为，我们只需要了解其核心思想即可</li>
</ul>
<h3 id="12-测试多种排序算法"><a href="#12-测试多种排序算法" class="headerlink" title="12. 测试多种排序算法"></a>12. 测试多种排序算法</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; compareSort &#125; <span class="keyword">from</span> <span class="string">&quot;hy-algokit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> bubbleSort <span class="keyword">from</span> <span class="string">&quot;./01.冒泡排序 (BubbleSort)&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> selectionSort <span class="keyword">from</span> <span class="string">&quot;./02.选择排序 (SelectionSort)&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> insertionSort <span class="keyword">from</span> <span class="string">&quot;./03.插入排序 (InsertionSort)&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> mergeSort <span class="keyword">from</span> <span class="string">&quot;./04.归并排序 (MergeSort)&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> quickSort <span class="keyword">from</span> <span class="string">&quot;./05.快速排序 (QuickSort)&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> heapSort <span class="keyword">from</span> <span class="string">&quot;./06.堆排序 (HeapSort)&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> shellSort <span class="keyword">from</span> <span class="string">&quot;./07.希尔排序 (ShellSort)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">compareSort</span>(</span><br><span class="line">  [</span><br><span class="line">    bubbleSort,</span><br><span class="line">    selectionSort,</span><br><span class="line">    insertionSort,</span><br><span class="line">    mergeSort,</span><br><span class="line">    quickSort,</span><br><span class="line">    heapSort,</span><br><span class="line">    shellSort,</span><br><span class="line">  ],</span><br><span class="line">  <span class="number">100000</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753502340763.png" alt="75350234076"></p>
<h2 id="（二）动态规划（Dynamic-programming）"><a href="#（二）动态规划（Dynamic-programming）" class="headerlink" title="（二）动态规划（Dynamic programming）"></a>（二）动态规划（Dynamic programming）</h2><h3 id="1-认识动态规划DP"><a href="#1-认识动态规划DP" class="headerlink" title="1. 认识动态规划DP"></a>1. 认识动态规划DP</h3><h4 id="1-1-认识动态规划"><a href="#1-1-认识动态规划" class="headerlink" title="1.1 认识动态规划"></a>1.1 认识动态规划</h4><ul>
<li>什么是动态规划？维基百科的解释<ul>
<li><code>动态规划（英语：Dynamic programming，简称DP）</code>是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法</li>
</ul>
</li>
<li>动态规划的名字来源于20世纪50年代的一个<code>美国数学家 Richard Bellman</code><ul>
<li>他在处理一类具有重叠子问题和最优子结构性质的问题时，想到了一种“动态”地求解问题的方法</li>
<li>它通过将问题划分为若干个子问题，并在计算子问题的基础上，逐步构建出原问题的解</li>
<li>他使用“动态规划”这个术语来描述这种方法，并将它应用于各种领域，如控制论、经济学、运筹学等</li>
</ul>
</li>
<li>动态规划（Dynamic Programming，可以简称DP）是一个非常重要的算法思想：<ul>
<li>在<code>算法竞赛、数据结构、机器学习</code>等领域中，动态规划都是必不可少的知识之一</li>
</ul>
</li>
<li>动态规划也是互联网大厂和算法竞赛中非常喜欢考察的一类题目：<ul>
<li>因为通过动态规划可以很好的看出一个人的思考问题的能力、逻辑的强度、程序和算法的设计等等</li>
<li>那么通过学习动态规划，可以<code>提高算法设计和分析的能力</code>，为解决复杂问题提供强有力的工具和思路</li>
</ul>
</li>
</ul>
<h4 id="1-2-动态规划的解题思路"><a href="#1-2-动态规划的解题思路" class="headerlink" title="1.2 动态规划的解题思路"></a>1.2 动态规划的解题思路</h4><ul>
<li>高深莫测、晦涩难懂？<ul>
<li>很多人第一次接触动态规划时，往往会觉得这类题目高深莫测、晦涩难懂，不知道从何下手，甚至压根读不懂题意</li>
<li>往往会因为还没有完全入门就产生了困惑、迷茫，甚至是恐惧，最后直接放弃</li>
<li>我认为完全没有必要，只要掌握了动态规划的基本思路和实现方法，就可以很好地应用它解决各种问题</li>
</ul>
</li>
<li>动态规划的核心思想是<code>“将问题划分为若干个子问题，并在计算子问题的基础上，逐步构建出原问题的解”</code></li>
<li>具体地说，动态规划通常涉及以下四个步骤：<ul>
<li>步骤一：<code>定义状态</code><ul>
<li>将原问题划分为若干个子问题，定义状态表示子问题的解，通常使用一个数组或者矩阵来表示</li>
</ul>
</li>
<li>步骤二：<code>确定状态转移方程</code><ul>
<li>在计算子问题的基础上，逐步构建出原问题的解</li>
<li>这个过程通常使用“状态转移方程”来描述，表示从一个状态转移到另一个状态时的转移规则</li>
</ul>
</li>
<li>步骤三：<code>初始化状态</code></li>
<li>步骤四：<code>计算原问题的解（最终答案）</code><ul>
<li>通过计算状态之间的转移，最终计算出原问题的解</li>
<li>通常使用递归或者迭代（循环）的方式计算</li>
</ul>
</li>
</ul>
</li>
<li>这四个步骤是动态规划的核心思想，其中状态定义和状态转移方程是动态规划的关键</li>
</ul>
<h4 id="1-3-如何开始动态规划呢？"><a href="#1-3-如何开始动态规划呢？" class="headerlink" title="1.3 如何开始动态规划呢？"></a>1.3 如何开始动态规划呢？</h4><ul>
<li>我们可以从一个最简单的算法：斐波那契数列开始。</li>
<li>斐波那契数列是一个经典的数列，在自然界中很多地方都可以找到，它的定义如下：<ul>
<li>第 0 个和第 1 个斐波那契数分别为0和1，即 F0 &#x3D; 0, F1 &#x3D; 1</li>
<li>从第 2 个数开始，每个斐波那契数都是它前面两个斐波那契数之和，即F2 &#x3D; F0 + F1，F3 &#x3D; F1 + F2，F4 &#x3D; F2 + F3，以此类推</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753514055508.png" alt="75351405550"></p>
<ul>
<li>那么我们来看一下，如果我们要求斐波那契数列第N个数的值</li>
<li>那么我们有多少种求解的办法呢？<ul>
<li>方式一：<code>递归算法</code></li>
<li>方式二：<code>记忆化搜索</code></li>
<li>方式三：<code>动态规划的方案</code></li>
<li>方式四：<code>动态规划 – 状态压缩</code></li>
</ul>
</li>
</ul>
<h3 id="2-斐波那契数列求解"><a href="#2-斐波那契数列求解" class="headerlink" title="2. 斐波那契数列求解"></a>2. 斐波那契数列求解</h3><h4 id="2-1-斐波那契数列-–-递归求解"><a href="#2-1-斐波那契数列-–-递归求解" class="headerlink" title="2.1 斐波那契数列 – 递归求解"></a>2.1 斐波那契数列 – 递归求解</h4><ul>
<li>递归算法是一种基本的算法思想：<ul>
<li>其基本思想是将一个大问题拆分成若干个相似的小问题</li>
<li>然后通过解决这些小问题来解决整个大问题</li>
</ul>
</li>
<li>递归算法通常采用函数自身调用的方式实现，每次调用函数时都会处理一个规模更小的问题，直到问题规模足够小，可以直接求解为止</li>
<li>当 n 小于等于 1 时，直接返回 n；否则，递归调用 fibonacci 函数来计算 n-1 和 n-2 两个子问题的结果，然后将它们相加得到结果</li>
<li>递归函数必须有一个终止条件，以确保递归过程能够结束</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">10</span>)); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-斐波那契数列-–-记忆化搜索"><a href="#2-2-斐波那契数列-–-记忆化搜索" class="headerlink" title="2.2 斐波那契数列 – 记忆化搜索"></a>2.2 斐波那契数列 – 记忆化搜索</h4><ul>
<li>对于递归算法，很容易出现重复计算的问题，因为在计算同一个子问题时，可能会被重复地计算多次</li>
<li>为了避免这个问题，我们可以使用记忆化搜索（Memoization）的技巧，将已经计算过的结果保存下来，以便在后续的计算中直接使用</li>
<li>下面是一个使用记忆化搜索优化的斐波那契数列实现，它可以避免重复计算，提高计算效率</li>
<li>这个实现和前面的递归实现非常相似，只是增加了一个 memo 参数，用于保存已经计算过的结果<ul>
<li>在实际应用中，记忆化搜索可以极大地提高递归算法的效率，特别是对于有大量重复计算的问题，优化效果尤为明显</li>
<li>这种解法也可以称之为<code>自顶向下</code>的解法</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n: <span class="built_in">number</span>, memo: <span class="built_in">number</span>[] = []</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="comment">// 求n的值，直接拿到值返回即可</span></span><br><span class="line">  <span class="keyword">if</span> (memo[n]) <span class="keyword">return</span> memo[n];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有从memo中取到值</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">fibonacci</span>(n - <span class="number">1</span>, memo) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>, memo);</span><br><span class="line">  <span class="comment">// 将n位置的结果存取到memo中</span></span><br><span class="line">  memo[n] = result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">10</span>)); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-斐波那契数列-–-动态规划"><a href="#2-3-斐波那契数列-–-动态规划" class="headerlink" title="2.3 斐波那契数列 – 动态规划"></a>2.3 斐波那契数列 – 动态规划</h4><ul>
<li>从上面的斐波那契数列的例子中，我们可以发现，通过记忆化搜索的方式，可以避免重复计算，提高计算效率</li>
<li>而动态规划（Dynamic Programming）算法就是一种利用历史状态信息来避免重复计算的算法<ul>
<li>动态规划算法可以看作是<code>记忆化搜索</code>的一种扩展，它通常采用<code>自底向上的方式计算子问题的结果</code>，并<code>将结果保存下来以便后续的计算使用</code></li>
<li>在动态规划算法中，通常需要明确<code>定义状态、设计状态转移方程、初始化状态，以及确定计算顺序</code>等</li>
</ul>
</li>
<li>下面我们可以以斐波那契数列为例，介绍如何用动态规划算法来解决这个问题<ul>
<li>需要注意的是，在动态规划算法中，为了<code>保证状态之间的依赖关系正确，通常需要按照一定的计算顺序来计算子问题的结果</code></li>
<li>对于斐波那契数列问题来说，我们<code>采用自底向上的方式计算子问题的结果</code>，<code>确保 dp[i-1] 和 dp[i-2] 的值</code>已经计算出来了，才能<code>计算 dp[i] 的值</code></li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="comment">// 1.定义状态</span></span><br><span class="line">  <span class="comment">// dp保留斐波那契数列中每一个位置对应的值(状态)</span></span><br><span class="line">  <span class="comment">// dp[x]：表示的就是x位置对应的值(状态)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.状态转移方程：dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">  <span class="comment">// 状态转移方程，一般情况下都是写在循环(for/while)中的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.设置初始化状态：dp = [0, 1]</span></span><br><span class="line">  <span class="comment">// 4.计算最终的结果</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dp</span>: <span class="built_in">number</span>[] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">// 自底向上的方式计算子问题的结果，将结果保存下来以便后续的计算使用</span></span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">10</span>)); <span class="comment">// 55</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">50</span>)); <span class="comment">// 12586269025</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-斐波那契数列-–-动态规划（状态压缩）"><a href="#2-4-斐波那契数列-–-动态规划（状态压缩）" class="headerlink" title="2.4 斐波那契数列 – 动态规划（状态压缩）"></a>2.4 斐波那契数列 – 动态规划（状态压缩）</h4><ul>
<li>在动态规划算法中，有一种常见的优化方法叫做状态压缩，可以<code>将状态的存储空间从数组优化为一个常数</code></li>
<li>对于斐波那契数列问题来说，我们只需要保存 dp[i-1] 和 dp[i-2] 两个状态的值，就能够计算出 dp[i] 的值，因此可以使用<code>两个变量</code>来存储这两个状态的值，从而<code>实现状态压缩的优化</code></li>
<li>以下是使用状态压缩优化后的代码：这个实现和前面的动态规划实现相比，<code>减少了存储空间的使用</code>，<code>优化了空间复杂度</code></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.定义状态</span></span><br><span class="line">  <span class="comment">// 2.初始化状态</span></span><br><span class="line">  <span class="keyword">let</span> prev = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> curr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">// 3.状态转移方程</span></span><br><span class="line">    <span class="keyword">const</span> next = prev + curr;</span><br><span class="line">    prev = curr;</span><br><span class="line">    curr = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.计算最终的结果</span></span><br><span class="line">  <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">10</span>)); <span class="comment">// 55</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">50</span>)); <span class="comment">// 12586269025</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-动态规划的统一解题步骤"><a href="#2-5-动态规划的统一解题步骤" class="headerlink" title="2.5 动态规划的统一解题步骤"></a>2.5 动态规划的统一解题步骤</h4><ul>
<li>当遇到需要使用动态规划来解决的问题时，可以按照以下步骤进行解题</li>
<li><strong>步骤一：定义状态：</strong><ul>
<li>明确状态的含义，通常需要使用一个或多个变量来表示状态</li>
<li>状态表示问题的解空间中的某个状态</li>
</ul>
</li>
<li><strong>步骤二：找到状态转移方程：</strong><ul>
<li>根据题目的要求和状态的定义，写出状态转移方程</li>
<li>状态转移方程表示的是从当前状态到下一个状态的转移规律，是动态规划算法的核心</li>
</ul>
</li>
<li><strong>步骤三：确定初始状态：</strong><ul>
<li>确定状态转移过程中的初始状态，也就是问题的边界</li>
<li>初始状态是转移方程的基础，也是状态转移的起点</li>
</ul>
</li>
<li><strong>步骤四：计算最终状态：</strong><ul>
<li>根据状态转移方程和初始状态，计算出最终状态的值</li>
<li>最终状态是问题的解，也是状态转移的终点</li>
</ul>
</li>
</ul>
<h3 id="3-跳台阶的问题求解"><a href="#3-跳台阶的问题求解" class="headerlink" title="3. 跳台阶的问题求解"></a>3. 跳台阶的问题求解</h3><h4 id="3-1-爬楼梯（跳台阶）"><a href="#3-1-爬楼梯（跳台阶）" class="headerlink" title="3.1 爬楼梯（跳台阶）"></a>3.1 爬楼梯（跳台阶）</h4><ul>
<li>爬楼梯（或者称之为跳台阶，我个人一直叫跳台阶）是一道经典的动态规划题目，也是面试常考的一道题目</li>
<li><code>爬楼梯</code>：假设你正在爬楼梯。需要 n 阶你才能到达楼顶<ul>
<li>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</li>
</ul>
</li>
<li><code>跳台阶</code>：假设有 n 级台阶，每次可以跳 1 级或 2 级台阶，问有多少种不同的跳法可以跳到第 n 级台阶</li>
<li>题目解析：<ul>
<li>跳台阶问题是一道<code>经典的动态规划问题</code>，其本质是要求出到达第 n 级台阶的跳法数量</li>
<li>而到达第 n 级台阶只能由第 n-1 级台阶或第 n-2 级台阶跳上来，因此需要借助动态规划算法进行求解</li>
<li>通过引入状态、设计状态转移方程、初始化状态等方法，可以高效地求解跳台阶问题</li>
</ul>
</li>
<li>这道题目我们依然采用不同的方案来实现，让大家体会到动态规划的好处：<ul>
<li>方式一：<code>暴力递归</code></li>
<li>方式二：<code>记忆化搜索</code></li>
<li>方式三：<code>动态规划</code></li>
<li>方式四：<code>状态压缩</code></li>
</ul>
</li>
</ul>
<h4 id="3-2-跳台阶-–-暴力递归"><a href="#3-2-跳台阶-–-暴力递归" class="headerlink" title="3.2 跳台阶 – 暴力递归"></a>3.2 跳台阶 – 暴力递归</h4><ul>
<li>我们可以先从暴力递归的方式开始，分析问题的本质，然后再逐步引入动态规划算法进行优化</li>
<li>对于跳台阶问题，假设有 n 级台阶，我们要求出到达第 n 级台阶的不同跳法数量<ul>
<li>可以发现，从第 n 级台阶只能由第 n-1 级台阶或第 n-2 级台阶跳上来</li>
<li>因此，到达第 n 级台阶的跳法数量等于到达第 n-1 级台阶的跳法数量加上到达第 n-2 级台阶的跳法数量</li>
<li>即：jump(n) &#x3D; jump(n-1) + jump(n-2)</li>
<li>对于 n&#x3D;0 和 n&#x3D;1 的情况，跳法数量分别为 1 和 1</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jump</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">jump</span>(n - <span class="number">1</span>) + <span class="title function_">jump</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">jump</span>(<span class="number">20</span>)); <span class="comment">// 10946</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-跳台阶-–-记忆化搜索"><a href="#3-3-跳台阶-–-记忆化搜索" class="headerlink" title="3.3 跳台阶 – 记忆化搜索"></a>3.3 跳台阶 – 记忆化搜索</h4><ul>
<li>在介绍完暴力递归之后，我们可以引入记忆化搜索（Memoization）的方式进行优化<ul>
<li>对于跳台阶问题，我们可以使用一个长度为 n+1 的数组 memo，用来记录每个阶梯的跳法数量</li>
<li>初始时，我们将 memo 数组中所有元素都初始化为 0</li>
<li>然后在递归过程中，如果 memo[n] 已经被计算过，直接返回 memo[n]</li>
<li>否则计算 memo[n] 的值，并将其存储到 memo[n] 中</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jumpMemo</span>(<span class="params">n: <span class="built_in">number</span>, memo: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (memo[n] !== <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line"></span><br><span class="line">  memo[n] = <span class="title function_">jumpMemo</span>(n - <span class="number">1</span>, memo) + <span class="title function_">jumpMemo</span>(n - <span class="number">2</span>, memo);</span><br><span class="line">  <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jump</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> memo = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">jumpMemo</span>(n, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">jump</span>(<span class="number">20</span>)); <span class="comment">// 10946</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-跳台阶-–-动态规划"><a href="#3-4-跳台阶-–-动态规划" class="headerlink" title="3.4 跳台阶 – 动态规划"></a>3.4 跳台阶 – 动态规划</h4><ul>
<li>我们可以使用一个一维数组来记录跳台阶的结果</li>
<li>我们可以定义一个长度为 n+1 的一维数组 dp，用来记录每个阶梯的跳法数量<ul>
<li>初始时，我们将 dp 数组中所有元素都初始化为 0</li>
<li>然后设置 dp[0] &#x3D; 1，dp[1] &#x3D; 1，表示到达第 0 级台阶和第 1 级台阶时，只有 1 种跳法</li>
<li>接下来，我们可以使用循环，依次计算 dp[2]、dp[3]、…、dp[n] 的值，最终得到 dp[n] 即为答案</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jump</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="comment">// 1.定义状态</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dp</span>: <span class="built_in">number</span>[] = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.设置初始化状态</span></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.状态转移方程：dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.计算最终的结果</span></span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">jump</span>(<span class="number">20</span>)); <span class="comment">// 10946</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-跳台阶-–-滚动数组（滑动窗口）"><a href="#3-5-跳台阶-–-滚动数组（滑动窗口）" class="headerlink" title="3.5 跳台阶 – 滚动数组（滑动窗口）"></a>3.5 跳台阶 – 滚动数组（滑动窗口）</h4><ul>
<li>另外一种常见的优化方法是滚动数组（滑动窗口）的方式</li>
<li>滚动数组的基本思想是：<ul>
<li>由于每个状态只与它之前的状态有关</li>
<li>因此我们不需要记录所有的状态，只需要记录当前状态和它之前的若干个状态即可</li>
<li>通过不断更新这个滚动窗口，可以避免使用额外的空间，将空间复杂度进一步降低</li>
</ul>
</li>
<li>使用滚动数组的方式，可以将算法的空间复杂度降到 O(1)，是一种非常高效的动态规划优化方式</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jump</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="comment">// 1.定义状态</span></span><br><span class="line">  <span class="comment">// 2.初始化状态</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">// 3.状态转移方程</span></span><br><span class="line">    <span class="keyword">const</span> c = a + b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.计算最终的结果</span></span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">jump</span>(<span class="number">20</span>)); <span class="comment">// 10946</span></span><br></pre></td></tr></table></figure>

<h3 id="4-股票买卖的最大值"><a href="#4-股票买卖的最大值" class="headerlink" title="4. 股票买卖的最大值"></a>4. 股票买卖的最大值</h3><h4 id="4-1-买卖股票的最佳时机"><a href="#4-1-买卖股票的最佳时机" class="headerlink" title="4.1 买卖股票的最佳时机"></a>4.1 买卖股票的最佳时机</h4><ul>
<li>买卖股票的最佳时机：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></li>
<li>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格</li>
<li>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润</li>
<li>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753523956496.png" alt="75352395649"></p>
<h4 id="4-2-动态规划的实现思路"><a href="#4-2-动态规划的实现思路" class="headerlink" title="4.2 动态规划的实现思路"></a>4.2 动态规划的实现思路</h4><ul>
<li>定义状态：设 dp[i] 表示前 i 天中能够获取的最大利润</li>
<li>状态转移方程：<ul>
<li>对于第 i 天，有两种情况：<ul>
<li>在第 i 天卖出股票，在第i天的价格减去之前最便宜那天的买入价格，因此可以得到利润为prices[i] - minPrice</li>
<li>在第 i 天不卖出股票，那么目前的最大利润依然是前一天的最大利润 dp[i-1]</li>
</ul>
</li>
<li>可以得到状态转移方程为：dp[i] &#x3D; max(dp[i-1]，prices[i] - minPrice)</li>
</ul>
</li>
<li>初始状态：由于最小的天数是 1，因此初始状态为dp[0] &#x3D; 0</li>
<li>计算最终状态：最后一天保留下来的最大利润的值</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = prices.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.定义状态</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dp</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.设置始化值</span></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.状态转移方程求dp[i]</span></span><br><span class="line">  <span class="keyword">let</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i] = prices[i] - minPrice;</span><br><span class="line">    minPrice = <span class="title class_">Math</span>.<span class="title function_">min</span>(prices[i], minPrice);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.返回结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(...dp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxProfit</span>(arr)); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：优化一下-----------------------------------------------------------</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = prices.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.定义状态</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dp</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.设置始化值</span></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.状态转移方程求dp[i]</span></span><br><span class="line">  <span class="keyword">let</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>], prices[i] - minPrice);</span><br><span class="line">    minPrice = <span class="title class_">Math</span>.<span class="title function_">min</span>(prices[i], minPrice);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.返回结果</span></span><br><span class="line">  <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxProfit</span>(arr)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-动态规划-状态压缩"><a href="#4-3-动态规划-状态压缩" class="headerlink" title="4.3 动态规划 - 状态压缩"></a>4.3 动态规划 - 状态压缩</h4><ul>
<li>对于这个问题，实际上可以进行状态压缩</li>
<li>由于在状态转移方程中，当前状态只与前一个状态有关，因此可以不用维护整个 dp 数组，只需要用一个变量来表示前一个状态的最大利润即可</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = prices.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.定义状态</span></span><br><span class="line">  <span class="comment">// 2.设置始化值</span></span><br><span class="line">  <span class="keyword">let</span> preValue = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.状态转移方程求dp[i]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    preValue = <span class="title class_">Math</span>.<span class="title function_">max</span>(preValue, prices[i] - minPrice);</span><br><span class="line">    minPrice = <span class="title class_">Math</span>.<span class="title function_">min</span>(prices[i], minPrice);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.返回结果</span></span><br><span class="line">  <span class="keyword">return</span> preValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxProfit</span>(arr)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="5-求最大子数组的和"><a href="#5-求最大子数组的和" class="headerlink" title="5. 求最大子数组的和"></a>5. 求最大子数组的和</h3><h4 id="5-1-最大子数组和"><a href="#5-1-最大子数组和" class="headerlink" title="5.1 最大子数组和"></a>5.1 最大子数组和</h4><ul>
<li>最大子数组和：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></li>
<li>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组 (子数组最少包含一个元素)，返回其最大和</li>
<li>子数组 是数组中的一个连续部分</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753532954561.png" alt="75353295456"></p>
<h4 id="5-2-动态规划的实现思路"><a href="#5-2-动态规划的实现思路" class="headerlink" title="5.2 动态规划的实现思路"></a>5.2 动态规划的实现思路</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753532970592.png" alt="75353297059"></p>
<ul>
<li>动态规划的规律：<ul>
<li>以每个位置结尾的最大子序列的计算方式：<ul>
<li>如果前面的子序列是负数，那么最大子序列和一定是自己</li>
<li>如果前面的子序列是正数，那么最大子序列和是自己+前值</li>
</ul>
</li>
<li>由此可以得出计算公式：dp[i] &#x3D; max(dp[i-1] + nums[i]，nums[i])</li>
<li>初始化值：dp[0] &#x3D; nums[0]</li>
<li>计算最终值：找出所有值中最大的值即可</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxSubArray</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 1.定义状态</span></span><br><span class="line">  <span class="comment">// 2.设置初始化状态</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dp</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.状态转移方程</span></span><br><span class="line">  <span class="keyword">let</span> max = dp[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> value1 = nums[i];</span><br><span class="line">    <span class="keyword">const</span> value2 = dp[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">    dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(value1, value2);</span><br><span class="line"></span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.计算最终的结果</span></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxSubArray</span>(arr)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h4 id="5-3-状态压缩的优化"><a href="#5-3-状态压缩的优化" class="headerlink" title="5.3 状态压缩的优化"></a>5.3 状态压缩的优化</h4><ul>
<li>在动态规划算法中，我们需要定义一个一维数组 dp，其中dp[i] 表示以第 i 个元素结尾的子数组的最大和<ul>
<li>根据动态转移方程 dp[i] &#x3D; max(dp[i-1] + nums[i], nums[i])，我们可以计算出 dp 数组中的每个元素，从而求解原问题</li>
<li>这个算法的空间复杂度为 O(n)</li>
</ul>
</li>
<li>然而，我们可以发现，dp 数组中的每个元素只与前一个元素有关</li>
<li>因此，我们可以使用滚动数组的技巧，将一维数组 dp 压缩成一个变量 maxSum，从而将空间复杂度优化为 O(1)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxSubArray</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 1.定义状态</span></span><br><span class="line">  <span class="comment">// 2.设置初始化状态</span></span><br><span class="line">  <span class="keyword">let</span> preSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.状态转移方程</span></span><br><span class="line">  <span class="keyword">let</span> max = preSum;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> value1 = nums[i];</span><br><span class="line">    <span class="keyword">const</span> value2 = preSum + nums[i];</span><br><span class="line">    preSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(value1, value2);</span><br><span class="line"></span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, preSum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.计算最终的结果</span></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxSubArray</span>(arr)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h3 id="6-不同的路径的数量"><a href="#6-不同的路径的数量" class="headerlink" title="6. 不同的路径的数量"></a>6. 不同的路径的数量</h3><h4 id="6-1-不同路径"><a href="#6-1-不同路径" class="headerlink" title="6.1 不同路径"></a>6.1 不同路径</h4><ul>
<li>不同路径：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/description/">https://leetcode.cn/problems/unique-paths/description/</a></li>
<li>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start”，m表示行，n表示列）</li>
<li>机器人每次只能<code>向下</code>或者<code>向右</code>移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）</li>
<li>问总共有多少条不同的路径？</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753535837318.png" alt="75353583731"></p>
<h4 id="6-2-动态规划的实现思路"><a href="#6-2-动态规划的实现思路" class="headerlink" title="6.2 动态规划的实现思路"></a>6.2 动态规划的实现思路</h4><ul>
<li>这个题目和跳楼梯其实是一类题目</li>
<li>设 dp[i][j] 表示从起点到网格的 (i, j) 点的不同路径数</li>
<li>对于每个格子，由于机器人只能从上面或左边到达该格子，因此有以下两种情况：<ul>
<li>从上面的格子到达该格子，即 dp[i][j] &#x3D; dp[i-1][j]</li>
<li>从左边的格子到达该格子，即 dp[i][j] &#x3D; dp[i][j-1]<ul>
<li>因此，到达网格的 (i, j) 点的不同路径数就等于到达上面格子的路径数加上到达左边格子的路径数</li>
</ul>
</li>
<li>动态转移方程为：dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]</li>
</ul>
</li>
<li>初始状态：对于边界情况，起点的路径数为 1，即 dp[0][0] &#x3D; 1</li>
<li>计算最终状态：dp[m-1][n-1]</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753536070327.png" alt="75353607032"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uniquePaths</span>(<span class="params">m: <span class="built_in">number</span>, n: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="comment">// 1.定义状态</span></span><br><span class="line">  <span class="keyword">let</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: m &#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.初始化状态</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.状态转移方程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.计算最终的结果</span></span><br><span class="line">  <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">uniquePaths</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// 28</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">uniquePaths</span>(<span class="number">3</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-不同路径的组合数学（课下扩展）"><a href="#6-3-不同路径的组合数学（课下扩展）" class="headerlink" title="6.3 不同路径的组合数学（课下扩展）"></a>6.3 不同路径的组合数学（课下扩展）</h4><ul>
<li>我们可以使用组合数学的方法，通过计算总共需要向下和向右走的步数，从而计算不同的路径数目</li>
<li>假设总共需要向下走 n 步，向右走 m 步，则路径的总长度为 n + m，其中需要选择 n 个位置向下走，因此路径的总数目为 C(n + m, n)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uniquePaths</span>(<span class="params">m: <span class="built_in">number</span>, n: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="comment">// 总共需要走的步数</span></span><br><span class="line">  <span class="keyword">const</span> total = m + n - <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 向下走的步数</span></span><br><span class="line">  <span class="keyword">const</span> down = n - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 不同路径的数目</span></span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 使用组合数学的方法计算不同路径数目</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= down; i++) &#123;</span><br><span class="line">    ans *= total - down + i; <span class="comment">// C(total-down+i, i)的分子</span></span><br><span class="line">    ans /= i; <span class="comment">// C(total-down+i, i)的分母</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回计算结果</span></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">uniquePaths</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// 28</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">uniquePaths</span>(<span class="number">3</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="7-礼物的最大价值"><a href="#7-礼物的最大价值" class="headerlink" title="7. 礼物的最大价值"></a>7. 礼物的最大价值</h3><ul>
<li>礼物的最大价值：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/description/">https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/description/</a></li>
<li>题目：<ul>
<li>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次<code>向右</code>或者<code>向下</code>移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753968342803.png" alt="75396834280"></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753968401991.png" alt="75396840199"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jewelleryValue</span>(<span class="params">frame: <span class="built_in">number</span>[][]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> m = frame.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> n = frame[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.定义状态</span></span><br><span class="line">  <span class="keyword">let</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: m &#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.初始化状态</span></span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = frame[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + frame[i][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + frame[<span class="number">0</span>][j];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.状态转移方程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + frame[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.计算最终的结果</span></span><br><span class="line">  <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> frame = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">jewelleryValue</span>(frame)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<h3 id="8-最长递增子序列"><a href="#8-最长递增子序列" class="headerlink" title="8. 最长递增子序列"></a>8. 最长递增子序列</h3><h4 id="8-1-最长递增子序列"><a href="#8-1-最长递增子序列" class="headerlink" title="8.1 最长递增子序列"></a>8.1 最长递增子序列</h4><ul>
<li>最长递增子序列（Longest Increasing Subsequence，简称LIS）<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">https://leetcode.cn/problems/longest-increasing-subsequence/description/</a></li>
</ul>
</li>
<li>题目：<ul>
<li>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度</li>
<li><code>子序列</code>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3, 6, 2, 7] 是数组 [0, 3, 1, 6, 2, 2, 7] 的子序列</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753969471027.png" alt="75396947102"></p>
<h4 id="8-2-最长递增子序列-–-动态规划"><a href="#8-2-最长递增子序列-–-动态规划" class="headerlink" title="8.2 最长递增子序列 – 动态规划"></a>8.2 最长递增子序列 – 动态规划</h4><ul>
<li>这道题目可以使用动态规划来解决</li>
<li>定义状态：设dp[i]表示以第i个元素结尾的最长上升子序列的长度</li>
<li>状态转移方程：<ul>
<li>对于每个i，我们需要找到在[0, i-1]范围内比nums[i]小的元素，以这些元素结尾的最长上升子序列中最长的那个子序列的长度</li>
<li>然后将其加1即可得到以nums[i]结尾的最长上升子序列的长度</li>
<li>状态转移方程为：dp[i] &#x3D; max(dp[j]) + 1，其中j &lt; i且nums[j] &lt; nums[i]</li>
</ul>
</li>
<li>初始状态：对于每个i，dp[i]的初始值为1，因为每个元素本身也可以作为一个长度为1的上升子序列</li>
<li>最终计算结果：最长上升子序列的长度即为dp数组中的最大值</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753969637893.png" alt="75396963789"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLIS</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.定义状态dp</span></span><br><span class="line">  <span class="comment">// 2.初始化值</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dp</span>: <span class="built_in">number</span>[] = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> max = dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.状态转移方程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 需要和前面所有的元素进行一次比较(找到比我小的元素)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="comment">// 找到比i位置小的数字</span></span><br><span class="line">      <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">        dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums1 = [<span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">101</span>, <span class="number">18</span>];</span><br><span class="line"><span class="keyword">const</span> nums2 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> nums3 = [<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLIS</span>(nums1)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLIS</span>(nums2)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLIS</span>(nums3)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="8-3-贪心-二分查找的思考过程"><a href="#8-3-贪心-二分查找的思考过程" class="headerlink" title="8.3 贪心 + 二分查找的思考过程"></a>8.3 贪心 + 二分查找的思考过程</h4><p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753969677019.png" alt="75396967701"></p>
<ul>
<li>维护一个数组tails，用于记录扫描到的元素应该存放的位置</li>
<li>扫描原数组中的每个元素num，在tails数组中找是否有比自己更大的值<ul>
<li>如果有，那么找到对应位置，并且让num作为该位置的最小值</li>
<li>如果没有，那么直接放到tails数组的尾部</li>
</ul>
</li>
<li>tails数组的长度，就是最长递增子序列的长度</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLIS</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 记录每个组中的最小值</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">tails</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历每一个元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> num = nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = tails.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (num &lt;= tails[mid]) &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否找到对应的位置</span></span><br><span class="line">    <span class="keyword">if</span> (left === tails.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 没有找到能存放的位置</span></span><br><span class="line">      tails.<span class="title function_">push</span>(num);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tails[left] = num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tails.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums1 = [<span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">101</span>, <span class="number">18</span>];</span><br><span class="line"><span class="keyword">const</span> nums2 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> nums3 = [<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLIS</span>(nums1)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLIS</span>(nums2)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLIS</span>(nums3)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>为什么这么神奇刚好是数组的长度呢？（了解）</strong><ul>
<li>情况一：如果是逆序的时候，一定会一直在一个上面加加加</li>
<li>情况二：一旦出现了比前面的最小值的值大的，那么就一定会增加一个新的数列，说明在上升的过程</li>
<li>情况三：如果之后出现一个比前面数列小的，那么就需要重新计算序列</li>
</ul>
</li>
</ul>
<h2 id="（三）大厂面试题（Leetcode）"><a href="#（三）大厂面试题（Leetcode）" class="headerlink" title="（三）大厂面试题（Leetcode）"></a>（三）大厂面试题（Leetcode）</h2><h3 id="1-字符串大厂面试题"><a href="#1-字符串大厂面试题" class="headerlink" title="1. 字符串大厂面试题"></a>1. 字符串大厂面试题</h3><h4 id="1-1-最长公共前缀"><a href="#1-1-最长公共前缀" class="headerlink" title="1.1 最长公共前缀"></a>1.1 最长公共前缀</h4><ul>
<li>最长公共前缀（Longest Common Prefix）：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/">https://leetcode.cn/problems/longest-common-prefix/</a></li>
<li>题目：<ul>
<li>编写一个函数来查找字符串数组中的最长公共前缀</li>
<li>如果不存在公共前缀，返回空字符串 “”</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753546793240.png" alt="75354679324"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">strs: <span class="built_in">string</span>[]</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!strs.<span class="property">length</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先用数组第一项作为公共前缀</span></span><br><span class="line">  <span class="keyword">let</span> prefix = strs[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; strs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (strs[i].<span class="title function_">indexOf</span>(prefix) !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 每次长度减1</span></span><br><span class="line">      prefix = prefix.<span class="title function_">slice</span>(<span class="number">0</span>, prefix.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prefix.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strs1 = [<span class="string">&quot;flower&quot;</span>, <span class="string">&quot;flow&quot;</span>, <span class="string">&quot;flight&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> strs2 = [<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;racecar&quot;</span>, <span class="string">&quot;car&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">longestCommonPrefix</span>(strs1)); <span class="comment">// &quot;fl&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">longestCommonPrefix</span>(strs2)); <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-无重复字符的最长子串"><a href="#1-2-无重复字符的最长子串" class="headerlink" title="1.2 无重复字符的最长子串"></a>1.2 无重复字符的最长子串</h4><ul>
<li>无重复字符的最长子串：<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/</a></li>
</ul>
</li>
<li>题目：给定一个字符串 s ，请你找出其中不含有重复字符的<code>最长子串</code>的长度</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753549142051.png" alt="75354914205"></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753549242890.png" alt="75354924289"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义需要用到的变量</span></span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;();</span><br><span class="line">  <span class="keyword">let</span> maxLength = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">    <span class="keyword">const</span> rightChar = s[right];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保留最新的索引之前，先判断是否之前已经出现过这个字符了</span></span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">has</span>(rightChar) &amp;&amp; map.<span class="title function_">get</span>(rightChar)! &gt;= left) &#123;</span><br><span class="line">      left = map.<span class="title function_">get</span>(rightChar)! + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    map.<span class="title function_">set</span>(rightChar, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> currLength = right - left + <span class="number">1</span>;</span><br><span class="line">    maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(currLength, maxLength);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLongestSubstring</span>(<span class="string">&quot;abcabcbb&quot;</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLongestSubstring</span>(<span class="string">&quot;bbbbb&quot;</span>));    <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLongestSubstring</span>(<span class="string">&quot;pwwkew&quot;</span>));   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-最长回文子串"><a href="#1-3-最长回文子串" class="headerlink" title="1.3 最长回文子串"></a>1.3 最长回文子串</h4><ul>
<li>最长回文子串：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">https://leetcode.cn/problems/longest-palindromic-substring/description/</a></li>
<li>题目：<ul>
<li>给你一个字符串 s，找到 s 中最长的回文子串</li>
<li>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753584074965.png" alt="75358407496"></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753584099183.png" alt="75358409918"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断对称</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">centerExpand</span>(<span class="params">s: <span class="built_in">string</span>, left: <span class="built_in">number</span>, right: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="property">length</span> &amp;&amp; s[left] === s[right]) &#123;</span><br><span class="line">    left--;</span><br><span class="line">    right++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">longestPalindrome</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 边界判断的情况</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 核心思路：对称</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> length1 = <span class="title function_">centerExpand</span>(s, i, i);</span><br><span class="line">    <span class="keyword">const</span> length2 = <span class="title function_">centerExpand</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> len = <span class="title class_">Math</span>.<span class="title function_">max</span>(length1, length2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">      <span class="comment">// 获取最长回文字符串的前后索引</span></span><br><span class="line">      <span class="keyword">const</span> left = i - <span class="title class_">Math</span>.<span class="title function_">floor</span>((len - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> right = i + <span class="title class_">Math</span>.<span class="title function_">floor</span>(len / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 新的长度比原来保存的start/end要长，重新赋值</span></span><br><span class="line">      start = left;</span><br><span class="line">      end = right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.<span class="title function_">substring</span>(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">longestPalindrome</span>(<span class="string">&quot;babad&quot;</span>)); <span class="comment">// aba</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">longestPalindrome</span>(<span class="string">&quot;cbbd&quot;</span>));  <span class="comment">// bb</span></span><br></pre></td></tr></table></figure>

<h3 id="2-栈结构大厂面试题"><a href="#2-栈结构大厂面试题" class="headerlink" title="2. 栈结构大厂面试题"></a>2. 栈结构大厂面试题</h3><h4 id="2-1-二叉树展开为链表"><a href="#2-1-二叉树展开为链表" class="headerlink" title="2.1 二叉树展开为链表"></a>2.1 二叉树展开为链表</h4><ul>
<li>二叉树展开为链表：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/</a></li>
<li>题目：给你二叉树的根结点 root ，请你将它展开为一个单链表<ul>
<li>展开后的单链表应该同样使用 TreeNode，其中right子指针指向链表中下一个结点，而左子指针始终为null </li>
<li>展开后的单链表应该与二叉树<code>先序遍历</code>顺序相同</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753705807837.png" alt="75370580783"></p>
<ul>
<li>可以使用栈结构：<ul>
<li>将当前节点的右子树和左子树依次压入栈中</li>
<li>然后再取出栈顶元素，将其左子树设为空，右子树设为栈顶元素</li>
<li>再继续将新的右子树和左子树压入栈中，重复这个过程直到栈为空</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, left?: TreeNode | <span class="literal">null</span>, right?: TreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// 边界判断</span></span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 栈结构</span></span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">previous</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = stack.<span class="title function_">pop</span>()!;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous) &#123;</span><br><span class="line">      previous.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">      previous.<span class="property">right</span> = current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将左右两边的节点压入栈中：先压right，后压left</span></span><br><span class="line">    <span class="keyword">const</span> left = current.<span class="property">left</span>;</span><br><span class="line">    <span class="keyword">const</span> right = current.<span class="property">right</span>;</span><br><span class="line">    <span class="keyword">if</span> (right) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    previous = current;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-逆波兰表达式求值"><a href="#2-2-逆波兰表达式求值" class="headerlink" title="2.2 逆波兰表达式求值"></a>2.2 逆波兰表达式求值</h4><ul>
<li>逆波兰表达式求值：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/</a></li>
<li>题目：<ul>
<li>给你一个字符串数组 tokens ，表示一个根据<code>逆波兰表示法</code>表示的算术表达式</li>
<li>请你计算该表达式，返回一个表示表达式值的整数</li>
<li>注意：<ul>
<li>有效的算符为 ‘+’、’-‘、’*’ 和 ‘&#x2F;‘ </li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式</li>
<li>两个整数之间的除法总是<code>向零截断</code></li>
<li>表达式中不含除零运算</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式</li>
<li>答案及所有中间计算结果可以用<code>32位</code>整数表示</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753707659655.png" alt="75370765965"></p>
<ul>
<li>使用了一个栈来存储数字和运算符<ul>
<li>遍历 tokens 数组，遇到数字时将其压入栈中，遇到运算符时从栈中弹出两个数字并进行相应的计算，将计算结果再压入栈中</li>
<li>最后栈中剩下的数字就是表达式的值</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isOperator</span>(<span class="params">token: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> token === <span class="string">&quot;+&quot;</span> || token === <span class="string">&quot;-&quot;</span> || token === <span class="string">&quot;*&quot;</span> || token === <span class="string">&quot;/&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">evalRPN</span>(<span class="params">tokens: <span class="built_in">string</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">stack</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历tokens</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> token <span class="keyword">of</span> tokens) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isOperator</span>(token)) &#123;</span><br><span class="line">      <span class="keyword">const</span> num2 = stack.<span class="title function_">pop</span>()!;</span><br><span class="line">      <span class="keyword">const</span> num1 = stack.<span class="title function_">pop</span>()!;</span><br><span class="line">      <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">          stack.<span class="title function_">push</span>(num1 + num2);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">          stack.<span class="title function_">push</span>(num1 - num2);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">          stack.<span class="title function_">push</span>(num1 * num2);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">          <span class="comment">// Math.floor 和 Math.trunc 区别：</span></span><br><span class="line">          <span class="comment">// Math.floor(3/2) = 1     Math.floor(-3/2) = -2</span></span><br><span class="line">          <span class="comment">// Math.trunc(3/2) = 1     Math.trunc(-3/2) = -1</span></span><br><span class="line">          stack.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="title function_">trunc</span>(num1 / num2));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(<span class="title class_">Number</span>(token));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> stack.<span class="title function_">pop</span>()!;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tokens1 = [<span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;+&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;*&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> tokens2 = [<span class="string">&quot;4&quot;</span>, <span class="string">&quot;13&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;+&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> tokens3 = [<span class="string">&quot;10&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;+&quot;</span>, <span class="string">&quot;-11&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;17&quot;</span>, <span class="string">&quot;+&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;+&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(evalRPN(tokens1)); <span class="comment">// 9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(evalRPN(tokens2)); <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(evalRPN(tokens3)); <span class="comment">// 22</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-用两个栈实现队列"><a href="#2-3-用两个栈实现队列" class="headerlink" title="2.3 用两个栈实现队列"></a>2.3 用两个栈实现队列</h4><ul>
<li>用两个栈实现队列：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/description/">https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/description/</a></li>
<li>题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code>，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753709537291.png" alt="75370953729"></p>
<ul>
<li>使用两个栈 s1 和 s2：s1 用来插入元素，s2 用来删除元素<ul>
<li>其中插入元素只需要将元素插入 s1 即可</li>
<li>删除元素则需要分情况：<ul>
<li>如果 s2 不为空，直接弹出 s2 的栈顶元素</li>
<li>如果 s2 为空，将 s1 中的元素逐个弹出并压入 s2，然后弹出 s2 的栈顶元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">stack1</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">stack2</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">appendTail</span>(<span class="attr">value</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="title function_">push</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deleteHead</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// stack2不为空</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="title function_">pop</span>()!;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// stack2为空，stack1不为空</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = <span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="title function_">pop</span>()!;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="title function_">push</span>(item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="title function_">pop</span>()!;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cQueue = <span class="keyword">new</span> <span class="title class_">CQueue</span>();</span><br><span class="line">cQueue.<span class="title function_">appendTail</span>(<span class="number">1</span>);</span><br><span class="line">cQueue.<span class="title function_">appendTail</span>(<span class="number">2</span>);</span><br><span class="line">cQueue.<span class="title function_">appendTail</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列：先进先出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cQueue.<span class="title function_">deleteHead</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cQueue.<span class="title function_">deleteHead</span>()); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cQueue.<span class="title function_">deleteHead</span>()); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cQueue.<span class="title function_">deleteHead</span>()); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-队列结构大厂面试题"><a href="#3-队列结构大厂面试题" class="headerlink" title="3. 队列结构大厂面试题"></a>3. 队列结构大厂面试题</h3><h4 id="3-1-滑动窗口最大值"><a href="#3-1-滑动窗口最大值" class="headerlink" title="3.1 滑动窗口最大值"></a>3.1 滑动窗口最大值</h4><ul>
<li>滑动窗口最大值：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/description/">https://leetcode.cn/problems/sliding-window-maximum/description/</a></li>
<li>首先，我们需要定义一个<code>双端队列</code> deque 用来<code>存储下标</code>，一个空数组 res 用来存储结果</li>
<li>接着，我们遍历整个数组，对于当前的数字 nums[i]，如果双端队列 deque 不为空，并且当前数字 nums[i] 大于等于队列末尾的数字，则我们弹出队列末尾的数字，直到队列为空或者当前数字 nums[i] 小于队列末尾的数字。这样可以保证队列中的数字是单调递减的。然后，我们将当前数字的下标 i 入队</li>
<li>接下来，我们需要保证队列中的<code>数字是在滑动窗口范围内</code>的。如果队列头部的数字的下标<code>小于等于 i-k</code>，说明这个数字已经<code>不在滑动窗口内</code>，我们需要<code>弹出队列头部的数字</code></li>
<li>最后，如果当前下标 i 大于等于 k - 1，我们将队列头部数字所对应的 nums 中的数字加入到结果数组 res 中</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753710888236.png" alt="75371088823"></p>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753710932366.png" alt="75371093236"></p>
<ul>
<li>创建一个双端队列 (数组)</li>
<li>遍历每一个元素，每遍历到一个元素，就将其添加到队列尾部中，如果新添加的元素，比队列原来尾部的元素要大，那么之前尾部的元素删除掉</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 创建双端队列结构(存放元素对应的索引)</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">deque</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">res</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历每一个元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 将元素放到队列的尾部(队列存放的是下标值)</span></span><br><span class="line">    <span class="keyword">while</span> (deque.<span class="property">length</span> &amp;&amp; nums[i] &gt; nums[deque[deque.<span class="property">length</span> - <span class="number">1</span>]]) &#123;</span><br><span class="line">      deque.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将索引放入队列里面</span></span><br><span class="line">    deque.<span class="title function_">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断目前队列头部元素的索引是否在范围之内</span></span><br><span class="line">    <span class="keyword">while</span> (deque[<span class="number">0</span>] &lt;= i - k) &#123;</span><br><span class="line">      deque.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取头部的值，作为最大值</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> max = nums[deque[<span class="number">0</span>]];</span><br><span class="line">      res.<span class="title function_">push</span>(max);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxSlidingWindow</span>(nums, <span class="number">3</span>)); <span class="comment">// [3, 3, 5, 5, 6, 7]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxSlidingWindow</span>([<span class="number">1</span>], <span class="number">1</span>));  <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-链表结构大厂面试题"><a href="#4-链表结构大厂面试题" class="headerlink" title="4. 链表结构大厂面试题"></a>4. 链表结构大厂面试题</h3><h4 id="4-1-删除链表的倒数第-N-个结点"><a href="#4-1-删除链表的倒数第-N-个结点" class="headerlink" title="4.1 删除链表的倒数第 N 个结点"></a>4.1 删除链表的倒数第 N 个结点</h4><ul>
<li>删除链表的倒数第 N 个结点：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a></li>
<li>题目：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753881769911.png" alt="75388176991"></p>
<ul>
<li>可以使用<code>双指针</code>来解决这个问题：<ul>
<li>首先让快指针先移动 n 步，然后让慢指针和快指针一起移动，直到快指针到达链表末尾</li>
<li>此时慢指针所指的节点就是要删除的节点的前一个节点，可以将其指向下下个节点，从而删除倒数第 n 个节点</li>
<li>其中 dummy 节点是为了方便处理边界情况而添加的（dummy是虚拟节点的意思）</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753881825191.png" alt="75388182519"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">ListNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, next?: ListNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next === <span class="literal">undefined</span> ? <span class="literal">null</span> : next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">hea ListNode | <span class="literal">null</span>, n: <span class="built_in">number</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 1.创建虚拟节点</span></span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">  dummy.<span class="property">next</span> = head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.创建双指针</span></span><br><span class="line">  <span class="keyword">let</span> slow = dummy;</span><br><span class="line">  <span class="keyword">let</span> fast = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.先让快指针移动 n+1 个位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    fast = fast.<span class="property">next</span>!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.两个指针一起移动</span></span><br><span class="line">  <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">    slow = slow.<span class="property">next</span>!;</span><br><span class="line">    fast = fast.<span class="property">next</span>!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.slow指向的节点一定是要删除节点的前一个节点</span></span><br><span class="line">  slow.<span class="property">next</span> = slow.<span class="property">next</span>!.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-两两交换链表中的节点"><a href="#4-2-两两交换链表中的节点" class="headerlink" title="4.2 两两交换链表中的节点"></a>4.2 两两交换链表中的节点</h4><ul>
<li>两两交换链表中的节点：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">https://leetcode.cn/problems/swap-nodes-in-pairs/description/</a></li>
<li>题目：给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753882568688.png" alt="75388256868"></p>
<ul>
<li>实现思路：<ul>
<li>首先添加一个 dummy 节点</li>
<li>创建一个 current 节点，默认指向虚拟节点（这里因为有虚拟节点，所以可以直接调用next）</li>
<li>使用一个指针 current 依次指向每组相邻的节点，然后交换这两个节点的位置，直到遍历完整个链表</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753882524546.png" alt="75388252454"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">ListNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, next?: ListNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next === <span class="literal">undefined</span> ? <span class="literal">null</span> : next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swapPairs</span>(<span class="params">hea ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 1.创建虚拟节点</span></span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">  dummy.<span class="property">next</span> = head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.创建current节点，指向虚拟节点</span></span><br><span class="line">  <span class="keyword">let</span> current = dummy;</span><br><span class="line">  <span class="keyword">while</span> (current.<span class="property">next</span> &amp;&amp; current.<span class="property">next</span>.<span class="property">next</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node1 = current.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">const</span> node2 = current.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.交换位置</span></span><br><span class="line">    current.<span class="property">next</span> = node2;</span><br><span class="line">    node1.<span class="property">next</span> = node2.<span class="property">next</span>;</span><br><span class="line">    node2.<span class="property">next</span> = node1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.开始进行下一次交换</span></span><br><span class="line">    current = node1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-二叉树大厂面试题"><a href="#5-二叉树大厂面试题" class="headerlink" title="5. 二叉树大厂面试题"></a>5. 二叉树大厂面试题</h3><h4 id="5-1-二叉树的前序遍历"><a href="#5-1-二叉树的前序遍历" class="headerlink" title="5.1 二叉树的前序遍历"></a>5.1 二叉树的前序遍历</h4><ul>
<li>二叉树的前序遍历：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, left?: TreeNode | <span class="literal">null</span>, right?: TreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">preorderTraversal</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">result</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">node: TreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    result.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">    <span class="title function_">traverse</span>(node.<span class="property">left</span>);</span><br><span class="line">    <span class="title function_">traverse</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">traverse</span>(root);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>栈实现</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753963331481.png" alt="75396333148"> </p>
<h4 id="5-2-二叉树的中序遍历"><a href="#5-2-二叉树的中序遍历" class="headerlink" title="5.2 二叉树的中序遍历"></a>5.2 二叉树的中序遍历</h4><ul>
<li>二叉树的中序遍历：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, left?: TreeNode | <span class="literal">null</span>, right?: TreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inorderTraversal</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">result</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">node: TreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">traverse</span>(node.<span class="property">left</span>);</span><br><span class="line">    result.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">    <span class="title function_">traverse</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">traverse</span>(root);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>栈实现</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753963296739.png" alt="75396329673"> </p>
<h4 id="5-3-二叉树的后序遍历"><a href="#5-3-二叉树的后序遍历" class="headerlink" title="5.3 二叉树的后序遍历"></a>5.3 二叉树的后序遍历</h4><ul>
<li>二叉树的后序遍历：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, left?: TreeNode | <span class="literal">null</span>, right?: TreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">postorderTraversal</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">result</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">node: TreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">traverse</span>(node.<span class="property">left</span>);</span><br><span class="line">    <span class="title function_">traverse</span>(node.<span class="property">right</span>);</span><br><span class="line">    result.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">traverse</span>(root);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>栈实现</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753963263793.png" alt="75396326379"> </p>
<h4 id="5-4-二叉树的层序遍历"><a href="#5-4-二叉树的层序遍历" class="headerlink" title="5.4 二叉树的层序遍历"></a>5.4 二叉树的层序遍历</h4><ul>
<li>二叉树的层序遍历：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">https://leetcode.cn/problems/binary-tree-level-order-traversal/description/</a></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, left?: TreeNode | <span class="literal">null</span>, right?: TreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">levelOrder</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">result</span>: <span class="built_in">number</span>[][] = [];</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">queue</span>: <span class="title class_">TreeNode</span>[] = [root];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">level</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">    <span class="keyword">let</span> levelSize = queue.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>()!;</span><br><span class="line">      level.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.<span class="title function_">push</span>(level);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-翻转二叉树"><a href="#5-5-翻转二叉树" class="headerlink" title="5.5 翻转二叉树"></a>5.5 翻转二叉树</h4><ul>
<li>翻转二叉树（Max Howell去Google面试没有写出来的题目）<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/description/">https://leetcode.cn/problems/invert-binary-tree/description/</a></li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753885017941.png" alt="75388501794"></p>
<ul>
<li>栈实现</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, left?: TreeNode | <span class="literal">null</span>, right?: TreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invertTree</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title class_">TreeNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.创建栈结构</span></span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.从栈中不断取出节点，对节点的左右子节点交换</span></span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = stack.<span class="title function_">pop</span>()!;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对current节点左右交换位置</span></span><br><span class="line">    <span class="keyword">const</span> temp = current.<span class="property">left</span>;</span><br><span class="line">    current.<span class="property">left</span> = current.<span class="property">right</span>;</span><br><span class="line">    current.<span class="property">right</span> = temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将子节点加入栈中</span></span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">left</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(current.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">right</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(current.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归实现</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, left?: TreeNode | <span class="literal">null</span>, right?: TreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invertTree</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title class_">TreeNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// root不为空</span></span><br><span class="line">  <span class="keyword">const</span> left = root.<span class="property">left</span>;</span><br><span class="line">  root.<span class="property">left</span> = <span class="title function_">invertTree</span>(root.<span class="property">right</span>);</span><br><span class="line">  root.<span class="property">right</span> = <span class="title function_">invertTree</span>(left);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-6-二叉树中的最大路径和"><a href="#5-6-二叉树中的最大路径和" class="headerlink" title="5.6 二叉树中的最大路径和"></a>5.6 二叉树中的最大路径和</h4><ul>
<li>二叉树中的最大路径和：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/</a></li>
<li>题目：<ul>
<li><code>路径</code>被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中<code>至多出现一次</code>，该路径<code>至少包含一个</code>节点，且不一定经过根节点</li>
<li>路径和是<code>路径中各节点值的总和</code></li>
<li>给你一个二叉树的根节点 root ，返回其 最大路径和</li>
</ul>
</li>
</ul>
<p><img src="/./images/typora%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%5C1753964399673.png" alt="75396439967"></p>
<ul>
<li>这道题目可以使用深度优先搜索（DFS）来解决<ul>
<li>我们可以从根节点开始递归，遍历二叉树中的所有节点</li>
<li>对于每个节点，我们需要计算经过该节点的最大路径和<ul>
<li>在计算经过该节点的最大路径和时，我们需要考虑到左子树和右子树是否能够贡献最大路径和</li>
<li>如果左子树的最大路径和大于 0，那么我们就将其加入到经过该节点的最大路径和中</li>
<li>如果右子树的最大路径和大于 0，那么我们就将其加入到经过该节点的最大路径和中</li>
</ul>
</li>
<li>最后，我们将经过该节点的最大路径和与已经计算出的最大路径和进行比较，取两者中的较大值</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, left?: TreeNode | <span class="literal">null</span>, right?: TreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val === <span class="literal">undefined</span> ? <span class="number">0</span> : val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxPathSum</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> maxSum = -<span class="title class_">Infinity</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义内部函数来进行递归的操作</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">node: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右子树计算可以提供的非0最大值</span></span><br><span class="line">    <span class="keyword">const</span> leftSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">dfs</span>(node.<span class="property">left</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> rightSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">dfs</span>(node.<span class="property">right</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点中能获取到的最大值</span></span><br><span class="line">    <span class="keyword">const</span> pathSum = node.<span class="property">val</span> + leftSum + rightSum;</span><br><span class="line">    maxSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(pathSum, maxSum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前节点能给父节点提供的最大值</span></span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">val</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(leftSum, rightSum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dfs</span>(root);</span><br><span class="line">  <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tree20 = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">20</span>, <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">15</span>), <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">7</span>));</span><br><span class="line"><span class="keyword">let</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">9</span>), tree20);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxPathSum</span>(root)); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://old-gang.github.io">Mr.储</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://old-gang.github.io/post/4b0178e0.html">https://old-gang.github.io/post/4b0178e0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://old-gang.github.io" target="_blank">Mr.储</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/web%E5%89%8D%E7%AB%AF/">web前端</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/post/dbf79349.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深入了解前端可视化</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mr.储</div><div class="author-info__description">Fake it, until u make it~</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/old-gang"><i class="fab fa-github"></i><span>点个关注呗</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/old-gang" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p align="center"><img src="https://chu-image-host.oss-cn-beijing.aliyuncs.com/typora/f7384c88956d4378b72e47548e19c9f8.gif" width="50" alt="gou"></p> <p align="center">微信号：cr1710518304</p> <p align="center">QQ号：1710518304</p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">JavaScript数据结构和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%82%82%E9%80%85%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">(一) 邂逅数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%96%E7%A8%8B%E5%B0%BD%E5%A4%B4%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 编程尽头、数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1 为什么需要学习数据结构与算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%BC%96%E7%A8%8B%E7%9A%84%E7%9C%9F%E7%9B%B8-%E2%80%93-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.2 编程的真相 – 数据的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.3 数据结构与算法的本质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.  数据结构与算法的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">2.1 学习数据结构与算法到底有什么实际应用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Vue%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2.2 Vue源码中的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-React%E3%80%81Webpack%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">2.3 React、Webpack源码中的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Homebrew%E4%BD%9C%E8%80%85%E8%A2%ABGoogle%E6%8B%92%E7%BB%9D"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">2.4 Homebrew作者被Google拒绝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E3%80%81%E9%AB%98%E7%BA%A7%E5%B2%97%E4%BD%8D%E9%9D%A2%E8%AF%95"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">2.5 互联网大厂、高级岗位面试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 如何学习数据结构算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. 到底什么是数据结构？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">4.1 常见的数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">5. 到底什么是算法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">5.1 什么是算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">5.2 生活中的数据结构与算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%94%9F%E6%B4%BB%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.6.</span> <span class="toc-text">6. 生活中数据结构与算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E2%80%93-%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.</span> <span class="toc-text">(二) 线性结构 – 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%EF%BC%88Linear-List%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 线性结构（Linear List）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%EF%BC%88Array%EF%BC%89%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 数组（Array）结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%A0%88%E7%BB%93%E6%9E%84%EF%BC%88Stack%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">(三) 栈结构（Stack）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A4%E8%AF%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 认识栈结构和特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%88%E7%BB%93%E6%9E%84%E7%89%B9%E6%80%A7-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 栈结构特性-面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%BB%93%E6%9E%84%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 实现栈结构的封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%A0%88%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.1 栈结构的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%88%9B%E5%BB%BA%E6%A0%88%E7%9A%84%E7%B1%BB"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.2 创建栈的类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%88%E7%BB%93%E6%9E%84%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95-%E5%AE%8C%E6%95%B4%E5%B0%81%E8%A3%85"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. 栈结构常见的方法 (完整封装)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A0%88%E9%9D%A2%E8%AF%95%E9%A2%98-%E2%80%93-%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. 栈面试题 – 十进制转二进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%A0%88%E9%9D%A2%E8%AF%95%E9%A2%98-%E2%80%93-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.3.6.</span> <span class="toc-text">6. 栈面试题 – 有效的括号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%EF%BC%88Queue%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">(四) 队列结构（Queue）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A4%E8%AF%86%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 认识队列以及特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E8%AE%A4%E8%AF%86%E9%98%9F%E5%88%97"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">1.1 认识队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">1.2 生活中的队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%BC%80%E5%8F%91%E4%B8%AD%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">1.3 开发中队列的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E5%B0%81%E8%A3%85"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 实现队列结构封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95-%E5%AE%8C%E6%95%B4%E5%B0%81%E8%A3%85"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. 队列结构常见方法 (完整封装)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95%E9%A2%98-%E2%80%93-%E5%87%BB%E9%BC%93%E4%BC%A0%E8%8A%B1"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. 队列面试题 – 击鼓传花</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF"><span class="toc-number">1.4.5.</span> <span class="toc-text">5. 队列面试题 - 约瑟夫环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%88%E5%8E%86%E5%8F%B2%EF%BC%89"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">5.1 什么是约瑟夫环问题（历史）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98-%E2%80%93-%E5%AD%97%E8%8A%82%E3%80%81%E9%98%BF%E9%87%8C%E3%80%81%E8%B0%B7%E6%AD%8C%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">5.2 约瑟夫环问题 – 字节、阿里、谷歌等面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%88LinkedList%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">(五) 链表结构（LinkedList）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A4%E8%AF%86%E9%93%BE%E8%A1%A8%E4%BB%A5%E5%8F%8A%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 认识链表以及特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E9%93%BE%E8%A1%A8%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">1.1 链表以及数组的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">1.2 链表的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E9%93%BE%E8%A1%A8%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">1.3 链表到底是什么?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B0%81%E8%A3%85%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. 封装链表的类结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%81%E8%A3%85%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. 封装链表相关方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-append%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">3.1 append方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-insert%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">3.2 insert方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-removeAt%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">3.3 removeAt方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-get%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">3.4 get方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E9%81%8D%E5%8E%86%E7%BB%93%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C%E9%87%8D%E6%9E%84"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">3.5 遍历结点的操作重构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-update%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.6.</span> <span class="toc-text">3.6 update方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-indexOf%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.7.</span> <span class="toc-text">3.7 indexOf方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-remove%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.8.</span> <span class="toc-text">3.8 remove方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-isEmpty%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.9.</span> <span class="toc-text">3.9 isEmpty方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%93%BE%E8%A1%A8%E5%AE%8C%E6%95%B4%E5%B0%81%E8%A3%85%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.4.</span> <span class="toc-text">4. 链表完整封装代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.5.5.</span> <span class="toc-text">5. 链表常见的面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8-%E5%AD%97%E8%8A%82%E3%80%81%E8%85%BE%E8%AE%AF%E7%AD%89%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">5.1 设计链表 -字节、腾讯等公司面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E2%80%93-%E5%AD%97%E8%8A%82%E3%80%81%E9%98%BF%E9%87%8C%E7%AD%89%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">5.2 删除链表中的节点 – 字节、阿里等公司面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E2%80%93-%E5%AD%97%E8%8A%82%E3%80%81%E8%B0%B7%E6%AD%8C%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">5.3 反转链表 – 字节、谷歌等面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.5.6.</span> <span class="toc-text">6. 算法的复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E7%8E%B0%E5%AE%9E%E6%A1%88%E4%BE%8B%EF%BC%89"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">6.1 什么是算法复杂度（现实案例）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E7%A8%8B%E5%BA%8F%E6%A1%88%E4%BE%8B%EF%BC%89"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">6.2 什么是算法复杂度（程序案例）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">6.3 顺序查找和二分查找的测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88Big-O-notation%EF%BC%89"><span class="toc-number">1.5.6.4.</span> <span class="toc-text">6.4 大O表示法（Big O notation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AF%B9%E6%95%B0%E7%BB%93"><span class="toc-number">1.5.6.5.</span> <span class="toc-text">6.5 大O表示法 - 常见的对数结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.5.6.6.</span> <span class="toc-text">6.6 空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.7.</span> <span class="toc-text">7. 数组和链表的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88HashTable%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">(六) 哈希表（HashTable）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%93%88%E5%B8%8C%E8%A1%A8%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 哈希表介绍和特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">1.1 哈希表的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">1.2 哈希表到底是什么呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%85%AC%E5%8F%B8%E5%91%98%E5%B7%A5%E5%AD%98%E5%82%A8"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">1.3 案例一：公司员工存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A50000%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">1.4 案例二：50000个单词的存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%93%88%E5%B8%8C%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. 数据的哈希化过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%AD%97%E6%AF%8D%E8%BD%AC%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%A1%88%E4%B8%80"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">2.1 字母转数字的方案一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%AD%97%E6%AF%8D%E8%BD%AC%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%A1%88%E4%BA%8C"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">2.2 字母转数字的方案二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E4%B8%8B%E6%A0%87%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">2.3 下标的压缩算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">2.4 哈希表的一些概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9C%B0%E5%9D%80%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. 地址冲突解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">3.1 什么是冲突？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">3.2 链地址法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%EF%BC%88%E4%B8%80%E5%AE%9A%E8%A6%81%E7%90%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.6.3.2.1.</span> <span class="toc-text">3.2.1 链地址法（一定要理解）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">1.6.3.2.2.</span> <span class="toc-text">3.2.2 链地址法解析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">3.3 开放地址法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="toc-number">1.6.3.3.1.</span> <span class="toc-text">3.3.1 开放地址法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B"><span class="toc-number">1.6.3.3.2.</span> <span class="toc-text">3.3.2 线性探测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B"><span class="toc-number">1.6.3.3.3.</span> <span class="toc-text">3.3.3 二次探测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-4-%E5%86%8D%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-number">1.6.3.3.4.</span> <span class="toc-text">3.3.4 再哈希法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%93%88%E5%B8%8C%E5%8C%96%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">3.4 哈希化的效率</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-1-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%95%88%E7%8E%87"><span class="toc-number">1.6.3.4.1.</span> <span class="toc-text">3.4.1 线性探测效率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-2-%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B%E5%92%8C%E5%86%8D%E5%93%88%E5%B8%8C%E5%8C%96%E6%95%88%E7%8E%87"><span class="toc-number">1.6.3.4.2.</span> <span class="toc-text">3.4.2 二次探测和再哈希化效率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-3-%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%E6%95%88%E7%8E%87"><span class="toc-number">1.6.3.4.3.</span> <span class="toc-text">3.4.3 链地址法效率</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.4.</span> <span class="toc-text">4. 哈希函数代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">4.1 哈希函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97%EF%BC%9A%E9%9C%8D%E7%BA%B3%E6%B3%95%E5%88%99"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">4.2 快速计算：霍纳法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">4.3 均匀分布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-Java%E4%B8%AD%E7%9A%84HashMap"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">4.4 Java中的HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-N%E6%AC%A1%E5%B9%82%E7%9A%84%E5%BA%95%E6%95%B0"><span class="toc-number">1.6.4.5.</span> <span class="toc-text">4.5 N次幂的底数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.5.</span> <span class="toc-text">5. 哈希表创建和操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">5.1 哈希函数的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%88%9B%E5%BB%BA%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">5.2 创建哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E6%8F%92%E5%85%A5-amp-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">5.3 插入 &amp; 修改数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.6.5.4.</span> <span class="toc-text">5.4 获取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">1.6.5.5.</span> <span class="toc-text">5.5 删除数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E8%87%AA%E5%8A%A8%E6%89%A9%E5%AE%B9"><span class="toc-number">1.6.6.</span> <span class="toc-text">6. 哈希表的自动扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%89%A9%E5%AE%B9%E7%9A%84%E6%80%9D%E6%83%B3"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">6.1 哈希表扩容的思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E6%89%A9%E5%AE%B9%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">6.2 扩容函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-put-x2F-remove%E6%96%B9%E6%B3%95%E4%BF%AE%E6%94%B9"><span class="toc-number">1.6.6.3.</span> <span class="toc-text">6.3 put&#x2F;remove方法修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E5%AE%B9%E9%87%8F%E8%B4%A8%E6%95%B0"><span class="toc-number">1.6.6.4.</span> <span class="toc-text">6.4 容量质数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E8%B4%A8%E6%95%B0%E5%88%A4%E6%96%AD"><span class="toc-number">1.6.6.5.</span> <span class="toc-text">6.5 更高效的质数判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-%E6%89%A9%E5%AE%B9%E7%9A%84%E8%B4%A8%E6%95%B0-%E5%AE%8C%E6%95%B4%E5%B0%81%E8%A3%85"><span class="toc-number">1.6.6.6.</span> <span class="toc-text">6.6 扩容的质数 (完整封装)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E6%A0%91%E7%BB%93%E6%9E%84%EF%BC%88Tree%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">(七) 树结构（Tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A4%E8%AF%86%E6%A0%91%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E7%89%B9%E6%80%A7"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. 认识树结构以及特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%91%EF%BC%9F"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">1.1 什么是树？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%A8%A1%E6%8B%9F%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">1.2 模拟树结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">1.3 树结构的抽象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 树结构的优点和术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%A0%91%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">2.1 树的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%A0%91%E7%9A%84%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">2.2 树的术语</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%91%E7%BB%93%E6%9E%84%E5%B8%B8%E8%A7%81%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. 树结构常见表示方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.4.</span> <span class="toc-text">4. 二叉树特性以及概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">4.1 二叉树的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">4.2 二叉树的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%AE%8C%E7%BE%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">4.3 完美二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.4.4.</span> <span class="toc-text">4.4 完全二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.5.</span> <span class="toc-text">5. 二叉树常见存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AE%A4%E8%AF%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%89%B9%E6%80%A7"><span class="toc-number">1.7.6.</span> <span class="toc-text">6. 认识二叉搜索树特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%9F"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">6.1 什么是二叉搜索树？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">6.2 二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">1.7.7.</span> <span class="toc-text">7. 二叉搜索树类的封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.8.</span> <span class="toc-text">8. 二叉搜索树常见操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.9.</span> <span class="toc-text">9. 二叉搜索树插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.10.</span> <span class="toc-text">10. 二叉搜索树遍历操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.10.1.</span> <span class="toc-text">10.1 先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.10.2.</span> <span class="toc-text">10.2 中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.10.3.</span> <span class="toc-text">10.3 后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.10.4.</span> <span class="toc-text">10.4 层序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E5%A4%A7%E5%80%BC-amp-%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">1.7.11.</span> <span class="toc-text">11. 二叉搜索树最大值 &amp; 最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.12.</span> <span class="toc-text">12. 二叉搜索树搜索操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.13.</span> <span class="toc-text">13. 二叉搜索树删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A%E6%B2%A1%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.13.1.</span> <span class="toc-text">13.1 情况一：没有子节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.13.2.</span> <span class="toc-text">13.2 情况二：一个子节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-%E6%83%85%E5%86%B5%E4%B8%89%EF%BC%9A%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.13.3.</span> <span class="toc-text">13.3 情况三：两个子节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.13.4.</span> <span class="toc-text">13.4 删除操作总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%8C%E6%95%B4%E5%B0%81%E8%A3%85"><span class="toc-number">1.7.14.</span> <span class="toc-text">14. 二叉搜索树完整封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84"><span class="toc-number">1.7.14.1.</span> <span class="toc-text">14.1 代码重构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-%E6%A0%91%E5%AD%98%E6%94%BE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.14.2.</span> <span class="toc-text">14.2 树存放对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">1.7.15.</span> <span class="toc-text">15. 二叉搜索树的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E6%A0%91%E7%9A%84%E5%B9%B3%E8%A1%A1%E6%80%A7"><span class="toc-number">1.7.16.</span> <span class="toc-text">16. 树的平衡性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E5%9B%BE%E7%BB%93%E6%9E%84%EF%BC%88Graph%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">(八) 图结构（Graph）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A4%E8%AF%86%E5%9B%BE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E7%89%B9%E6%80%A7"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 认识图结构以及特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">1.1 什么是图?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%9B%BE%E7%9A%84%E7%8E%B0%E5%AE%9E%E6%A1%88%E4%BE%8B"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">1.2 图的现实案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%86%8D%E6%AC%A1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">1.3 再次 什么是图?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%8E%86%E5%8F%B2%E6%95%85%E4%BA%8B"><span class="toc-number">1.8.1.4.</span> <span class="toc-text">1.4 历史故事</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%AC%A7%E6%8B%89%E5%92%8C%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E6%B3%95"><span class="toc-number">1.8.2.</span> <span class="toc-text">2. 欧拉和七桥问题解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.8.3.</span> <span class="toc-text">3. 图结构的常见术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%9B%BE%E7%9A%84%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">3.1 图的术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">3.2 图的表示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.8.4.</span> <span class="toc-text">4. 邻接矩阵和邻接表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">4.1 邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">4.2 邻接表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%9B%E5%BB%BA%E5%9B%BE%E7%B1%BB"><span class="toc-number">1.8.5.</span> <span class="toc-text">5. 创建图类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">5.1 添加方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-printEdges%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">5.2 printEdges方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.8.6.</span> <span class="toc-text">6. 图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">6.1 图的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E9%81%8D%E5%8E%86%E7%9A%84%E6%80%9D%E6%83%B3"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">6.2 遍历的思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">1.8.6.3.</span> <span class="toc-text">6.3 广度优先搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">1.8.6.4.</span> <span class="toc-text">6.4 深度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%9B%BE%E5%AE%8C%E6%95%B4%E5%B0%81%E8%A3%85"><span class="toc-number">1.8.7.</span> <span class="toc-text">7. 图完整封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.8.8.</span> <span class="toc-text">8. 图结构的常见建模</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-%E2%80%93-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.9.</span> <span class="toc-text">(九) 循环链表 – 双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.9.1.</span> <span class="toc-text">1. 循环链表结构介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%EF%BC%88%E6%96%B9%E4%BE%BF%E7%BB%A7%E6%89%BF%EF%BC%89"><span class="toc-number">1.9.2.</span> <span class="toc-text">2. 单向链表代码重构（方便继承）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.3.</span> <span class="toc-text">3. 循环链表代码完整实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.9.4.</span> <span class="toc-text">4. 双向链表结构介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">4.1 双向链表的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E7%94%BB%E5%9B%BE"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">4.2 双向链表的画图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E5%B0%81%E8%A3%85"><span class="toc-number">1.9.5.</span> <span class="toc-text">5. 双向链表节点封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.6.</span> <span class="toc-text">6. 双向链表方法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-append%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.6.1.</span> <span class="toc-text">6.1 append方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-prepend%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.6.2.</span> <span class="toc-text">6.2 prepend方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-postTraverse%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.6.3.</span> <span class="toc-text">6.3 postTraverse方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-insert%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.6.4.</span> <span class="toc-text">6.4 insert方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-removeAt%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.6.5.</span> <span class="toc-text">6.5 removeAt方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.6.6.</span> <span class="toc-text">6.6 双向链表代码完整实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-%E5%A0%86%E7%BB%93%E6%9E%84%EF%BC%88Heap%EF%BC%89"><span class="toc-number">1.10.</span> <span class="toc-text">(十) 堆结构（Heap）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A4%E8%AF%86%E5%A0%86%E7%BB%93%E6%9E%84%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.10.1.</span> <span class="toc-text">1. 认识堆结构的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%EF%BC%88Heap%EF%BC%89%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">1.1 什么是堆（Heap）结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A0%86%EF%BC%88Heap%EF%BC%89%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">1.2 为什么需要堆（Heap）结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E8%AE%A4%E8%AF%86%E5%A0%86%EF%BC%88Heap%EF%BC%89%E7%BB%93%E6%9E%84"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">1.3 认识堆（Heap）结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%A0%86%E7%BB%93%E6%9E%84%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.10.1.4.</span> <span class="toc-text">1.4 堆结构的性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A0%86%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.10.2.</span> <span class="toc-text">2. 堆结构的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A0%86%E7%BB%93%E6%9E%84%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">1.10.3.</span> <span class="toc-text">3. 堆结构的封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%80%E5%A4%A7%E5%A0%86%E7%BB%93%E6%9E%84%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.10.4.</span> <span class="toc-text">4. 最大堆结构方法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-insert%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">4.1 insert插入方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-delete%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">4.2 delete删除方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%A0%86%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.4.3.</span> <span class="toc-text">4.3 堆结构的其他方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E5%8E%9F%E5%9C%B0%E5%BB%BA%E5%A0%86"><span class="toc-number">1.10.4.4.</span> <span class="toc-text">4.4 数组进行原地建堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E6%9C%80%E5%A4%A7%E5%A0%86%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.10.4.5.</span> <span class="toc-text">4.5 最大堆完整代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%80%E5%B0%8F%E5%A0%86%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.10.5.</span> <span class="toc-text">5.最小堆完整代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9C%80%E5%A4%A7%E5%A0%86%E5%92%8C%E6%9C%80%E5%B0%8F%E5%A0%86%E5%90%8C%E6%97%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.10.6.</span> <span class="toc-text">6. 最大堆和最小堆同时实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-Deque-%E2%80%93-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-Priority-Queue"><span class="toc-number">1.11.</span> <span class="toc-text">(十一) 双端队列(Deque) – 优先队列(Priority Queue)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A4%E8%AF%86%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%88Deque%EF%BC%89"><span class="toc-number">1.11.1.</span> <span class="toc-text">1. 认识双端队列的特性（Deque）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.11.2.</span> <span class="toc-text">2. 双端队列的代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%A4%E8%AF%86%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%EF%BC%88Priority-Queue%EF%BC%89"><span class="toc-number">1.11.3.</span> <span class="toc-text">3. 认识优先级队列结构（Priority Queue）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80"><span class="toc-number">1.11.4.</span> <span class="toc-text">4. 优先级队列的实现一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8C"><span class="toc-number">1.11.5.</span> <span class="toc-text">5. 优先级队列的实现二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%E6%A0%91%EF%BC%89"><span class="toc-number">1.12.</span> <span class="toc-text">(十二) 平衡二叉树（AVL树）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.12.1.</span> <span class="toc-text">1. 平衡的二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%88Balanced-Tree%EF%BC%89"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">1.1 平衡树（Balanced Tree）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%A6%82%E4%BD%95%E8%AE%A9%E6%A0%91%E5%8F%AF%E4%BB%A5%E6%9B%B4%E5%8A%A0%E5%B9%B3%E8%A1%A1%E5%91%A2%EF%BC%9F"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">1.2 如何让树可以更加平衡呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.12.1.3.</span> <span class="toc-text">1.3 常见的平衡二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AVL%E6%A0%91%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">1.12.2.</span> <span class="toc-text">2. AVL树介绍和特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-AVL%E6%A0%91"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">2.1 AVL树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-AVL%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC%E6%83%85%E5%86%B5"><span class="toc-number">1.12.2.2.</span> <span class="toc-text">2.2 AVL树的旋转情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-AVL%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B"><span class="toc-number">1.12.2.3.</span> <span class="toc-text">2.3 AVL树结构的封装过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9AAVL%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%B0%81%E8%A3%85%EF%BC%88AVLTreeNode%EF%BC%89"><span class="toc-number">1.12.3.</span> <span class="toc-text">3. 步骤一：AVL树节点的封装（AVLTreeNode）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9AAVL%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%8F%B3%E6%97%8B%E8%BD%AC"><span class="toc-number">1.12.4.</span> <span class="toc-text">4. 步骤二：AVL左旋转右旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-AVL%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC-%E2%80%93-%E5%8F%B3%E6%97%8B%E8%BD%AC"><span class="toc-number">1.12.4.1.</span> <span class="toc-text">4.1 AVL树的旋转 – 右旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-AVL%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC-%E2%80%93-%E5%B7%A6%E6%97%8B%E8%BD%AC"><span class="toc-number">1.12.4.2.</span> <span class="toc-text">4.2 AVL树的旋转 – 左旋转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%81%E8%A3%85AVLTree"><span class="toc-number">1.12.5.</span> <span class="toc-text">5. 封装AVLTree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%AD%A5%E9%AA%A4%E4%B8%89%EF%BC%9A%E4%B8%8D%E5%90%8C%E6%83%85%E5%86%B5%E6%97%8B%E8%BD%AC%E4%BB%A3%E7%A0%81"><span class="toc-number">1.12.6.</span> <span class="toc-text">6. 步骤三：不同情况旋转代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E6%97%8B%E8%BD%AC%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5-%E5%88%86%E6%9E%90"><span class="toc-number">1.12.6.1.</span> <span class="toc-text">6.1 旋转的四种情况 - 分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E6%97%8B%E8%BD%AC%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.12.6.2.</span> <span class="toc-text">6.2 旋转的四种情况 - 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%AD%A5%E9%AA%A4%E5%9B%9B%EF%BC%9AAVL%E6%8F%92%E5%85%A5%E6%97%B6%E7%9A%84%E8%B0%83%E6%95%B4"><span class="toc-number">1.12.7.</span> <span class="toc-text">7. 步骤四：AVL插入时的调整</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E6%8F%92%E5%85%A5%E7%9A%84%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">1.12.7.1.</span> <span class="toc-text">7.1 插入的案例演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-insert%E7%9A%84%E8%B0%83%E6%95%B4%E5%92%8C%E5%86%8D%E5%B9%B3%E8%A1%A1"><span class="toc-number">1.12.7.2.</span> <span class="toc-text">7.2 insert的调整和再平衡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%AD%A5%E9%AA%A4%E4%BA%94%EF%BC%9AAVL%E5%88%A0%E9%99%A4%E6%97%B6%E7%9A%84%E8%B0%83%E6%95%B4"><span class="toc-number">1.12.8.</span> <span class="toc-text">8. 步骤五：AVL删除时的调整</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E5%88%A0%E9%99%A4%E7%9A%84%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">1.12.8.1.</span> <span class="toc-text">8.1 删除的案例演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-remove%E7%9A%84%E8%B0%83%E6%95%B4%E5%92%8C%E5%86%8D%E5%B9%B3%E8%A1%A1"><span class="toc-number">1.12.8.2.</span> <span class="toc-text">8.2 remove的调整和再平衡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-AVL%E5%86%8D%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.12.9.</span> <span class="toc-text">9. AVL再平衡的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-AVL%E6%A0%91%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">1.12.10.</span> <span class="toc-text">10. AVL树完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%89"><span class="toc-number">1.13.</span> <span class="toc-text">(十三) 平衡二叉树（红黑树）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">1.13.1.</span> <span class="toc-text">1. 红黑树介绍和特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E9%82%82%E9%80%85%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.13.1.1.</span> <span class="toc-text">1.1 邂逅红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.13.1.2.</span> <span class="toc-text">1.2 红黑树的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%9B%BE%E4%BE%8B"><span class="toc-number">1.13.1.3.</span> <span class="toc-text">1.3 红黑树的图例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%9B%B8%E5%AF%B9%E5%B9%B3%E8%A1%A1"><span class="toc-number">1.13.2.</span> <span class="toc-text">2. 红黑树的相对平衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF"><span class="toc-number">1.13.3.</span> <span class="toc-text">3. 红黑树的代码思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.13.4.</span> <span class="toc-text">4. 红黑树的性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.13.5.</span> <span class="toc-text">5. AVL树和红黑树的选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript%E7%AE%97%E6%B3%95%E5%92%8C%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">JavaScript算法和面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88Sorting-algorithm%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">（一）排序算法（Sorting algorithm）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 排序算法的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%BA%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 人和计算机区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%A6%82%E4%BD%95%E6%8E%92%E5%BA%8F%EF%BC%9F-%E4%BA%BA%E6%9D%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">2.1 如何排序？ 人来排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%A6%82%E4%BD%95%E6%8E%92%E5%BA%8F%EF%BC%9F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9D%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">2.2 如何排序？ 计算机来排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. 常见的排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E8%AE%A4%E8%AF%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">3.1 认识排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">3.2 常见的排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">3.3 排序算法的时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF"><span class="toc-number">2.1.4.</span> <span class="toc-text">4. 排序的学习思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.5.</span> <span class="toc-text">5. 冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">5.1 冒泡排序的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">5.2 冒泡排序的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9B%BE%E8%A7%A3"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">5.3 冒泡排序的图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.5.4.</span> <span class="toc-text">5.4 冒泡排序的代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.5.5.</span> <span class="toc-text">5.5 冒泡排序的时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.5.6.</span> <span class="toc-text">5.6 冒泡排序的总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.6.</span> <span class="toc-text">6. 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">6.1 选择排序的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">6.2 选择排序的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9B%BE%E8%A7%A3"><span class="toc-number">2.1.6.3.</span> <span class="toc-text">6.3 选择排序的图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.6.4.</span> <span class="toc-text">6.4 选择排序的代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.6.5.</span> <span class="toc-text">6.5 选择排序的时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.6.6.</span> <span class="toc-text">6.6 选择排序的总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.7.</span> <span class="toc-text">7. 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.7.1.</span> <span class="toc-text">7.1 插入排序的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.7.2.</span> <span class="toc-text">7.2 插入排序的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9B%BE%E8%A7%A3"><span class="toc-number">2.1.7.3.</span> <span class="toc-text">7.3 插入排序的图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.7.4.</span> <span class="toc-text">7.4 插入排序的代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.7.5.</span> <span class="toc-text">7.5 插入排序的时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.7.6.</span> <span class="toc-text">7.6 插入排序的总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.8.</span> <span class="toc-text">8. 归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.8.1.</span> <span class="toc-text">8.1 归并排序的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">2.1.8.2.</span> <span class="toc-text">8.2 归并排序的思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9B%BE%E8%A7%A3"><span class="toc-number">2.1.8.3.</span> <span class="toc-text">8.3 归并排序的图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.8.4.</span> <span class="toc-text">8.4 归并排序的代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.8.5.</span> <span class="toc-text">8.5 归并排序的时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.8.6.</span> <span class="toc-text">8.6 归并排序的总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.9.</span> <span class="toc-text">9. 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.9.1.</span> <span class="toc-text">9.1 快速排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.9.2.</span> <span class="toc-text">9.2 快速排序的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">2.1.9.3.</span> <span class="toc-text">9.3 快速排序的思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9B%BE%E8%A7%A3"><span class="toc-number">2.1.9.4.</span> <span class="toc-text">9.4 快速排序的图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.9.5.</span> <span class="toc-text">9.5 快速排序的代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-6-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.1.9.6.</span> <span class="toc-text">9.6 快速排序的复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-7-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.9.7.</span> <span class="toc-text">9.7 快速排序的总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.10.</span> <span class="toc-text">10. 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.10.1.</span> <span class="toc-text">10.1 堆排序的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">2.1.10.2.</span> <span class="toc-text">10.2 堆排序的思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9B%BE%E8%A7%A3"><span class="toc-number">2.1.10.3.</span> <span class="toc-text">10.3 堆排序的图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.10.4.</span> <span class="toc-text">10.4 堆排序的代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.1.10.5.</span> <span class="toc-text">10.5 堆排序的复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.10.6.</span> <span class="toc-text">10.6 堆排序的总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.11.</span> <span class="toc-text">11. 希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.11.1.</span> <span class="toc-text">11.1 希尔排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9B%9E%E9%A1%BE"><span class="toc-number">2.1.11.2.</span> <span class="toc-text">11.2 插入排序的回顾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">2.1.11.3.</span> <span class="toc-text">11.3 希尔排序的思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%A2%9E%E9%87%8F"><span class="toc-number">2.1.11.4.</span> <span class="toc-text">11.4 希尔排序的增量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%B8%8C%E5%B0%94%E5%A2%9E%E9%87%8F%EF%BC%89"><span class="toc-number">2.1.11.5.</span> <span class="toc-text">11.5 希尔排序的代码实现（希尔增量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.11.6.</span> <span class="toc-text">11.6 希尔排序的复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88Hibbard-%E5%A2%9E%E9%87%8F%EF%BC%89"><span class="toc-number">2.1.11.7.</span> <span class="toc-text">11.7 希尔排序的代码实现（Hibbard 增量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-8-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.11.8.</span> <span class="toc-text">11.8 希尔排序的总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%B5%8B%E8%AF%95%E5%A4%9A%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.12.</span> <span class="toc-text">12. 测试多种排序算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88Dynamic-programming%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">（二）动态规划（Dynamic programming）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A4%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. 认识动态规划DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E8%AE%A4%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">1.1 认识动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">1.2 动态规划的解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%91%A2%EF%BC%9F"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">1.3 如何开始动态规划呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%B1%82%E8%A7%A3"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. 斐波那契数列求解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E2%80%93-%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A3"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">2.1 斐波那契数列 – 递归求解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E2%80%93-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2.2 斐波那契数列 – 记忆化搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E2%80%93-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">2.3 斐波那契数列 – 动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E2%80%93-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%EF%BC%89"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">2.4 斐波那契数列 – 动态规划（状态压缩）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E7%BB%9F%E4%B8%80%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">2.5 动态规划的统一解题步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%B3%E5%8F%B0%E9%98%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3"><span class="toc-number">2.2.3.</span> <span class="toc-text">3. 跳台阶的问题求解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E8%B7%B3%E5%8F%B0%E9%98%B6%EF%BC%89"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">3.1 爬楼梯（跳台阶）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E8%B7%B3%E5%8F%B0%E9%98%B6-%E2%80%93-%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">3.2 跳台阶 – 暴力递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E8%B7%B3%E5%8F%B0%E9%98%B6-%E2%80%93-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">3.3 跳台阶 – 记忆化搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E8%B7%B3%E5%8F%B0%E9%98%B6-%E2%80%93-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">3.4 跳台阶 – 动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E8%B7%B3%E5%8F%B0%E9%98%B6-%E2%80%93-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89"><span class="toc-number">2.2.3.5.</span> <span class="toc-text">3.5 跳台阶 – 滚动数组（滑动窗口）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">2.2.4.</span> <span class="toc-text">4. 股票买卖的最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">4.1 买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">4.2 动态规划的实现思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">4.3 动态规划 - 状态压缩</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C"><span class="toc-number">2.2.5.</span> <span class="toc-text">5. 求最大子数组的和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">5.1 最大子数组和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">5.2 动态规划的实现思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.2.5.3.</span> <span class="toc-text">5.3 状态压缩的优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">2.2.6.</span> <span class="toc-text">6. 不同的路径的数量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">6.1 不同路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">6.2 动态规划的实现思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E7%9A%84%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%88%E8%AF%BE%E4%B8%8B%E6%89%A9%E5%B1%95%EF%BC%89"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">6.3 不同路径的组合数学（课下扩展）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">2.2.7.</span> <span class="toc-text">7. 礼物的最大价值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.2.8.</span> <span class="toc-text">8. 最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.2.8.1.</span> <span class="toc-text">8.1 最长递增子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-%E2%80%93-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.2.8.2.</span> <span class="toc-text">8.2 最长递增子序列 – 动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E8%B4%AA%E5%BF%83-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%80%9D%E8%80%83%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.8.3.</span> <span class="toc-text">8.3 贪心 + 二分查找的思考过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88Leetcode%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">（三）大厂面试题（Leetcode）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">1. 字符串大厂面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">1.1 最长公共前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">1.2 无重复字符的最长子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">1.3 最长回文子串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%88%E7%BB%93%E6%9E%84%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.3.2.</span> <span class="toc-text">2. 栈结构大厂面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">2.1 二叉树展开为链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">2.2 逆波兰表达式求值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">2.3 用两个栈实现队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.3.3.</span> <span class="toc-text">3. 队列结构大厂面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">3.1 滑动窗口最大值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.3.4.</span> <span class="toc-text">4. 链表结构大厂面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">4.1 删除链表的倒数第 N 个结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">4.2 两两交换链表中的节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.3.5.</span> <span class="toc-text">5. 二叉树大厂面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">5.1 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">5.2 二叉树的中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">5.3 二叉树的后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.5.4.</span> <span class="toc-text">5.4 二叉树的层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.5.5.</span> <span class="toc-text">5.5 翻转二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">2.3.5.6.</span> <span class="toc-text">5.6 二叉树中的最大路径和</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Mr.储</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-api-ten-lac.vercel.app',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-api-ten-lac.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
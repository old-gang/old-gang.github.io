<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>学习TypeScript | Mr.储</title><meta name="keywords" content="web前端"><meta name="author" content="Mr.储"><meta name="copyright" content="Mr.储"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TypeScriptTypeScript 介绍 TypeScript 官方文档  TypeScript 简称：TS，是 JavaScript 的超集，简单来说就是：JavaScript 有的 TypeScript 都有    TypeScript 实际上就是 JavaScript(弱类型) + Type (类型) , 即为 JS 添加类型支持，如图 12&#x2F;&#x2F; 为username声明明确的变量类型">
<meta property="og:type" content="article">
<meta property="og:title" content="学习TypeScript">
<meta property="og:url" content="https://old-gang.github.io/post/3a1358b6.html">
<meta property="og:site_name" content="Mr.储">
<meta property="og:description" content="TypeScriptTypeScript 介绍 TypeScript 官方文档  TypeScript 简称：TS，是 JavaScript 的超集，简单来说就是：JavaScript 有的 TypeScript 都有    TypeScript 实际上就是 JavaScript(弱类型) + Type (类型) , 即为 JS 添加类型支持，如图 12&#x2F;&#x2F; 为username声明明确的变量类型">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-23T09:06:41.000Z">
<meta property="article:modified_time" content="2023-04-09T09:20:14.090Z">
<meta property="article:author" content="Mr.储">
<meta property="article:tag" content="web前端">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://old-gang.github.io/post/3a1358b6"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '学习TypeScript',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-09 17:20:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Mr.储</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">学习TypeScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">更新于</span><time datetime="2023-04-09T09:20:14.090Z" title="更新于 2023-04-09 17:20:14">2023-04-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="学习TypeScript"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h3 id="TypeScript-介绍"><a href="#TypeScript-介绍" class="headerlink" title="TypeScript 介绍"></a>TypeScript 介绍</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/">TypeScript 官方文档</a></p>
</li>
<li><p><strong>TypeScript 简称：TS，是 JavaScript 的超集</strong>，简单来说就是：JavaScript 有的 TypeScript 都有</p>
</li>
</ul>
<p><img src="https://chu-image-host.oss-cn-beijing.aliyuncs.com/typora/ts.png" alt="ts"></p>
<p>TypeScript 实际上就是 <strong>JavaScript(弱类型) + Type (类型)</strong> , 即为 JS 添加类型支持，如图</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为username声明明确的变量类型 字符串类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">username</span>: <span class="built_in">string</span> = <span class="string">&#x27;John&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript-为什么要为-JS-添加类型支持"><a href="#TypeScript-为什么要为-JS-添加类型支持" class="headerlink" title="TypeScript 为什么要为 JS 添加类型支持"></a>TypeScript 为什么要为 JS 添加类型支持</h3><blockquote>
<p>Javascript 类型系统存在先天缺陷，我们在写代码时经常遇到类型错误（Uncaught TypeError）</p>
</blockquote>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA1wAAABgCAYAAAAJtXOPAAASbElEQVR4nO3dbWxc1Z3H8Z8n6aKxhBoYC5oNWBgbGbLtVhvywMqpQhYsEUWo3ZqALFnCCs2SioStClKyu6hM2BdLdlHJlkRrKQWMNFJV0fTFoghap+tG9UgxeXgTBJli4ypS6kIzkaOtPGoLzL7478m9cz0Pdx6ux558P5Jlj2fm3nPPnDv3/O/533Pb8vl8XgAAAACAhlupDz5odhkAAAAAoCW15efmGOECAAAAgAjEml0AAAAAAGhVBFwAAAAAEBECLgAAAACICAEXAAAAAESk7b3H/j7/WeZDSdKKu+9Sx47HdOsDDzW5WAAAAACw/LX9/m+3FsxS+Nnnn+mTjri6D/6H2m/rbFa5AAAAAGDZW5BSuCK2Qquv/Ekz//LPzSgPAADNlctJzzwjZTLNLsn1ifoH0GJi7U88fu1B+xOPyz3u+Ph/9fuJk9GtOZm0H790WnrwQSmbjW69jZTLSbt2SalUdOtIpaRVq4r/RLneoGRy4fp37bI6aDX+bf3KVzjoN8Jy27cXWzpt7S2dbnZJyvN/Hy3mvpHJ2PrcuoP1lM1a+2rEd2MuJz39tHTjjVJvb33lrlep/WYptJd6y+COn8WOI/G49M1vSk89xXcGgJYQc0GWP9iSpBVtMc399/GqFjb1m9/o7fHxRpdx+ctkpAceqK1zMjQkzc3Zz3e+Yz/u8dBQ48tajn/dc3PS0aN2YGwlyaQ0MSFNT9s2vvuuND6+9ALLYicssDSlUq1xciKdlg4elCYnbd84f37xApLeXlvf9LS0fv3C5xMJ6cQJaXZW2rGjvnUdO2a/9+2rbzmtrqNDuv322t8fj0tr1pR+vq9P2rxZ2r9/+e87AK57K+dffeNaoDX/6huaf/WNa09+/uFHVS3sw5kZvfP/Ade2rVsbV0pgMaTT1tn6yU+sAydZp2D37uaWC62vr8+CmKVsZka67z6ps4Wv7c1mpdFR6cCBpX0yaam0l1tuscCrHmvWlK7rvXulxx6Tzp2zbQaAZarstPCxFV+oaaHvjI/rH7/3vfpGu7JZ6dFHvZSKUikswVSTYPqFS3twP/5RgWLpGsGRg2CqSrGUlT/8wc5gB9NdXNk2bZLOnrXfjU4HTKcX1ksw1TGVsm3ypwMFz7gH67Ha8rl1+OvbX4+ZjH2ev/61V5/VfFaStw3+7QiW0217LelrY2PSwED5s/Zu+cXSqtxzP/958fbgryf/NhRLrS1VDy7d8dAh+ynV7ssJ81lUag/l6iFY1lWrpO3bw5XNXweuLkttY6X2UKmMjdgvypXB/W/PHunNN6XVqxeWo1KqXJgyBLezljSvYOpyI9OVK+0XxVKz68kKqMeFC1JXl7Ru3cLnlsJ+U6m9FNtvgm06zDEtjN5e6Re/KP59GSxnqRHeSiP1iYSNco2NVVc2AFhiYu1PPH5tZCuYVviFL3+5roW/Mz5eX9B15YqNLhw5YmfzBgakl17yvrgzGemRR6SRES/N7cQJb3Qim5Xee897bnLSRjDCdkZyOUtn2LzZ3u/SVQ4fLkzn279fGh621xw+LD3/vK3bpcFMTkr33uul4jQyHXDdOjvrfPq0979z5+xs9LZt3v8OHZKmpmzd09P2vEudCdbj9LSd5Q0egP0d/GKBwqFDtu3T0/YzMVFY1x98IG3caGeP5+asXl95xZ5Lp+2zdnU0OytdurRwHXv2SCdP2vOTk9LrrzemU5bL2foq+dnPpGef9T7HYJuUrFNWrD04/s8i2CYr1UMyWTy91N/uwyj3WYRpD5XqIZm0cs/O2vPHq0tPlmRByptv2jJmZ60j7MrolGoP7jqcNWu8Mo6M2Hb520sj9otSZXDpwIcP2/eGqwt/Kl6lVLkwZTh4sHA75+aqGw1IpWyZLo3Wvw5/gBAMHKtNaa20XywFY2PlR1yavd9Uai9S4X4TbNNhj2n1yOUsDfvdd4vvV9Xq77c6Ia0QwDIWc8HWgnTCtphWff3hulfwzvi4XnnttdoXMDLidU76++2Le37eHv/oR3bAKtW5SCSkJ5/0Hnd2WnAyMxNu3fPz0tWr0uCgPY7HpS1brIPmd/iwV4YNG6R8Xrp8Odw66uXKdPKkd0AaG7MDqr8DvmOHd01CImEdH7cdp08X1qN73r9MaeE1XMEO1/r10o9/bO9vb7cOcrCujx/31tPT4x1Ig6NL8biVYWKisFO2Y4f0gx/Y8x0dUltbYV3H43ZtWbUBSFjf+EbhGd1gm5Qqtwf/ZxFsk2HroRFKfRZh2kO5eshmpffft45lPWlZ69dLL75oy3D1EOx4lWoPFy9KH33k7btS8ZMTjdgvKrXJeoQtQ63tI5ezZQ0Pe/uLfx2S7U/FAsdqA65mfk+G4U669PSUf91y2m/cCJFr02GPafVwadhuG4JlqEXwOxYAlpmYP8jyB125r35Vq/7mr+tewUNbt2rvzp11L2eBsAdHf3rG6tV25i+s9nbpi1+0wE7y8vsrrXOxbdtmB9GLF72Dtr+jWYrrKExNLRy92rOn+nJ0dVmdSV7g4z9rGsz3Hxqy17iyBOu1o2Nhp8x/9tldKN+I3P5KF3A7wVSZalPlyinVpovVQ71KfRbxeLj2UK4eLl+ObuQi2PEq1R4uX7bAx7+N7jOu1PGrdr+Iqk1K4cqQTFqHtru7+tlD5+etTru6Cv/vTpbQyS20XPcbZ7GOacEU1UOHGrt8AFhmFlzD9XlshXLrN2r1MzV0uH167rhDe3furH7yDH+nvZwwnadUqnDGuVpnsHIH0e5u69gs9uyAlSQS0tq1dob1wgX7u9LsYVNTXkexp2fh6NVizkJY6rMs1mmOUk9P+ZGCbNamKd63z6ujWlLlSllK9VCuPURdD6W4wCDM90OxIDXMSZqltF9I4cvgUk1nZ+3xwYPhll9qJLqaum4VYQPyUpbqflNMlMe04GyWLgW6HtdbWwTQcmJ/7t+m+du6lLutS3/qf0jxf/833f6v/6S/6Li55oXu3blTe3fuVM8dd5R+UX+/5XS76ymyWcvp37IlfGemv98OHKWuyZqaKvyiPnascIQr2ClLpQrPxF28aCNHLmCrJY3GraetrTCVqdEGB+3akZdfrjy6lclYXfT32+MNG6q7ti0KpdqDP9UpjHomzXDXvPmnIc7lLK01l7N28vHH3miAK2Mjha2HSsFhPSq1h0r10Nkp3Xmn197T6fpHAt2Z+LDfD64M7ky+ZNsUvLbRL6r9oqtLOnXKvk+qVW0Zwo7U+l+/ZYvVrWtLmYx1mIeHm3PCxQUmn3wS/bqD+vtr36+W4n4T1KhjWjkzM9Ktt3oniNLp+ka4Kl1XBwDLQGz1d/9BnUe/r9uPfl9/+d0ndeNf3VXzwu7q6tJ/vvBC+UDL6euzM31u5r7ubjvAV3Omra/PzhBu3158JrO9e+3L313kPTVVeKatt1f62te8MkxN2XUG/ufXrvVSdSrNuFRKImEXWe/ZE80sYJJ3sL7ppuLTNvsvdn/kEZv63KU99fba4927y89aFUyXaeS9hRrRHuqVSEhvvWV/u7rauFHautUO9r29VkbX3u6/3z7Tm2s/ObFA2HoYGLCOm2ubjbypcKX2UKke4nG7DuXgQXv++edtP622ns6c8bavu9v2obDtIR6361gmJrzyj4561xg6jdgvKunrs8/Lfab+melc6lV3t22vq1N/XZcrQ7EZCi9dqu4eUkNDhSmJmzbZSYbFnIZ7cNCCFdeeDhyQ7rnHe75SPbmZPV3auPuurTaYuPtu+33hQvXbsBj7TaV6CFPGRhzTygl+N42O2r5Yi2zW9mF3EgQAlqm2/NxcvtmFWLLSaTvo+Ttp2azdF2Sxg4FK3KxsW7YsLFcqZRduuwv7gaWu2L7XaOwXKMbN2hhl22uW5XRMkwpnZwWAZazsfbiue8VmMwymhSwVbsrdgYHmlgMAljM3QhO8BUErWE7HtHTaRrf27m12SQCgbiubXYAlbWjI0gy7uwv/758WuNmSSUv1c1Oyc6YeAGoXj9uo53PPWepnpQmIlpPlcEyTLGPjpz+1e3C22igjgOsSKYUAAAAAEBFSCgEAAAAgIgRcAAAAABARAi4AAAAAiAgBFwAAAABEhIALy1s2azf9refGv+6mqcGb0gIAAAB1uv4CrkxGeuABOtWtIJ22G3Zu21b7MpJJuxHo9LQ0NyedP99a00ADAACgqa6/gKuRcjlp1y4plWp2SZYfNzKVTtf+/rEx6a23pFtvrW0ZmYz0/vt2/zLu9QIAAIAItF7AlUx66WGrVnkd+kzG0sU2bZLOnrXf7jW1BEzZrPTww9KaNXYzyTBlkGxdyaT9ds8nk4Xv96e4BZ/PZqVHH7XXPPjgwjS4dHphWpw/MHTvHxmx9+7a5f3tX0+lMgSDJVcef1pfsB789ZxI2E0td+8uX/+uHMHXJBK2/Eo3enbbXizl8PRpae1agi0AAABEprUCrnRa6u+31LC5OenwYUsXy2YtTez8eWlyUrr3XvvtXhcMmMKsp7tbGh4uHiyVKoNz6JA0NWXPT05Kx455wUs6bUGIK9/srHTpUuF6rlyx1xw5Yq8ZGJBeesmCi3XrpPvus2DCOXdOmpnxUu+uXLGgc3xcOnVK+t3vpOPHpYkJK2eYMlSSStl7ZmdL13Nvr/TLX0qjoxYU5XLhl98IU1PSl75k6y4V/AIAAAB1aK2Aq6/PfpwNG6R8Xrp8uXHrSKW8YKRYoBamDDt2SPv22d+dnRYgzczY47ExC6DcdUTxuAV2LhhyRka81/T32/vn5+31W7ZIJ096AczYmLR5c+FIzvCw1N4u3XKLNDgodXRIN99cXRkqOXVKunix/GsSCUsLlGzEMLj8vr7agmInHpeOHpVOnCg+knXkiPTss7aO6WnbRlJEAQAA0CCtFXC5VDc3WrFpk/TJJ41d/uhodGXI5WxUqKen8P8dHdUFjtu2SVevWrCTzdp1SoODi1uGoSELKl3qZrlZBONxS808c0Z6++1wy2+Uffu8wDKRsMDSH6wCAAAAdWidgCuXk/bvt5Ecl8I2OWkjOI2SSNhIyciIBRLBkZB6y+ACj6mpwv9fviy1tVnQE7aca9daWuGFC/Z32Jn3GlUGyYIuVw+bN1vdBAMZF6C69MNaR7Jq0dOzcDsl2/5K14YBAAAAIbROwDU/b2l1bmQml7PrmoKjSx0dFjj4r3GqVl+fpZ+NjhZe8xO2DOX099s1XW7Si2zWrgEbHq5ucofBQen116WXXw4/uhW2DO3tUleXlwaZyViaZTnBETP3vvvvt+UePVo8yCk1aUZY5SbN2LBB+tWvCrdzdNS2HwAAAGiA1gm4EgnpwAFpzx7roK9eLW3fLt1zT/nX1dqZd9ceXbrkvT9sGcrp6ytMxXOTc1Q78tPZKd15p3TTTfZ3NSqVwV3T5bbzqads1M9dAyYtnKFwdFR68UUvqMpmvffVMqrlAqlVq6wcZ85YOau5cXFvr/TCC4XbeeBA4TV4AAAAQB3a8nNz+WYXAhHI5aSnn7YJNBYzTQ8AAADANa0zwoVCx47Z74GB5pYDAAAAuI4RcLUal8oXTOEDAAAAsOhIKQQAAACAiDDCBQAAAAARWanf/rbZZQAAAACAltSWz+dJKQQAAACACJBSCAAAAAARIeACAAAAgIgQcAEAAABARAi4AAAAACAiBFwAAAAAEBECLgAAAACISOzczKfNLgMAAAAAtKTYt1+b19H/+WOzywEAAAAALScmST8c/yNBFwAAAAA0WOy/drZLIugCAAAAgEaLretaKYIuAAAAAGi8mCSt61qpb229QZIFXUykAQAAAAD1i0nSuZlP9cNxG9n61tYbtK5rZVMLBQAAAACtIHZu5lN9+7V5SRZs7fq7G5pcJAAAAABoDW0bn7ualwi2AAAAAKDRYhLBFgAAAABEoe3sR3/Oc80WAAAAADReWz6fzze7EAAAAADQimLNLgAAAAAAtCoCLgAAAACICAEXAAAAAESEgAsAAAAAIkLABQAAAAARIeACAAAAgIgQcAEAAABARAi4AAAAACAiBFwAAAAAEBECLgAAAACICAEXAAAAAESEgAsAAAAAIkLABQAAAAARIeACAAAAgIgQcAEAAABARAi4AAAAACAiBFwAAAAAEBECLgAAAACICAEXAAAAAESEgAsAAAAAIkLABQAAAAARIeACAAAAgIgQcAEAAABARAi4AAAAACAiBFwAAAAAEBECLgAAAACICAEXAAAAAESEgAsAAAAAIkLABQAAAAARIeACAAAAgIgQcAEAAABARAi4AAAAACAiBFwAAAAAEJH/A4ykV+xuPUlEAAAAAElFTkSuQmCC" alt="image-20211026153734187"></p>
<p>这类错误的出现导致项目开发完成上线之后，要投入大量的精力和时间去测试，找 bug，改 bug，对于开发效率是一种降低。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为什么 JS 在开发时不能提前<strong>预知，预防</strong>这些错误呢？</p>
<ul>
<li>因为 Javascript 属于<strong>动态类型</strong>的编程语言，动态类型最大的特点就是它只能在<strong>代码执行期间</strong>做类型的相关检查，所以往往你发现问题的时候，已经晚了。</li>
</ul>
<p>TS 能提前预防这些错误吗？</p>
<ul>
<li><strong>可以</strong>。 TypeScript 属于<strong>静态类型</strong>的编程语言。也就是代码会先通过<strong>编译</strong>，然后运行，编译不通过的，自然暴露了我们代码中的问题。</li>
</ul>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>更早的发现错误，减少找 Bug，改 Bug，提升开发效率。</li>
<li>程序中随时出现代码提示，随时随地的安全感，增强的开发体验。</li>
<li>强大的类型系统提高代码可维护性，重构代码更容易。</li>
<li>支持最新的 ECMAScript 语法，优先体验最新的语法，让你走上前端技术最前沿。</li>
<li>TS 的类型推断机制，不需要在每个地方都标注类型，降低学习负担，除此之外，Vue3 源码使用 TS 重写，Angular 默认支持 TS，React 于 TS 完美配合。</li>
</ul>
<p><strong>当下最主流的开发技术栈</strong></p>
<p>Vue3 + TS</p>
<p>Reack Hooks + TS</p>
<h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><ul>
<li>安装编译 TS 的工具包</li>
<li>编译运行 TS 代码</li>
<li>简化运行 TS 的步骤</li>
</ul>
<h3 id="安装编译-TS-的依赖"><a href="#安装编译-TS-的依赖" class="headerlink" title="安装编译 TS 的依赖"></a>安装编译 TS 的依赖</h3><p>为什么要安装依赖？</p>
<ul>
<li>Nodejs&#x2F;浏览器 只认识 JavaScript 代码，不识 TS 代码，需要先将 TS 代码转化为 JS 代码，才可以运行。</li>
</ul>
<p>安装命令</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -g typescript</span><br></pre></td></tr></table></figure>

<p>验证是否安装成功</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc -v</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tsc 为关键字</p>
</blockquote>
<p>运行流程图</p>
<p><img src="https://chu-image-host.oss-cn-beijing.aliyuncs.com/typora/%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="运行流程图"></p>
<h3 id="编译运行-ts-代码"><a href="#编译运行-ts-代码" class="headerlink" title="编译运行 ts 代码"></a>编译运行 ts 代码</h3><ol>
<li>创建一个 hello.ts 文件 （TS 的文件的后缀名为.ts）</li>
<li>将 TS 编译为 JS，在终端编译命令 <strong>tsc hello.ts</strong> （此时，同级目录会出现一个同名 JS 文件）</li>
<li>执行 JS 代码，在终端输入命令 <strong>node hello.js</strong>，使用node运行代码</li>
</ol>
<p><img src="https://chu-image-host.oss-cn-beijing.aliyuncs.com/typora/image-20211027122824443.2014ed6b.png" alt="image-20211027122824443.2014ed6b"></p>
<h3 id="使用-ts-node-简化运行-TS-的步骤"><a href="#使用-ts-node-简化运行-TS-的步骤" class="headerlink" title="使用 ts-node 简化运行 TS 的步骤"></a>使用 ts-node 简化运行 TS 的步骤</h3><p>通过上面的描述，我们发现运行 TS 代码需要连续的执行两个命令，有些繁琐，可以使用**<code>ts-node</code>**进行简化</p>
<p>安装命令</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -g ts-node</span><br></pre></td></tr></table></figure>

<p>**<code>ts-node</code>**包提供了 ts-node 命令，相当于前面两个命令的合并， 接下来就可以直接采用 命令执行运行 ts 文件</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ts-node hello.<span class="property">ts</span></span><br></pre></td></tr></table></figure>

<p>OK， 接下来我们就可以愉快的来学习 TypeScript 了</p>
<p>注意： 我们在运行过程中，可能会遇到如图的问题</p>
<p><img src="https://chu-image-host.oss-cn-beijing.aliyuncs.com/typora/ts-node%E5%BC%82%E5%B8%B8.png" alt="ts-node异常"></p>
<p>这个问题是因为当前的语法中 es6 的配置没有，需要我们用一个命令来进行设置</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --init # 初始化一个配置 此配置会给我们加一个es6的指向，错误就不再有了</span><br></pre></td></tr></table></figure>

<h3 id="解决两个-ts-文件之间的变量名冲突"><a href="#解决两个-ts-文件之间的变量名冲突" class="headerlink" title="解决两个 ts 文件之间的变量名冲突"></a>解决两个 ts 文件之间的变量名冲突</h3><p>问题：在非模块化环境下，TS 会把 .ts 文件中声明的变量当做全局变量</p>
<p>所以，当两个 .ts 文件中声明的变量名称相同，并且在 VSCode 中同时打开这两个文件时，VSCode 会提示报错</p>
<p>虽然，不会影响代码的运行。但看到报错会让人感觉不舒服，所以，只要让 .ts 文件中的代 码变为模块化环境即可</p>
<p>操作方式：<strong>在 .ts 文件中添加 export {}</strong></p>
<p>解释 1：当 TS 看到 export 这样的模块化语法后，就会将该文件当做模块来解析，此时，再声明的变量就是该模块中的局部变量了</p>
<p>解释 2：export 不需要导出任何内容，该代码的作用仅仅是为了让 TS 知道这是模块化环境</p>
<h1 id="TypeScript-常用类型"><a href="#TypeScript-常用类型" class="headerlink" title="TypeScript 常用类型"></a>TypeScript 常用类型</h1><p>TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：<strong>类型系统</strong></p>
<p><strong>JS 有类型</strong>（比如，number&#x2F;string 等），但是 <strong>JS 不会检查变量的类型是否发生变化</strong>，而 TS 会检查</p>
<p>TypeScript 类型系统的主要优势：<strong>可以显示标记出代码中的意外行为，从而降低了发生错误的可能性</strong></p>
<h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>示例代码</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：代码中<code>:number</code>就是类型注解</p>
</blockquote>
<p><strong>类型注解约束了只能给该变量赋值该类型的值</strong></p>
<p>错误演示</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误原因：将 string 类型的值赋值给了 number 类型的变量，类型不一致</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="string">&#x27;18&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="常用基础类型"><a href="#常用基础类型" class="headerlink" title="常用基础类型"></a>常用基础类型</h2><p>可以将 TS 中的常用基础类型分为两类</p>
<ol>
<li>JavaScript 已有类型</li>
</ol>
<ul>
<li>原始类型： <strong>number&#x2F;string&#x2F;boolean&#x2F;null&#x2F;undefined&#x2F;symbol</strong></li>
<li>对象类型：<strong>object</strong>(数组、对象、函数等)</li>
</ul>
<ol start="2">
<li>TypeScript 新增类型</li>
</ol>
<ul>
<li>联合类型、自定义类型（类型别名）、接口、元祖、字面量类型、枚举、void、any 等</li>
</ul>
<blockquote>
<p>注意：原始类型在 TS 和 JS 中写法一致， 对象类型在 TS 中更加细化，每个具体对象都有自己的类型语法</p>
</blockquote>
<h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p><strong>number&#x2F;string&#x2F;boolean&#x2F;null&#x2F;undefined&#x2F;symbol</strong></p>
<blockquote>
<p>特点：可完全按照 JavaScript 中的名称来书写</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">username</span>: <span class="built_in">string</span> = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">isMerry</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">unique</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;shuiruohanyu&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// null 和 undefined类型的值，值能为 null 和 undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">nullType</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">undefinedType</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>数组两种写法</p>
<ol>
<li><code>类型[]</code>写法， 如</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">userList</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tony&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">peopleList</span>: <span class="built_in">object</span>[] = [&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;];</span><br></pre></td></tr></table></figure>

<ol>
<li>Array&lt;类型&gt;写法， 如</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">user2List</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tony&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">people2List</span>: <span class="title class_">Array</span>&lt;<span class="built_in">object</span>&gt; = [&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;];</span><br></pre></td></tr></table></figure>

<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><blockquote>
<p>组中既有 number 类型，又有 string 类型，这个数组的类型应该如何写?</p>
</blockquote>
<p>可以用<code>|</code>(竖线)分割多个类型， 如</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">str = <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果数组中可以是字符串或者数字，则可以这么写</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;张三&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;张三&#x27;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><blockquote>
<p>既满足a类型也满足b类型</p>
</blockquote>
<p>可以用<code>&amp;</code>(竖线)分割多个类型，通常是多个对象的交叉， 如</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Ikun</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Icoder</span> &#123;</span><br><span class="line">  <span class="attr">coder</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="title class_">Ikun</span> &amp; <span class="title class_">Icoder</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">coder</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><blockquote>
<p>当一个复杂类型或者联合类型过多或者被频繁使用时，可以通过类型别名来简化该类型的使用</p>
</blockquote>
<p>用法：<code>type</code> 名称 &#x3D; 具体类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CustomArray</span> = <span class="title class_">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="title class_">CustomArray</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;张三&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>以上代码中，<code>type</code>作为创建自定义类型的关键字</p>
<ul>
<li>类型别名可以使任意合法的变量名称</li>
<li>推荐大驼峰的命名写法</li>
</ul>
<h3 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h3><p><strong>目标</strong>：能够知道 TS 中 never 类型的含义</p>
<p><strong>内容</strong>：一般用于封装框架或工具库时使用</p>
<ul>
<li><code>never</code> 类型：永远不会出现的值的类型（或永远不会发生的类型）</li>
<li><code>never </code> 类型：处理 TS 类型系统的最底层<ul>
<li>可以将 never 类型的数据，赋值给任意其他的类型；无法将任何类型（除了 never 类型自己）来分配给 never 类型</li>
<li>当遇到never类型时，表示此类型不能用，不能通过该类型来解释当下的运行环境，必须指明类型</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 函数抛出错误，就会结束函数的指向，函数不会有返回值的，这种函数的返回值就是never类型 (不存在的类型)</span><br><span class="line">let fn1 = () =&gt; &#123;</span><br><span class="line">  // 手动通过 throw 抛出一个异常（错误）</span><br><span class="line">  throw new Error(&#x27;err...&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">let n = fn1(); // n =&gt; never，表示fn1函数的返回值是一个never类型</span><br><span class="line"></span><br><span class="line">// fn2函数里面写一个死循环，不可能有返回的，永远没有结果的函数，返回值就是一个never类型的</span><br><span class="line">let fn2 = () =&gt; &#123;</span><br><span class="line">  while (true) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">let n = fn2(); // n =&gt; never</span><br><span class="line"></span><br><span class="line">// const定义一个常量，num值永远等于123，所以不可能进入if判断，n就是never类型</span><br><span class="line">const num = 123;</span><br><span class="line">if (num !== 123) &#123;</span><br><span class="line">  let n = num; // n =&gt; never</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 封装框架/工具库的时候可以使用一下never</span><br><span class="line">// 其他同时在扩展工具的时候, 对于一些没有处理的case, 可以直接报错，如果只添加了类型，没写case，会报错</span><br><span class="line">function handleMessage(message: string | number | boolean) &#123;</span><br><span class="line">  switch (typeof message) &#123;</span><br><span class="line">    case &quot;string&quot;:</span><br><span class="line">      console.log(message.length)</span><br><span class="line">      break</span><br><span class="line">    case &quot;number&quot;:</span><br><span class="line">      console.log(message)</span><br><span class="line">      break</span><br><span class="line">    case &quot;boolean&quot;:</span><br><span class="line">      console.log(Number(message))</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      const check: never = message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unknown类型"><a href="#unknown类型" class="headerlink" title="unknown类型"></a>unknown类型</h3><p><strong>目标</strong>：能够知道 TS 中的 unknown 类型</p>
<p><strong>内容</strong>：</p>
<ul>
<li><code>unknown</code> 类型是类型安全的 any</li>
<li>可以把任何类型的值赋值给 unknown 类型的变量（别的类型可以赋值给unknown类型）</li>
<li>注意：不可以把unknown类型的变量 赋值给 任意类型的值 (除去unknown类型),自己可以是任意值，但是不可以给别人；</li>
<li>在使用 unknown 类型前，必须先将其设置为一个具体的类型(可以使用<code>typeof</code>进行类型校验&#x2F;缩小)，否则，无法对其进行任何操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: unknown</span><br><span class="line">e = <span class="number">10</span></span><br><span class="line">e = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">s</span>: string</span><br><span class="line">s = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line">s = e <span class="comment">//Type &#x27;unknown&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line"><span class="comment">//解决办法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> e === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  s = e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="any类型"><a href="#any类型" class="headerlink" title="any类型"></a>any类型</h3><ul>
<li>一旦设置为any类型，ts就失去了类型约束的作用</li>
<li>任何值可以赋值给any，any也可以赋值给任何值，且原有的类型也会变成any</li>
</ul>
<p>对比 any 和 unknown 类型：</p>
<ol>
<li>对于 any 类型来说，TS 不会对其进行类型检查</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 可以进行任意操作，没有安全可言</span><br><span class="line">let value: any;</span><br><span class="line">value = true;</span><br><span class="line">value = 1;</span><br><span class="line">value.length;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>unknown 类型</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let value: unknown;</span><br><span class="line">value = &#x27;abc&#x27;(</span><br><span class="line">  // 先转化为具体类型再使用</span><br><span class="line">  value as string,</span><br><span class="line">).length;</span><br><span class="line"></span><br><span class="line">// 先判断是 string 类型，再使用</span><br><span class="line">if (typeof value === &#x27;string&#x27;) &#123;</span><br><span class="line">  value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="never类型和unknown类型"><a href="#never类型和unknown类型" class="headerlink" title="never类型和unknown类型"></a>never类型和unknown类型</h3><ul>
<li>never 处理 TS 类型系统的最底层<ul>
<li>无法将任意类型的数据赋值给 never 类型</li>
<li>可以将 never 类型赋值给任意其他类型</li>
<li>理解：never 表示啥也不是，所以，无法给 never 设置任何内容</li>
<li>理解：never 处于最底层，相当于任何类型的子类型，所以，可以赋值给其他任何类型<ul>
<li>比如，’a’ 字面量就是 string 的子类型 <code>let s: string = &#39;a&#39;</code></li>
</ul>
</li>
</ul>
</li>
<li>unknown 处于 TS 类型系统的最顶层<ul>
<li>可以将任意类型的数据赋值给 unknown 类型</li>
<li>无法将 unknown 类型赋值给任意其他类型</li>
<li>简单来说：unknown 类型可以接受任意类型，但是无法赋值给其他类型</li>
<li>理解：unknown 表示不确定，不确定就可以表示任意类型，既然可以是任意类型，所以可以接受任意类型的数据</li>
<li>理解：unknown 表示不确定，不确定就可以表示任意类型，既然可以是任意类型，所以就无法赋值给一个特点的类型</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部 底部 unknown -&gt; ... -&gt; ...-&gt; never </span></span><br><span class="line"><span class="comment">// unknown 可以按照 “万物皆对象” 的方式来理解：“万物皆 unknown”</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="built_in">unknown</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以将任意类型的数据赋值给 unknown 类型</span></span><br><span class="line">u = <span class="number">1</span>;</span><br><span class="line">u = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误演示：不能将 unknown 类型赋值给其它类型的变量</span></span><br><span class="line"><span class="comment">// let a: number = u</span></span><br></pre></td></tr></table></figure>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><blockquote>
<p>除了变量，我们常见的类型指定还有针对函数的类型声明</p>
</blockquote>
<p>函数类型需要指的是 <code>函数参数</code>和<code>返回值</code>的类型，这里分为两种写法</p>
<ul>
<li>第一种： 单独指定参数，返回值类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单独指定函数返回值和函数参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定变量形式的</span></span><br><span class="line"><span class="keyword">const</span> add2 = (<span class="attr">num1</span>: <span class="built_in">number</span>, <span class="attr">num2</span>: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种， 同时指定参数和返回值</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同时指定参数和返回值</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CustomFunc</span> = <span class="function">(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">add3</span>: <span class="title class_">CustomFunc</span> = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意： 当函数作为表达式时，可以通过类似箭头函数形式的语法来为函数添加类型，这种形式<code>只适用于函数表达式</code></p>
<h4 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h4><p>当我们的函数定义为没有返回值的类型时，可用关键字<code>void</code>表示</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有返回值的函数</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CustomFunc1</span> = <span class="function">(<span class="params">num1: <span class="built_in">string</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">combinStr</span>: <span class="title class_">CustomFunc1</span> = <span class="function">() =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果一个函数没有返回值，此时，在 TS 的类型中，应该使用 <code>void</code> 类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果什么都不写 表示add4函数的类型为void</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add4</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种写法明确指定返回值为void与上方的类型相同</span></span><br><span class="line"><span class="keyword">const</span> add5 = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果指定返回值为undefined  return undefined</span></span><br><span class="line"><span class="keyword">const</span> add6 = (): <span class="function"><span class="params">undefined</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="函数可选参数"><a href="#函数可选参数" class="headerlink" title="函数可选参数"></a>函数可选参数</h4><p>当我们定义函数时，有的参数可传可不传，这种情况下，可以使用 TS 的可选参数来指定类型</p>
<p>比如，在使用数组的<code>slice</code>方法时，我们可以直接使用<code>slice()</code> 也可以传入参数 <code>slice(1)</code> 也可以<code>slice(1,3)</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> slice = (start?: <span class="built_in">number</span>, end?: <span class="built_in">number</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><code>?</code> 表示该参数或者变量可传可不传</p>
<p>注意：<strong>可选参数只能出现在参数列表的最后</strong>， 即必须参数必须在可选参数之前</p>
<h4 id="调用签名"><a href="#调用签名" class="headerlink" title="调用签名"></a>调用签名</h4><blockquote>
<p>如果我们想描述一个带有属性的函数，我们可以在一个对象类型中写一个调用签名（call signature）</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ICalcFn</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  (<span class="attr">num1</span>: <span class="built_in">number</span>, <span class="attr">num2</span>: <span class="built_in">number</span>): <span class="built_in">void</span> <span class="comment">// 使用：不是=&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calc</span>(<span class="params">calcFn: ICalcFn</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(calcFn.<span class="property">name</span>)</span><br><span class="line">  <span class="title function_">calcFn</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>在参数列表和返回的类型之间用的是 : 而不是 &#x3D;&gt;</strong></p>
<h4 id="构造签名"><a href="#构造签名" class="headerlink" title="构造签名"></a>构造签名</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (): <span class="title class_">Person</span> <span class="comment">// 前面加上new</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factory</span>(<span class="params">fn: IPerson</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title function_">fn</span>()</span><br><span class="line">  <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">factory</span>(<span class="title class_">Person</span>)</span><br></pre></td></tr></table></figure>

<h4 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h4><blockquote>
<p>需求： 在TypeScript中，如果我们编写了一个add函数，希望可以对字符串和数字类型进行相加，应该如何编写呢？</p>
</blockquote>
<ul>
<li><p>在TypeScript中，我们可以去编写不同的重载签名（<em>overload signatures</em>）来表示函数可以以不同的方式进行调用；</p>
</li>
<li><p>一般是编写两个或者以上的重载签名，再去编写一个通用的函数以及实现；</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts中函数的重载写法</span></span><br><span class="line"><span class="comment">// 1、先编写重载签名</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">arg1: <span class="built_in">number</span>, arg2: <span class="built_in">number</span></span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">arg1: <span class="built_in">string</span>, arg2: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="comment">// 2、编写通用的函数实现,通用函数不能被调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">arg1: <span class="built_in">any</span>, arg2: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="this的内置工具使用"><a href="#this的内置工具使用" class="headerlink" title="this的内置工具使用"></a>this的内置工具使用</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"><span class="variable language_">this</span>: &#123; name: <span class="built_in">string</span> &#125;, info: &#123;name: <span class="built_in">string</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, info)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooType</span> = <span class="keyword">typeof</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.ThisParameterType: 获取FooType类型中this的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooThisType</span> = <span class="title class_">ThisParameterType</span>&lt;<span class="title class_">FooType</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.OmitOmitThisParameter: 删除this参数类型, 剩余的函数类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PureFooType</span> = <span class="title class_">OmitThisParameter</span>&lt;<span class="title class_">FooType</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.ThisType: 用于绑定一个上下文的this</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IState</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IStore</span> &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="title class_">IState</span></span><br><span class="line">  <span class="attr">eating</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">store</span>: <span class="title class_">IStore</span> &amp; <span class="title class_">ThisType</span>&lt;<span class="title class_">IState</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">eating</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">running</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="property">eating</span>.<span class="title function_">call</span>(store.<span class="property">state</span>)</span><br></pre></td></tr></table></figure>

<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>JS 中的对象是由属性和方法组成的，TS 的对象类型是<strong>对象中属性和方法的描述</strong></p>
<blockquote>
<p>{} 用来指定对象中可以包含那些属性；</p>
<p>语法：{属性名：属性值，属性名：属性值}</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果有多个属性 可以换行 去掉间隔符号</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person3</span>: &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">sayHello1</span>: <span class="title class_">Function</span>;</span><br><span class="line">  <span class="title function_">sayHello2</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">sayHello3</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;王五&#x27;</span>,</span><br><span class="line">  <span class="title function_">sayHello1</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">sayHello2</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">sayHello3</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>： </p>
<ul>
<li>可是使用<code>&#123;&#125;</code>来描述对象结构<ul>
<li>{ } 里的属性必须有，不能多也不能少</li>
<li>使用<code>?</code> 表示可选属性，可写可不写</li>
<li><code>[propName:string]:any</code> ,表示任意类型的属性(propName是变量名，可以随便写)</li>
</ul>
</li>
<li>属性采用<code>属性名：类型</code>形式</li>
<li>函数可以采用 <code>方法名(): 返回值类型</code> 或者 <code>函数名: Function</code>（不指定返回值）的形式</li>
</ul>
<h4 id="使用类型别名"><a href="#使用类型别名" class="headerlink" title="使用类型别名"></a>使用类型别名</h4><p>直接使用<code>&#123;&#125;</code>会降低代码可读性，不具有辨识度，更推荐使用类型别名<code>type</code>添加对象类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PersonObj</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">sayHello</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">PersonObj</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;高大大&#x27;</span>,</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="带有参数的方法的类型"><a href="#带有参数的方法的类型" class="headerlink" title="带有参数的方法的类型"></a>带有参数的方法的类型</h4><p>如果对象中的函数带有参数，可以在函数中指定参数类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带参数的函数方法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonObj2</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="attr">start</span>: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: <span class="title class_">PersonObj2</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;高大大&#x27;</span>,</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params">start</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="箭头形式的方法类型"><a href="#箭头形式的方法类型" class="headerlink" title="箭头形式的方法类型"></a>箭头形式的方法类型</h4><blockquote>
<p>语法：(形参:类型,形参:类型,…) &#x3D;&gt; 返回值 </p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数形式定义类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">People</span> = &#123;</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="function">(<span class="params">start: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p3</span>: <span class="title class_">People</span> = &#123;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="对象可选属性"><a href="#对象可选属性" class="headerlink" title="对象可选属性"></a>对象可选属性</h4><p>对象中的若干属性，有时也是可选的，此时我们依然可以使用<code>?</code>来表示</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Config</span> = &#123;</span><br><span class="line">  method?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">url</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params">config: Config</span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="title function_">func</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;/a&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h3><p>当一个对象类型被多次使用时，一般使用接口（interface）描述对象的类型，达到复用的目的</p>
<ul>
<li>我们使用<code>interface</code>关键字来声明接口</li>
<li>接口名称推荐以<code>I</code>为开头</li>
<li>声明接口之后，直接使用接口名称作为变量的类型</li>
</ul>
<blockquote>
<p>接口后不需要分号</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口：接口后面的分号(;)可以不写、接口也可以使用?定义可选属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPeople</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">sayHello1</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">sayHello2</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">IPeople</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;老高&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="title function_">sayHello1</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">sayHello2</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="接口和自定义类型的区别"><a href="#接口和自定义类型的区别" class="headerlink" title="接口和自定义类型的区别"></a>接口和自定义类型的区别</h4><p>相同点：都可以给对象指定类型</p>
<p>不同点： 接口只能为<strong>对象</strong>指定类型， 类型别名可以为<strong>任意类型</strong>指定别名</p>
<ul>
<li>推荐用 type 来定义</li>
</ul>
<h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><ul>
<li>如果两个接口之间有相同的属性和方法，可以讲<strong>公共的属性和方法抽离出来，通过继承来实现复用</strong></li>
</ul>
<p>比如，这两个接口都有 x、y 两个属性，重复写两次，可以，但很繁琐</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更好的方式</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span> <span class="keyword">extends</span> &#123;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>extends</code>关键字实现了 Point3D 继承了 Point2D 的所有属性的定义， 同时拥有继承的属性和自身自定义的属性</p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><blockquote>
<p>元组中每个元素都有自己特性的类型，根据索引值获取到的值可以确定对应的类型</p>
</blockquote>
<p>语法：[类型，类型…] , 一般不会特别长</p>
<p>当我们想定义一个数组中具体索引位置的类型时，可以使用元祖。</p>
<blockquote>
<p>原有的数组模式只能宽泛的定义数组中的普遍类型，无法精确到位置</p>
</blockquote>
<p>元组是另一种类型的数组，它确切知道包含多少个元素，以及特定索引对应的类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">position</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">39.5427</span>, <span class="number">116.2317</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所用于定义函数的返回值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initialState: <span class="built_in">number</span></span>): [<span class="built_in">number</span>, <span class="function">(<span class="params">newValue: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>] &#123;</span><br><span class="line">  <span class="keyword">let</span> stateValue = initialState</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setValue</span>(<span class="params">newValue: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    stateValue = newValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [stateValue, setValue]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>


<h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>在 TS 中，某些没有明确指出类型的地方，<strong>TS 的类型推论机制会帮助提供类型</strong></p>
<p>也就是说，由于类型推论的存在，在某些地址类型注解可以省略不写。</p>
<ul>
<li>发生类型推论的常见场景</li>
</ul>
<ol>
<li>声明变量并初始化时</li>
<li>决定函数返回值时</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量creater_name自动被推断为 string</span></span><br><span class="line"><span class="keyword">let</span> creater_name = <span class="string">&#x27;gaoly&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值的类型被自动推断为 number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addCount</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐：<strong>能省略类型注解的地方就省略</strong>（<del>偷懒</del>，充分利用 TS 类型推论的能力，提升开发效率）</p>
<p>技巧：如果不知道类型，可以通过鼠标放在变量名称上，利用 VSCode 的提示来查看类型</p>
<h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><blockquote>
<p>下面的代码类型分别是什么？</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量类型</span></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>通过 TS 的类型推导可以得到答案</p>
<ol>
<li><p>变量 str1 的变量类型为： string</p>
</li>
<li><p>变量 str2 的变量类型为： ‘张三’</p>
</li>
</ol>
<p>解释：str1 是一个变量(let)，它的值可以是任意字符串，所以类型为：string</p>
<p>str2 是一个常量(const)，它的值不能变化只能是 ‘张三’，所以，它的类型为：”张三”</p>
<p>此时，”张三” 就是一个<strong>字面量类型</strong>，即某个特殊的字符串也可以作为 TS 中的类型</p>
<p>任意的 JS 字面量（对象，数组，数字）都可以作为类型使用</p>
<h4 id="使用场景和模式"><a href="#使用场景和模式" class="headerlink" title="使用场景和模式"></a>使用场景和模式</h4><ul>
<li>使用模式：<strong>字面量类型配合联合类型一起使用</strong></li>
<li>使用场景：用来表示一组明确的可选值列表</li>
<li>比如，在贪吃蛇游戏中，游戏的方向的可选值只能是上、下、左、右中的任意一个</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27;right&#x27;</span> | <span class="string">&#x27;up&#x27;</span> | <span class="string">&#x27;down&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义类型:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(direction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，会有类型提示：</span></span><br><span class="line"><span class="title function_">changeDirection</span>(<span class="string">&#x27;up&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>解释：参数 direction 的值只能是 up&#x2F;down&#x2F;left&#x2F;right 中的任意一个</li>
<li>优势：相比于 string 类型，使用字面量类型更加精确、严谨</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul>
<li>枚举的功能类似于<strong>字面量类型+联合类型组合</strong>的功能，也可以表示一组明确的可选值</li>
<li>枚举：定义一组命名常量。它描述一个值，该值可以是这些命名常量中的一个</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="comment">// 创建枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction2</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span>,</span><br><span class="line">  <span class="title class_">Down</span>,</span><br><span class="line">  <span class="title class_">Left</span>,</span><br><span class="line">  <span class="title class_">Right</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeDirection2</span>(<span class="params">direction: Direction2</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(direction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，需要应该传入：枚举 Direction 成员的任意一个</span></span><br><span class="line"><span class="comment">// 类似于 JS 中的对象，直接通过 点（.）语法 访问枚举的成员</span></span><br><span class="line"><span class="title function_">changeDirection2</span>(<span class="title class_">Direction2</span>.<span class="property">Up</span>);</span><br></pre></td></tr></table></figure>

<h4 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h4><ul>
<li>问题：我们把枚举成员作为了函数的实参，它的值是什么呢?</li>
<li>解释：通过将鼠标移入 Direction.Up，可以看到枚举成员 Up 的值为 0</li>
<li>注意：枚举成员是有值的，<font color="cornflowerblue"><strong>不赋值时默认为：从 0 开始自增的数值</strong></font></li>
<li>我们把枚举成员的值为数字的枚举，称为：<code>数字枚举</code></li>
<li>当然，也可以给枚举中的成员初始化值</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Down -&gt; 11、Left -&gt; 12、Right -&gt; 13</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="number">10</span>,</span><br><span class="line">  <span class="title class_">Down</span>,</span><br><span class="line">  <span class="title class_">Left</span>,</span><br><span class="line">  <span class="title class_">Right</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="number">2</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="number">4</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="number">8</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="number">16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">  <span class="title class_">Read</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">// &lt;&lt; 位移运算，实质是二进制的运算，使用程序员计算器查看结果</span></span><br><span class="line">  <span class="title class_">Write</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// 0001 -&gt; 0010  =&gt; 结果为2</span></span><br><span class="line">  foo = <span class="number">1</span> &lt;&lt; <span class="number">2</span> <span class="comment">// 0001 -&gt; 0100 =&gt; 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><ul>
<li>字符串枚举：枚举成员的值是字符串</li>
<li>注意：字符串枚举没有自增长行为，因此，<strong>字符串枚举的每个成员必须有初始值</strong></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&#x27;UP&#x27;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&#x27;DOWN&#x27;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&#x27;LEFT&#x27;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&#x27;RIGHT&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="枚举实现原理"><a href="#枚举实现原理" class="headerlink" title="枚举实现原理"></a>枚举实现原理</h4><ul>
<li>枚举是 TS 为数不多的非 JavaScript 类型级扩展(不仅仅是类型)的特性之一</li>
<li>因为：其他类型仅仅被当做类型，而枚举不仅用作类型，还提供值(枚举成员都是有值的)</li>
<li>也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，<strong>枚举类型会被编译为 JS 代码</strong></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&#x27;UP&#x27;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&#x27;DOWN&#x27;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&#x27;LEFT&#x27;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&#x27;RIGHT&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会被编译为以下 JS 代码：</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;Up&#x27;</span>] = <span class="string">&#x27;UP&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;Down&#x27;</span>] = <span class="string">&#x27;DOWN&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;Left&#x27;</span>] = <span class="string">&#x27;LEFT&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;Right&#x27;</span>] = <span class="string">&#x27;RIGHT&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || <span class="title class_">Direction</span> = &#123;&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>说明：枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表</li>
<li>一般情况下，<strong>推荐使用字面量类型+联合类型组合的方式</strong>，因为相比枚举，这种方式更加直观、简洁、高效</li>
</ul>
<h3 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h3><ul>
<li><strong>原则:不推荐使用 any</strong>!这会让 TypeScript 变为 “AnyScript”(失去 TS 类型保护的优势)</li>
<li>因为当值的类型为 any 时，可以对该值进行任意操作，并且不会有代码提示</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="built_in">any</span> = &#123; <span class="attr">x</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">bar</span> = <span class="number">100</span>;</span><br><span class="line"><span class="title function_">obj</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">n</span>: <span class="built_in">number</span> = obj;</span><br></pre></td></tr></table></figure>

<ul>
<li>解释:以上操作都不会有任何类型错误提示，即使可能存在错误</li>
<li>尽可能的避免使用 any 类型，除非临时使用 any 来“避免”书写很长、很复杂的类型</li>
<li>其他隐式具有 any 类型的情况<ol>
<li>声明变量不提供类型也不提供默认值</li>
<li>函数参数不加类型</li>
</ol>
</li>
<li>注意：因为不推荐使用 any，所以，这两种情况下都应该提供类型</li>
</ul>
<p>在项目开发中，尽量少用 any 类型</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有时候你会比 TS 更加明确一个值的类型，此时，可以使用类型断言来指定更具体的类型。 比如，</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面中一个a标签，a标签的id是link，获取这个a标签的dom元素</span></span><br><span class="line"><span class="keyword">const</span> aLink = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;link&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：该方法返回值的类型是 HTMLElement，该类型只包含所有标签公共的属性或方法，不包含 a 标签特有的 href 等属性</li>
<li>因此，这个**类型太宽泛(不具体)**，无法操作 href 等 a 标签特有的属性或方法</li>
<li>解决方式：这种情况下就需要<strong>使用类型断言指定更加具体的类型</strong></li>
<li>使用类型断言：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aLink = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;link&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLAnchorElement</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>解释:<ol>
<li>使用 <code>as</code> 关键字实现类型断言</li>
<li>关键字 as 后面的类型是一个更加具体的类型（HTMLAnchorElement 是 HTMLElement 的子类型）</li>
<li>通过类型断言，aLink 的类型变得更加具体，这样就可以访问 a 标签特有的属性或方法了</li>
<li>类型断言是主观判断，断言开发者主观认为它一定是一种确定的类型 (主观行为，会屏蔽ts的错误提示)</li>
</ol>
</li>
<li>另一种断言语法，使用 <code>&lt;类型&gt;变量</code> 语法，这种语法形式不常用知道即可:</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该语法，知道即可：在react的jsx中使用会报错</span></span><br><span class="line"><span class="keyword">const</span> aLink = &lt;<span class="title class_">HTMLAnchorElement</span>&gt;<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;link&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="断言总结"><a href="#断言总结" class="headerlink" title="断言总结"></a>断言总结</h3><ul>
<li>类型断言：变量 as 类型 (强制转化类型)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CustomObj1</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CustomObj2</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// people初始指定为CustomObj1类型，但实际是CustomObj2类型</span></span><br><span class="line"><span class="comment">// 可以使用类型断言，不然这样赋值会报错的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">people</span>: <span class="title class_">CustomObj1</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125; <span class="keyword">as</span> <span class="title class_">CustomObj2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>非空断言：变量! (变量后面跟一个感叹号!，表示主观认为变量不为空)</li>
<li>常量断言：变量 as const (表示变量是一个常量或者字面量)</li>
</ul>
<h3 id="类型缩小"><a href="#类型缩小" class="headerlink" title="类型缩小"></a>类型缩小</h3><h4 id="1、typeof"><a href="#1、typeof" class="headerlink" title="1、typeof"></a>1、typeof</h4><ul>
<li>众所周知，JS 中提供了 typeof 操作符，用来在 JS 中获取数据的类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;hello world&#x27;</span>)   <span class="comment">// .js文件 和 .ts文件里面都会输出：string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj)  <span class="comment">// .js文件 和 .ts文件里面都会输出：object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区别：如果使用了ts特有的语法，typeof会根据ts类型上下文推断出对象的具体类型</span></span><br><span class="line"><span class="comment">// typeof使用的时候，需要注意typeof是处于js环境上下文，还是处于ts环境上下文</span></span><br><span class="line"><span class="comment">// typeof定义类型的时候，出现在冒号(:)后面，获取使用type定义变量类型，此时typeof都处于ts环境上下文</span></span><br><span class="line"><span class="comment">// sayHello函数的参数：</span></span><br><span class="line"><span class="comment">// (parameter) info: &#123;</span></span><br><span class="line"><span class="comment">//   name: string;</span></span><br><span class="line"><span class="comment">//   age: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">info: <span class="keyword">typeof</span> obj</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// info的类型：</span></span><br><span class="line"><span class="comment">// type info = &#123;</span></span><br><span class="line"><span class="comment">//   name: string;</span></span><br><span class="line"><span class="comment">//   age: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">type</span> info = <span class="keyword">typeof</span> obj</span><br></pre></td></tr></table></figure>

<ul>
<li>实际上，TS 也提供了 typeof 操作符：可以在类型上下文中引用变量或属性的类型（类型查询）</li>
<li>使用场景:根据已有变量的值，获取该值的类型，来简化类型书写</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">formatPoint</span>(<span class="params">point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">formatPoint</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面a1 和 a2两种定义类型的方式是等价的</span></span><br><span class="line"><span class="keyword">type</span> a1 = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// js里面typeof一个对象，返回字符串&quot;object&quot;；</span></span><br><span class="line"><span class="comment">// 使用了ts特有的语法，使用type定义类型，这时候typeof一个对象，返回该对象的具体类型</span></span><br><span class="line"><span class="comment">// type a2 = &#123; x: number, y: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> a2 = <span class="keyword">typeof</span> p</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">formatPoint</span>(<span class="params">point: <span class="keyword">typeof</span> p</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串类型</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">type</span> a = <span class="keyword">typeof</span> str     <span class="comment">// 相当于定义：type a = string</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解释:<ol>
<li>使用 <code>typeof</code> 操作符来获取变量 p 的类型，结果与第一种（对象字面量形式的类型）相同</li>
<li>typeof 出现在<strong>类型注解的位置（参数名称的冒号后面）所处的环境就在类型上下文</strong>(区别于 JS 代码)</li>
<li>注意：typeof 只能用来查询变量或属性的类型，无法查询其他形式的类型（比如，函数调用的类型）</li>
</ol>
</li>
</ul>
<h4 id="2、平等缩小"><a href="#2、平等缩小" class="headerlink" title="2、平等缩小"></a>2、平等缩小</h4><p>我们可以使用Switch或者相等的一些运算符来表达相等性（比如&#x3D;=&#x3D;, !&#x3D;&#x3D;, &#x3D;&#x3D;, and !&#x3D; ）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&quot;left&quot;</span> | <span class="string">&quot;right&quot;</span> | <span class="string">&quot;up&quot;</span> | <span class="string">&quot;down&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">switchDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (direction === <span class="string">&quot;left&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;左:&quot;</span>, <span class="string">&quot;角色向左移动&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction === <span class="string">&quot;right&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;右:&quot;</span>, <span class="string">&quot;角色向右移动&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction === <span class="string">&quot;up&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;上:&quot;</span>, <span class="string">&quot;角色向上移动&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction === <span class="string">&quot;down&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;下:&quot;</span>, <span class="string">&quot;角色向下移动&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、instanceof"><a href="#3、instanceof" class="headerlink" title="3、instanceof"></a>3、instanceof</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printDate</span>(<span class="params">date: <span class="built_in">string</span> | <span class="built_in">Date</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (date <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getTime</span>())</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(date)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、in操作符-索引类型"><a href="#4、in操作符-索引类型" class="headerlink" title="4、in操作符 (索引类型)"></a>4、in操作符 (索引类型)</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用索引类型</span></span><br><span class="line"><span class="comment">// 什么时候使用索引类型？当对象中有什么属性，无法提前确定下来，此时，就可以使用索引类型了</span></span><br><span class="line"><span class="keyword">type</span> T = &#123;</span><br><span class="line">  <span class="comment">// [key in number] 表示索引类型</span></span><br><span class="line">  <span class="comment">// key in number 表示：约束对象的键只能是数值类型</span></span><br><span class="line">  <span class="comment">// key 仅仅是个占位符，可以是任何名称</span></span><br><span class="line">  [key <span class="keyword">in</span> <span class="built_in">number</span>]: <span class="title class_">Articles</span></span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">number</span>]: <span class="title class_">Articles</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果对象中可以出现任意 string 类型的键，可以这样实现：</span></span><br><span class="line">  <span class="comment">// [key in string]</span></span><br><span class="line">  <span class="comment">// [key: string]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="TypeScript-高级类型"><a href="#TypeScript-高级类型" class="headerlink" title="TypeScript 高级类型"></a>TypeScript 高级类型</h1><h2 id="TypeScript面向对象"><a href="#TypeScript面向对象" class="headerlink" title="TypeScript面向对象"></a>TypeScript面向对象</h2><p>TypeScript作为JavaScript的超集，也是支持使用class关键字的，并且还可以对类的属性和方法等进行静态类型检测</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>使用class关键字来定义一个类</p>
<p><strong>我们可以声明类的属性：在类的内部声明类的属性以及对应的类型</strong></p>
<ul>
<li>如果类型没有声明，那么它们默认是any的</li>
<li>我们也可以给属性设置初始化值</li>
<li>在默认的strictPropertyInitialization模式下面我们的属性是必须初始化的，如果没有初始化，那么编译时就会报错<ul>
<li>如果我们在strictPropertyInitialization模式下确实不希望给属性初始化，可以使用 <code>name!: string</code>语法</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name!: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小储&quot;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>我们使用extends关键字来实现继承，子类中使用super来访问父类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="attr">sno</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, sno: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name, age);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sno</span> = sno;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">running</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">running</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;student running&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类的成员修饰符"><a href="#类的成员修饰符" class="headerlink" title="类的成员修饰符"></a>类的成员修饰符</h3><p><code>public</code> 修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是public的；<br><code>private</code> 修饰的是仅在同一类中可见、私有的属性或方法；<br><code>protected</code> 修饰的是仅在类自身及子类中可见、受保护的属性或方法；</p>
<p><code>readonly</code>  只读属性，外接无法修改</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;running&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getters-x2F-setters"><a href="#getters-x2F-setters" class="headerlink" title="getters&#x2F;setters"></a>getters&#x2F;setters</h3><p>私有属性我们是不能直接访问的，或者某些属性我们想要监听它的获取(getter)和设置(setter)的过程，这个时候我们可以使用存取器，多用于对属性的访问进行拦截操作</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">newVal: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVal &gt;= <span class="number">0</span> &amp;&amp; newVal &lt; <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_age</span> = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_age</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小储&quot;</span>, <span class="number">100</span>);</span><br><span class="line">p1.<span class="property">age</span> = -<span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">age</span>); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>TypeScript 提供了特殊的语法，可以把一个构造函数参数转成一个同名同值的类属性</p>
<ul>
<li>你可以通过在构造函数参数前添加一个可见性修饰符 public private protected 或者 readonly 来创建参数属性，最后这些类属性字段也会得到这些修饰符</li>
</ul>
<blockquote>
<p>当类中有多个属性时，可以使用参数属性进行简写</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">private</span> _age: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小储&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>

<h3 id="抽象类abstract"><a href="#抽象类abstract" class="headerlink" title="抽象类abstract"></a>抽象类abstract</h3><ul>
<li>我们知道，继承是多态使用的前提<ul>
<li>所以在定义很多通用的调用接口时, 我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式（多态：父类引用指向子类对象）</li>
<li>但是，父类本身可能<font color="cornflowerblue"><strong>并不需要对某些方法进行具体的实现</strong></font>，所以父类中定义的方法,，我们可以定义为抽象方法</li>
</ul>
</li>
<li>什么是 抽象方法? <strong>在TypeScript中没有具体实现的方法(没有方法体)，就是抽象方法</strong><ul>
<li>抽象方法，必须存在于抽象类中</li>
<li>抽象类是使用abstract声明的类</li>
</ul>
</li>
<li>抽象类有如下的<font color="red"><strong>特点</strong></font><ul>
<li>抽象类是不能被实例的话（也就是不能通过new创建）</li>
<li>抽象方法必须被子类实现</li>
</ul>
</li>
</ul>
<p>演练：封装一个通用的获取面积的方法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="comment">// getArea方法只有声明没有实现体</span></span><br><span class="line">  <span class="comment">// 实现让子类自己实现</span></span><br><span class="line">  <span class="comment">// 可以将getArea方法定义为抽象方法: 在方法的前面加abstract</span></span><br><span class="line">  <span class="comment">// 抽象方法必须出现在抽象类中, 类前面也需要加abstract</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">getArea</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> width: <span class="built_in">number</span>, <span class="keyword">public</span> height: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> radius: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">radius</span> ** <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calcArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> shape.<span class="title function_">getArea</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// const shape1: Shape = new Rectangle(10, 20);将具体的子类赋值给了父类， 父类引用指向子类对象</span></span><br><span class="line"><span class="title function_">calcArea</span>(<span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line"><span class="title function_">calcArea</span>(<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>));</span><br><span class="line"><span class="title function_">calcArea</span>(<span class="keyword">new</span> <span class="title class_">Triangle</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Java中会报错: 不允许</span></span><br><span class="line"><span class="title function_">calcArea</span>(&#123; <span class="attr">getArea</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类不能被实例化</span></span><br><span class="line"><span class="comment">// calcArea(new Shape())</span></span><br><span class="line"><span class="comment">// calcArea(100)</span></span><br><span class="line"><span class="comment">// calcArea(&quot;abc&quot;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类的作用"><a href="#类的作用" class="headerlink" title="类的作用"></a>类的作用</h3><p>1、可以创建类对应的实例对象 </p>
<p>2、类本身可以作为这个实例的类型 </p>
<p>3、类也可以当做有一个构造签名的函数</p>
<h3 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h3><ul>
<li><p>定义：有的时候，你不能提前知道一个类型里的所有属性的名字，但是你知道这些值的特征，这种情况，你就可以用一个索引签名 (index signature) 来描述可能的值的类型；</p>
</li>
<li><p>一个索引签名的属性类型必须是 string 或者是 number。</p>
<ul>
<li>虽然 TypeScript 可以同时支持 string 和 number 类型，但数字索引的返回类型一定要是字符索引返回类型的子类型</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ICollection</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logCollection</span>(<span class="params">collection: ICollection</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; collection.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(collection[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">tuple</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="string">&quot;cr&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: <span class="built_in">string</span>[] = [<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>];</span><br><span class="line"><span class="title function_">logCollection</span>(tuple);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<h3 id="接口继承-1"><a href="#接口继承-1" class="headerlink" title="接口继承"></a>接口继承</h3><p>可以从其他的接口中继承过来属性 </p>
<ol>
<li>减少了相代码的重复编写</li>
<li>如果使用第三库，给我们定义了一些属性，如果我们自定义一个接口，同时你希望自定义接口拥有第三方某一个类型中所有的属性，可以使用继承来完成</li>
</ol>
<blockquote>
<p>接口支持多继承，类不支持多继承</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>, <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">son</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">stu</span>: <span class="title class_">Student</span> = &#123;</span><br><span class="line">  <span class="attr">son</span>: <span class="number">110</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cr&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><p>使用关键字<code>implements</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IKun</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">slogan</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">playBasketball</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRun</span> &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">ikun</span>: <span class="title class_">IKun</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">slogan</span>: <span class="string">&quot;你干嘛!&quot;</span>,</span><br><span class="line">  <span class="attr">playBasketball</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作用: 接口被类实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">IKun</span>, <span class="title class_">IRun</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">slogan</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">playBasketball</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ikun2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">const</span> ikun3 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ikun2.<span class="property">name</span>, ikun2.<span class="property">age</span>, ikun2.<span class="property">slogan</span>);</span><br><span class="line">ikun2.<span class="title function_">playBasketball</span>();</span><br><span class="line">ikun2.<span class="title function_">running</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="严格字面量赋值检测"><a href="#严格字面量赋值检测" class="headerlink" title="严格字面量赋值检测"></a>严格字面量赋值检测</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.奇怪的现象一: </span></span><br><span class="line"><span class="comment">// 定义info, 类型是IPerson类型</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 多了一个height属性</span></span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="title class_">IPerson</span> = obj <span class="comment">// 不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.奇怪的现象二:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPerson</span>(<span class="params">person: IPerson</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> kobe = &#123; <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">height</span>: <span class="number">1.98</span> &#125;</span><br><span class="line"><span class="title function_">printPerson</span>(kobe)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释现象</span></span><br><span class="line"><span class="comment">// 第一次创建的对象字面量, 称之为fresh(新鲜的)</span></span><br><span class="line"><span class="comment">// 对于新鲜的字面量, 会进行严格的类型检测. 必须完全满足类型的要求(不能有多余的属性)</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">IPerson</span> = obj2</span><br></pre></td></tr></table></figure>

<p><img src="https://chu-image-host.oss-cn-beijing.aliyuncs.com/typora/image-20230402155844564.png" alt="image-20230402155844564"></p>
<h2 id="TS-中的类型兼容性"><a href="#TS-中的类型兼容性" class="headerlink" title="TS 中的类型兼容性"></a>TS 中的类型兼容性</h2><p><strong>目标</strong>：能够理解 TS 中的类型兼容性</p>
<p><strong>内容</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html">TS 类型兼容性参考文档</a></p>
<p>两种类型系统：1. <strong>Structural Type System(结构化类型系统)</strong>      2. Nominal Type System(标明类型系统)</p>
<p><strong>TS 采用的是结构化类型系统，也叫做 duck typing(鸭子类型)，类型检查关注的是值所具有的形状</strong></p>
<p>也就是说，在结构类型系统中，如果两个对象具有相同的形状，则认为它们属于同一类型。比如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p2</span>: <span class="title class_">Point2D</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构类型系统中，如果两个对象具有相同的形状，则认为它们属于同一类型</span></span><br><span class="line"><span class="comment">// 接口Point 和 接口Point2D，具有相同的结构，是可以相互赋值，两者是相互兼容的</span></span><br><span class="line"><span class="comment">// p2是Point2D类型，p是Point类型，将Point2D类型变量赋值给Point类型，这样做没有报错 (不报错，正确的)</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Point</span> = p2;</span><br></pre></td></tr></table></figure>

<p><strong>对于对象类型来说</strong>，y 的成员至少与 x 相同，则 x 兼容 y（<strong>成员多的可以赋值给成员少的</strong>，或者说：只要满足必须的类型就行，多了也没事）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p3</span>: <span class="title class_">Point3D</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">z</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不会报错：对象成员多的可以赋值给成员少的，成员多的类型属性只要满足成员少的类型的属性就ok了</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p2</span>: <span class="title class_">Point2D</span> = p3;</span><br></pre></td></tr></table></figure>

<p><strong>对于函数类型来说</strong>，类型兼容性比较复杂，需要考虑：1.参数个数、2.返回值类型 等等</p>
<ol>
<li><p>参数个数：参数多的兼容参数少的 (或者说，参数少的可以赋值给多的)</p>
<ul>
<li><strong>在 JS 中省略用不到的函数参数实际上是很常见的，这样的使用方式，促成了 TS 中函数类型之间的兼容性</strong></li>
</ul>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="comment">// arr.forEach 第一个参数的类型为： (value: string, index: number, array: string[]) =&gt; void</span></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">func1</span>: <span class="variable constant_">F1</span> = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">func2</span>: <span class="variable constant_">F1</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 报错：不能将类型“(a: number, b: number) =&gt; void”分配给类型“F1”</span></span><br><span class="line"><span class="comment">// 参数多的函数类型，不能赋值给参数少的函数类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">func3</span>: <span class="variable constant_">F1</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：参数少的函数可以赋值给参数多的函数 (参数多的函数兼容参数少的)</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f1</span>: <span class="variable constant_">F1</span> = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">f2</span>: <span class="variable constant_">F2</span> = f1;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>返回值类型：只要满足必须的类型要求就行，多了也没事</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种情况不会报错</span></span><br><span class="line"><span class="comment">// 类型F1明确指出了返回void类型(无返回值的类型)，但是声明函数的时候，是可以返回其它值的</span></span><br><span class="line"><span class="comment">// 原因：f1函数返回了一个number类型的值，返回的值对F1定义的无返回值类型函数没有任何影响，所以不会报错</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">f1</span>: <span class="variable constant_">F1</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;    <span class="comment">// 这里返回不会对类型系统造成任何影响，不影响就可以进行兼容处理</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这种情况会报错</span></span><br><span class="line"><span class="comment">// 类型F1明确指出了返回string类型，但是f1函数返回的却是number类型，所以就会报错</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// 不能将类型“() =&gt; number”分配给类型“F1”，不能将类型“number”分配给类型“string”</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">f1</span>: <span class="variable constant_">F1</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;    <span class="comment">// 这里返回会对类型系统造成任何影响，造成影响就不可以进行兼容处理</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="类型参数化"><a href="#类型参数化" class="headerlink" title="类型参数化"></a>类型参数化</h3><p><strong>内容</strong>：</p>
<ul>
<li><strong>泛型（Generics）可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用</strong>，常用于：函数、接口、class 中</li>
<li>需求：创建一个 id 函数，传入什么数据就返回该数据本身（也就是说，参数和返回值类型相同）</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如，该函数传入什么数值，就返回什么数值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">id1</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">id2</span>(<span class="params">value: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// res1 =&gt; 10</span></span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title function_">id1</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// res2 =&gt; &#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="title function_">id2</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>比如，id(10) 调用以上函数就会直接返回 10 本身。但是，该函数只接收数值类型，无法用于其他类型</li>
<li>为了能让函数能够接受任意类型的参数，可以将参数类型修改为 any。但是，这样就失去了 TS 的类型保护，类型不安全</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">id</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这时候，就可以使用<strong>泛型</strong>来实现了</li>
<li><strong>泛型在保证类型安全(不丢失类型信息)的同时，可以让函数等与多种不同的类型一起工作，灵活可复用</strong></li>
<li>实际上，在 C# 和 Java 等编程语言中，泛型都是用来实现可复用组件功能的主要工具之一</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义数组的两种方式，下面的这种方式就是使用泛型来定义的数组的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p><strong>内容</strong>：</p>
<p>创建泛型函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：&lt;Type&gt;泛型是写在函数(value: Type)这个括号的前面的 (而不是之前的理解的写在函数名id后面的)</span></span><br><span class="line"><span class="keyword">function</span> id &lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以仅使用一个字母来作为类型变量的名称</span></span><br><span class="line"><span class="keyword">function</span> id &lt;T&gt;(<span class="attr">value</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从箭头函数的定义来看，泛型就是写在函数的()括号前面</span></span><br><span class="line"><span class="keyword">const</span> id = &lt;P&gt;(<span class="attr">value</span>: P): <span class="function"><span class="params">P</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>语法：在函数名称的后面添加 <code>&lt;&gt;</code>（尖括号），<strong>尖括号中添加类型变量</strong>，比如此处的 Type</li>
<li><strong>类型变量 Type，是一种特殊类型的变量，它处理类型而不是值</strong></li>
<li><strong>类型变量相当于一个类型容器</strong>，能够捕获用户提供的类型（具体是什么类型由用户调用该函数时指定）</li>
<li>因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型</li>
<li>类型变量 Type，可以是任意合法的变量名称</li>
</ul>
<p>调用泛型函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用上面使用了泛型创建的id函数</span></span><br><span class="line"><span class="comment">// 函数参数和返回值类型都为：number</span></span><br><span class="line"><span class="keyword">const</span> num = id&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数和返回值类型都为：string</span></span><br><span class="line"><span class="keyword">const</span> str = id&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>语法：在函数名称的后面添加 <code>&lt;&gt;</code>（尖括号），<strong>尖括号中指定具体的类型</strong>，比如，此处的 number</li>
<li>当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到</li>
<li>此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number</li>
<li>这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，<strong>实现了复用的同时保证了类型安全</strong></li>
</ul>
<h3 id="简化泛型函数调用"><a href="#简化泛型函数调用" class="headerlink" title="简化泛型函数调用"></a>简化泛型函数调用</h3><p><strong>内容</strong>：</p>
<p>在调用泛型函数时，<strong>可以省略 &lt;类型&gt; 来简化泛型函数的调用</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略 &lt;number&gt;、&lt;string&gt;泛型，直接调用函数，可以进行类型推断出具体类型</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="title function_">id</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> str = <span class="title function_">id</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> msg = <span class="title function_">id</span>(<span class="string">&#x27;aaa&#x27;</span>) =&gt; <span class="comment">// 使用const会推断为&#x27;aaa&#x27;</span></span><br></pre></td></tr></table></figure>

<p>解释:</p>
<ul>
<li>此时，TS 内部会采用一种叫做<strong>类型参数推断</strong>的机制，来根据传入的实参自动推断出类型变量 Type 的类型</li>
<li>比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型</li>
<li>推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读</li>
<li>说明：<strong>当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数</strong></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的一些类型推断</span></span><br><span class="line"><span class="comment">// 直接写一个数组，不指定类型，会通过类型推断，得出数组的具体类型 (其它类型也会有类型推断的)</span></span><br><span class="line"><span class="comment">// let arr1: number[]</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// let arr2: string[]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// let arr3: (string | number)[]</span></span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 会自动推断出数组forEach方法的item参数的类型；(parameter) item: number</span></span><br><span class="line"><span class="comment">// forEach(callbackfn: (value: T, index: number, array: T[]) =&gt; void, thisArg?: any): void;</span></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型函数语法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CustomFunc</span> = &lt;T, P&gt;<span class="function">(<span class="params">value1: T, value2: P</span>) =&gt;</span> T | P</span><br><span class="line"><span class="keyword">let</span> <span class="attr">fn1</span>: <span class="title class_">CustomFunc</span> = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a</span><br><span class="line"><span class="keyword">let</span> <span class="attr">fn2</span>: <span class="title class_">CustomFunc</span> = <span class="function">(<span class="params">a, b</span>) =&gt;</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">// let res1: string | number</span></span><br><span class="line"><span class="keyword">let</span> res1 = fn1&lt;<span class="built_in">number</span>, <span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推断</span></span><br><span class="line"><span class="comment">// let res2: number[] | &#123;</span></span><br><span class="line"><span class="comment">//   name: string;</span></span><br><span class="line"><span class="comment">//   age: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> res2 = <span class="title function_">fn2</span>([<span class="number">1</span>, <span class="number">2</span>], &#123;<span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>, <span class="attr">age</span>: <span class="number">42</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口：接口也可以配合泛型来使用，以增加其灵活性，增强其复用性</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IdFunc</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="function">(<span class="params">value: Type</span>) =&gt;</span> <span class="title class_">Type</span>;</span><br><span class="line">  <span class="title function_">ids</span>(): <span class="title class_">Type</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">IdFunc</span>&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  <span class="title function_">id</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">ids</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ol>
<li>在接口名称的后面添加 <code>&lt;类型变量&gt;</code>，那么，这个接口就变成了泛型接口。</li>
<li>接口的类型变量，对接口中所有其他成员可见，也就是<strong>接口中所有成员都可以使用类型变量</strong>。</li>
<li>使用泛型接口时，<strong>需要显式指定具体的类型</strong>(比如，此处的 IdFunc)。</li>
<li>此时，id 方法的参数和返回值类型都是 number;ids 方法的返回值类型是 number[]。</li>
</ol>
<p>实际上，JS 中的数组在 TS 中就是一个泛型接口</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的forEach方法，使用泛型定义的，如果知道数组的类型，就可以根据类型推断，推断出参数的具体类型</span></span><br><span class="line"><span class="comment">// forEach(callbackfn: (value: T, index: number, array: T[]) =&gt; void, thisArg?: any): void;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strs = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="comment">// 鼠标放在 forEach 上查看类型</span></span><br><span class="line"><span class="comment">// (method) Array&lt;string&gt;.forEach(callbackfn: (value: string, index: number, array: string[]) =&gt; void, thisArg?: any): void</span></span><br><span class="line">strs.<span class="property">forEach</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 鼠标放在 forEach 上查看类型</span></span><br><span class="line"><span class="comment">// (method) Array&lt;number&gt;.forEach(callbackfn: (value: number, index: number, array: number[]) =&gt; void, thisArg?: any): void</span></span><br><span class="line">nums.<span class="property">forEach</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>解释:当我们在使用数组时，TS 会根据数组的不同类型，来自动将类型变量设置为相应的类型</li>
<li>技巧:可以通过 Ctrl + 鼠标左键(Mac：Command + 鼠标左键)来查看具体的类型信息</li>
</ul>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p><strong>目标</strong>：能够知道为什么要为泛型添加约束</p>
<p><strong>内容</strong>：</p>
<p>有时候我们希望传入的类型有某些共性，但是这些共性可能不是在同一种类型中：</p>
<ul>
<li>比如string和array都是有length的，或者某些对象也是会有length属性的；</li>
<li>那么只要是拥有length的属性都可以作为我们的参数类型，那么应该如何操作呢？</li>
</ul>
<p>比如，以下示例代码中想要获取参数的长度：</p>
<ul>
<li>因为 Type 可以代表任意类型，无法保证一定存在 length 属性，比如 number 类型就没有 length。因此，无法访问 length 属性</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="comment">// 注意：此处会报错，类型“Type”上不存在属性“length”</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">id</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>此时，就需要<strong>为泛型添加约束来收缩类型（缩窄类型取值范围）</strong></p>
<p>添加泛型约束收缩类型，主要有以下两种方式：1.指定更加具体的类型      2.添加约束</p>
<p>首先，我们先来看第一种情况，如何指定更加具体的类型：</p>
<p>比如，将类型修改为 <code>Type[]</code>(Type 类型的数组)，因为只要是数组就一定存在 length 属性，因此就可以访问了</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">  <span class="comment">// 可以正确访问</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加泛型约束"><a href="#添加泛型约束" class="headerlink" title="添加泛型约束"></a>添加泛型约束</h3><p><strong>目标</strong>：能够使用 <code>extends</code> 关键字来为泛型函数添加类型约束</p>
<p><strong>内容</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个自定义类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ILength</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type extends ILength 添加泛型约束</span></span><br><span class="line"><span class="comment">// 解释：表示传入的类型必须满足 ILength 接口的要求才行，也就是得有一个 number 类型的 length 属性</span></span><br><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">ILength</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<ul>
<li>创建描述约束的接口 ILength，该接口要求提供 length 属性</li>
<li>通过 <code>extends</code> 关键字来为泛型（类型变量）添加约束</li>
<li>该约束表示：<strong>传入的类型必须具有 length 属性</strong></li>
<li>注意：传入的实参（比如，数组&#x2F;字符串）只要有 length 属性即可，除了length可以有别的属性（类型兼容性)</li>
</ul>
<h3 id="多个类型变量的泛型-keyof"><a href="#多个类型变量的泛型-keyof" class="headerlink" title="多个类型变量的泛型 (keyof)"></a>多个类型变量的泛型 (keyof)</h3><p><strong>目标</strong>：能够知道泛型可以有多个类型变量</p>
<p><strong>内容</strong>：</p>
<p>泛型的类型变量可以有多个，并且<strong>类型变量之间还可以约束</strong>(比如，第二个类型变量受第一个类型变量约束) 比如，创建一个函数来获取对象中属性的值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getProp&lt;<span class="title class_">Type</span>, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof <span class="title class_">Type</span>&gt;(<span class="attr">obj</span>: <span class="title class_">Type</span>, <span class="attr">key</span>: <span class="title class_">Key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="title function_">getProp</span>(person, <span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<ol>
<li>添加了第二个类型变量 Key，两个类型变量之间使用 <code>,</code> 逗号分隔。</li>
<li><strong>keyof 关键字接收一个对象类型，生成其键名称(可能是字符串或数字)的联合类型</strong>。</li>
<li>本示例中 <code>keyof person</code> 实际上获取的是 person 对象所有键的联合类型，也就是：<code>&#39;name&#39; | &#39;age&#39;</code></li>
<li>类型变量 Key 受 Type 约束，可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问对象中存在的属性</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type extends object 表示：Type 应该是一个对象类型，如果不是 对象 类型，就会报错</span></span><br><span class="line"><span class="comment">// 如果要用到 对象 类型，应该用 object ，而不是 Object</span></span><br><span class="line"><span class="keyword">function</span> getProperty&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> <span class="built_in">object</span>, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof <span class="title class_">Type</span>&gt;(</span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Type</span>,</span><br><span class="line">  <span class="attr">key</span>: <span class="title class_">Key</span>,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redux 整个应用，状态的类型</span></span><br><span class="line"><span class="comment">// 目前，Redux 中已经有两个状态：login（登录时的状态）和 profile（我的 - 个人信息）</span></span><br><span class="line"><span class="comment">// RootState =&gt; &#123; login: Token; profile: ProfileState; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RootState</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> store.<span class="property">getState</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希望，在使用 useInitialState 自定义 hook 的时候，只应该获取到 Redux 中已有的状态，但是，获取哪一个状态时不确定的，只有在调用时才能确定</span></span><br><span class="line"><span class="comment">// 因为 stateName 只能是 Redux 已有状态中的任何一个，所以，stateName 的取值范围：&#x27;login&#x27; | &#x27;profile&#x27; </span></span><br><span class="line"><span class="comment">// 而此处不能直接写死一个联合类型，因为 Redux 中的状态将来是会变化（将来还要继续往 redux 中添加状态）</span></span><br><span class="line"><span class="comment">// 既然不能写死，就得动态获取，也就是 Redux 状态类型 RootState 中有哪些状态，就拿到这些状态的名字即可</span></span><br><span class="line"><span class="comment">// 那也就是要获取到 RootState 对象类型中，所有键的集合：	keyof RootState =&gt; &#x27;login&#x27; | &#x27;profile&#x27;</span></span><br><span class="line"><span class="keyword">const</span> useInitialState = (<span class="attr">action</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>, <span class="attr">stateName</span>: keyof <span class="title class_">RootState</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型：</span></span><br><span class="line"><span class="comment">// S extends keyof RootState 表示：创建了一个泛型的类型变量叫做：S</span></span><br><span class="line"><span class="comment">// 通过 extends 关键字来给 类型变量S 添加了泛型约束</span></span><br><span class="line"><span class="comment">// 约束：S 的类型应该是 keyof RootState 中的任意一个，也就是：&#x27;login&#x27; | &#x27;profile&#x27;</span></span><br><span class="line"><span class="comment">// const useInitialState = &lt;S extends keyof RootState&gt;(action: () =&gt; void, stateName: S) &#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> useInitialState = &lt;<span class="title class_">StateName</span> <span class="keyword">extends</span> keyof <span class="title class_">RootState</span>&gt;(<span class="attr">action</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>, <span class="attr">stateName</span>: <span class="title class_">StateName</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- 对比以上两种方式的区别 --</span></span><br><span class="line"><span class="comment">// 1 这种方式：在调用该函数时，最终得到的返回值类型：Token | ProfileState 也就是将所有可能出现的情况都列举出来了</span></span><br><span class="line"><span class="keyword">const</span> useInitialState = (<span class="attr">action</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>, <span class="attr">stateName</span>: keyof <span class="title class_">RootState</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 这种方式：在调用该函数时，最终得到的返回值类型：是某一个状态的类型，这个类型由我们传入的 stateName 类决定</span></span><br><span class="line"><span class="comment">// useInitialState(getUser, &#x27;profile&#x27;) 返回值类型，就是 profile 这个键对应的类型：ProfileState</span></span><br><span class="line"><span class="comment">// useInitialState(getUser, &#x27;login&#x27;) 返回值类型，就是 login 这个键对应的类型：Token</span></span><br><span class="line"><span class="keyword">const</span> useInitialState = &lt;<span class="title class_">StateName</span> <span class="keyword">extends</span> keyof <span class="title class_">RootState</span>&gt;(<span class="attr">action</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>, <span class="attr">stateName</span>: <span class="title class_">StateName</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------            </span></span><br><span class="line"><span class="comment">// 完整函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useDispatch, useSelector &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">RootState</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@/types/store&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 useInitialState 函数（自定义 hook）</span></span><br><span class="line"><span class="keyword">const</span> useInitialState = &lt;<span class="title class_">StateName</span> <span class="keyword">extends</span> keyof <span class="title class_">RootState</span>&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  action: () =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  stateName: StateName,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line">  <span class="keyword">const</span> state = <span class="title function_">useSelector</span>(<span class="function">(<span class="params">state: RootState</span>) =&gt;</span> state[stateName]);</span><br><span class="line">  <span class="comment">// const state = useSelector&lt;RootState, RootState[StateName]&gt;(</span></span><br><span class="line">  <span class="comment">//   state =&gt; state[stateName]</span></span><br><span class="line">  <span class="comment">// )</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">dispatch</span>(<span class="title function_">action</span>());</span><br><span class="line">  &#125;, [dispatch, action]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------  </span></span><br><span class="line">                            </span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line"><span class="title function_">useInitialState</span>(getUser, <span class="string">&#x27;login&#x27;</span>)</span><br><span class="line"><span class="title function_">useInitialState</span>(getUser, <span class="string">&#x27;profile&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原来讲过的泛型基础：</span></span><br><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">id&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>)</span><br><span class="line"><span class="title function_">id</span>(<span class="number">10</span>)    <span class="comment">// 省略类型不写</span></span><br></pre></td></tr></table></figure>


<h2 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h2><p>泛型工具类型：TS 内置了一些常用的工具类型，来简化 TS 中的一些常见操作</p>
<p>说明：它们都是基于泛型实现的(泛型适用于多种类型，更加通用)，并且是内置的，可以直接在代码中使用。 这些工具类型有很多，主要学习以下几个:</p>
<ol>
<li><code>Partial&lt;Type&gt;</code></li>
<li><code>Readonly&lt;Type&gt;</code></li>
<li><code>Pick&lt;Type, Keys&gt;</code></li>
<li><code>Record&lt;Keys, Type&gt;</code></li>
<li><code>Required&lt;Type&gt;</code></li>
<li><code>ReturnType&lt;Type&gt;</code></li>
<li><code>Omit&lt;Type, Keys&gt;</code></li>
<li><code>Parameters&lt;Type&gt;</code></li>
<li><code>NonNullable&lt;Type&gt;</code></li>
<li><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code></li>
<li><code>Extract&lt;Type, Union&gt;</code></li>
<li><code>InstanceType&lt;Type&gt;</code></li>
<li><code>ConstructorParameters&lt;Type&gt;</code></li>
</ol>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/utility-types.html">TS 所有内置的泛型工具类型文档</a></li>
</ul>
<h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><ul>
<li>Partial 用来构造(创建)一个类型，将 Type 的所有属性都变成为可选属性。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">children</span>: <span class="built_in">number</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialProps</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Props</span>&gt;;</span><br><span class="line"><span class="comment">// type PartialProps = &#123;</span></span><br><span class="line"><span class="comment">//     id?: string | undefined;</span></span><br><span class="line"><span class="comment">//     children?: number[] | undefined;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解释:构造出来的新类型 PartialProps 结构和 Props 相同，但所有属性都变为可选的。</li>
</ul>
<h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><ul>
<li>Readonly 用来构造一个类型，将 Type 的所有属性都设置为 readonly(只读)。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">children</span>: <span class="built_in">number</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyProps</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Props</span>&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li>解释:构造出来的新类型 ReadonlyProps 结构和 Props 相同，但所有属性都变为只读的。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">props</span>: <span class="title class_">ReadonlyProps</span> = &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">children</span>: [] &#125;;</span><br><span class="line"><span class="comment">// 错误演示</span></span><br><span class="line">props.<span class="property">id</span> = <span class="string">&#x27;2&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>当我们想重新给 id 属性赋值时，就会报错:无法分配到 “id” ，因为它是只读属性。</li>
</ul>
<h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><ul>
<li>Pick&lt;Type, Keys&gt; 从 Type 中选择一组属性来构造新类型。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">children</span>: <span class="built_in">number</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 Props 类型里面选出 id 和 title属性，创建一个新的类型，赋值给 PickProps 类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PickProps</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Props</span>, <span class="string">&#x27;id&#x27;</span> | <span class="string">&#x27;title&#x27;</span>&gt;;</span><br><span class="line"><span class="comment">// type PickProps = &#123;</span></span><br><span class="line"><span class="comment">//     title: string;</span></span><br><span class="line"><span class="comment">//     id: string;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解释:<ol>
<li>Pick 工具类型有两个类型变量：1. 表示选择谁的属性     2. 表示选择哪几个属性。</li>
<li>其中第二个类型变量，如果只选择一个则只传入该属性名即可，如果有多个使用联合类型即可。</li>
<li>第二个类型变量传入的属性只能是第一个类型变量中存在的属性。</li>
<li>构造出来的新类型 PickProps，只有 id 和 title 两个属性类型。</li>
</ol>
</li>
</ul>
<h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用场景：如果已经知道对象中键的集合，可以直接通过 Record 来快速创建一个对象类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Record 内置泛型工具类型，用来创建一个对象类型</span></span><br><span class="line"><span class="comment">// Record 类型的作用：根据 联合类型 来得到一个对象类型。</span></span><br><span class="line"><span class="comment">// 	第一个泛型参数是联合类型，用来指定对象中有什么键</span></span><br><span class="line"><span class="comment">//  第二个泛型参数表示对象中值的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如，</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Record</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>, <span class="built_in">string</span>&gt;; <span class="comment">// =&gt; &#123; a: string; b: string &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该代码的作用：</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PullStatus</span> = <span class="string">&#x27;pulling&#x27;</span> | <span class="string">&#x27;canRelease&#x27;</span> | <span class="string">&#x27;refreshing&#x27;</span> | <span class="string">&#x27;complete&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">statusRecord</span>: <span class="title class_">Record</span>&lt;<span class="title class_">PullStatus</span>, <span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">pulling</span>: <span class="string">&#x27;用力拉&#x27;</span>,</span><br><span class="line">  <span class="attr">canRelease</span>: <span class="string">&#x27;松开吧&#x27;</span>,</span><br><span class="line">  <span class="attr">refreshing</span>: <span class="string">&#x27;玩命加载中...&#x27;</span>,</span><br><span class="line">  <span class="attr">complete</span>: <span class="string">&#x27;好啦&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以手动创建对象类型，但是，没有 Record 方便</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">  <span class="attr">pulling</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">canRelease</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">refreshing</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">complete</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把传入的类型变为必填状态</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type p = &#123;</span></span><br><span class="line"><span class="comment">//    name: string;</span></span><br><span class="line"><span class="comment">//    age: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">type</span> p = <span class="title class_">Required</span>&lt;<span class="title class_">IPerson</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该类型能够获取函数类型 T 的返回值类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f1</span> = (<span class="params"></span>) =&gt; <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment">// type t1 = string</span></span><br><span class="line"><span class="keyword">type</span> t1 = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> f1&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f2</span> = (<span class="params"></span>) =&gt; (&#123;<span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// type t2 = &#123;</span></span><br><span class="line"><span class="comment">//   name: string;</span></span><br><span class="line"><span class="comment">//   age: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> f2&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h3><ul>
<li><code>Omit &lt;T, K&gt;</code>在  T  类型中删除对应 K 属性</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">address</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type p = &#123;</span></span><br><span class="line"><span class="comment">//   name: string;</span></span><br><span class="line"><span class="comment">//   age?: number | undefined;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">type</span> p = <span class="title class_">Omit</span>&lt;<span class="title class_">IPerson</span>, <span class="string">&#x27;address&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">favor</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type P = &#123;</span></span><br><span class="line"><span class="comment">//   sex: string;</span></span><br><span class="line"><span class="comment">//   favor: Array&lt;string&gt;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">type</span> P = <span class="title class_">Omit</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回的是函数类型 fn 的形参元组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">str: <span class="built_in">string</span>, num: <span class="built_in">number</span>, message?: []</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// type p1 = [str: string, num: number, message?: [] | undefined]</span></span><br><span class="line"><span class="keyword">type</span> p1 = <span class="title class_">Parameters</span>&lt;<span class="keyword">typeof</span> fn1&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A = &#123;<span class="attr">name</span>: <span class="built_in">string</span>&#125;</span><br><span class="line"><span class="keyword">type</span> B = &#123;<span class="attr">age</span>: <span class="built_in">number</span>&#125;</span><br><span class="line"><span class="keyword">type</span> C = <span class="title class_">Array</span>&lt;&#123;<span class="attr">address</span>: <span class="built_in">string</span>, favor?: <span class="built_in">string</span>&#125;&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn2</span> = (<span class="params">a: A, b: B, c: C</span>) =&gt; <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">// type p2 = [a: A, b: B, c: C]</span></span><br><span class="line"><span class="keyword">type</span> p2 = <span class="title class_">Parameters</span>&lt;<span class="keyword">typeof</span> fn2&gt;</span><br></pre></td></tr></table></figure>

<h3 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从T中剔除null和undefined：去除掉联合类型中的 null 和 undefined 类型</span></span><br><span class="line"><span class="comment">// type p = string | number</span></span><br><span class="line"><span class="keyword">type</span> p = <span class="title class_">NonNullable</span>&lt;<span class="literal">null</span> | <span class="literal">undefined</span> | <span class="built_in">number</span> | <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h3><ul>
<li><code>Exclude&lt;T, U&gt;</code> 最常用的还是结合两个联合类型来使用的，我们能通过 <code>Exclude</code> 取出 <code>T</code> 联合类型在 <code>U</code> 联合类型中没有的子类型   —   从T中排除可分配给U的类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">address</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Alien</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">favor</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// keyof Person：就是获取 Person 类型所有 key 集合的联合类型 -&gt; &quot;name&quot; | &quot;age&quot; | &quot;sex&quot; | &quot;address&quot;</span></span><br><span class="line"><span class="comment">// keyof Alien：就是获取 Alien 类型所有 key 集合的联合类型   -&gt; &quot;name&quot; | &quot;age&quot; | &quot;favor&quot;</span></span><br><span class="line"><span class="comment">// type p = &quot;address&quot; | &quot;sex&quot;</span></span><br><span class="line"><span class="keyword">type</span> p = <span class="title class_">Exclude</span>&lt;keyof <span class="title class_">Person</span>, keyof <span class="title class_">Alien</span>&gt;</span><br><span class="line">                 </span><br><span class="line"><span class="keyword">type</span> T = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">string</span>[] | <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; | (<span class="function">() =&gt;</span> <span class="built_in">void</span>)</span><br><span class="line"><span class="keyword">type</span> U = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="comment">// type P = string[] | number[] | (() =&gt; void)</span></span><br><span class="line"><span class="keyword">type</span> P = <span class="title class_">Exclude</span>&lt;T, U&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h3><ul>
<li><code>Extract&lt;T, U&gt;</code> 和 <code>Exclude&lt;T, U&gt;</code> 是相反的，最常用的还是结合两个联合类型来使用的，我们能通过 <code>Extract</code> 取出 <code>T</code> 联合类型在 <code>U</code> 联合类型中所有重复的子类型   —   从T中提取可分配给U的类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">address</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Alien</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">favor</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// keyof Person：就是获取 Person 类型所有 key 集合的联合类型 -&gt; &quot;name&quot; | &quot;age&quot; | &quot;sex&quot; | &quot;address&quot;</span></span><br><span class="line"><span class="comment">// keyof Alien：就是获取 Alien 类型所有 key 集合的联合类型   -&gt; &quot;name&quot; | &quot;age&quot; | &quot;favor&quot;</span></span><br><span class="line"><span class="comment">// type p = &quot;name&quot; | &quot;age&quot;</span></span><br><span class="line"><span class="keyword">type</span> p = <span class="title class_">Extract</span>&lt;keyof <span class="title class_">Person</span>, keyof <span class="title class_">Alien</span>&gt;</span><br><span class="line">                 </span><br><span class="line"><span class="keyword">type</span> T = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">string</span>[] | <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; | (<span class="function">() =&gt;</span> <span class="built_in">void</span>)</span><br><span class="line"><span class="keyword">type</span> U = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="comment">// type P = string | number</span></span><br><span class="line"><span class="keyword">type</span> P = <span class="title class_">Extract</span>&lt;T, U&gt;</span><br></pre></td></tr></table></figure>

<h3 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType</h3><ul>
<li>获取 class 构造函数的返回类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;man&#x27;</span> | <span class="string">&#x27;women&#x27;</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, gender: <span class="string">&#x27;man&#x27;</span> | <span class="string">&#x27;women&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type P = Person</span></span><br><span class="line"><span class="keyword">type</span> P = <span class="title class_">InstanceType</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Person</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// params里面只能有：name age gender这三个属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">params</span>: P = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;man&#x27;</span>,</span><br><span class="line">  <span class="comment">// favor: &#x27;aa&#x27;   // 写这个就会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConstructorParameters"><a href="#ConstructorParameters" class="headerlink" title="ConstructorParameters"></a>ConstructorParameters</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取构造函数中参数类型 元组 形式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;man&#x27;</span> | <span class="string">&#x27;women&#x27;</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, gender: <span class="string">&#x27;man&#x27;</span> | <span class="string">&#x27;women&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type P = [name: string, age: number, gender: &quot;man&quot; | &quot;women&quot;]</span></span><br><span class="line"><span class="keyword">type</span> P = <span class="title class_">ConstructorParameters</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Person</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p><strong>内容</strong>：</p>
<p>有的时候，一个类型需要基于另外一个类型，但是你又不想拷贝一份，这个时候可以考虑使用映射类型</p>
<ul>
<li>大部分内置的工具都是通过映射类型来实现的；</li>
<li>大多数类型体操的题目也是通过映射类型完成的；</li>
</ul>
<blockquote>
<p>说明：映射类型只能使用type定义</p>
</blockquote>
<p>映射类型建立在索引签名的语法上：</p>
<ul>
<li>映射类型，就是使用了 PropertyKeys 联合类型的泛型</li>
<li>其中 PropertyKeys 多是通过 keyof 创建，然后循环遍历键名创建一个类型；</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Iperson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MapType</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [property <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="title class_">Type</span>[property];</span><br><span class="line">  <span class="comment">// 本质就是遍历类型所有的key，获取到类型，然后使用</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 拷贝一份IPerson</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewPerson</span> = <span class="title class_">MapType</span>&lt;<span class="title class_">Iperson</span>&gt;;</span><br></pre></td></tr></table></figure>

<p><img src="https://chu-image-host.oss-cn-beijing.aliyuncs.com/typora/image-20230405151550006.png" alt="image-20230405151550006"></p>
<h3 id="映射修饰符"><a href="#映射修饰符" class="headerlink" title="映射修饰符"></a>映射修饰符</h3><p>在使用映射类型时，有两个额外的修饰符可能会用到：</p>
<ul>
<li>一个是 readonly，用于设置属性只读；</li>
<li>一个是 ? ，用于设置属性可选；</li>
</ul>
<blockquote>
<p><strong>你可以通过前缀 - 或者 + 删除或者添加这些修饰符，如果没有写前缀，相当于使用了 + 前缀。</strong></p>
</blockquote>
<p>解释：</p>
<ul>
<li><p>默认是<code>+</code>，使用了映射修饰符，拷贝出来的类型所有的属性都会添加上对应的修饰符</p>
</li>
<li><p>原始类型中可能有？或 readonly，使用了<code>-</code>，在拷贝出来的类型中？或 readonly会被去掉</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MapPerson</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]-?: <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IPersonRequired</span> = <span class="title class_">MapPerson</span>&lt;<span class="title class_">IPerson</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">IPersonRequired</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cr&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span>,</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;北京市&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://chu-image-host.oss-cn-beijing.aliyuncs.com/typora/image-20230405152828428.png" alt="image-20230405152828428"></p>
<h1 id="TypeScript知识扩展"><a href="#TypeScript知识扩展" class="headerlink" title="TypeScript知识扩展"></a>TypeScript知识扩展</h1><h2 id="TypeScript模块化"><a href="#TypeScript模块化" class="headerlink" title="TypeScript模块化"></a>TypeScript模块化</h2><ul>
<li><p>我们需要先理解 TypeScript 认为什么是一个模块。</p>
<ul>
<li>JavaScript 规范声明任何没有 export 的 JavaScript 文件都应该被认为是一个脚本，而非一个模块</li>
<li>在一个脚本文件中，变量和类型会被声明在共享的全局作用域，将多个输入文件合并成一个输出文件，或者在 HTML使用多<br>个 <script> 标签加载这些文件。</li>
</ul>
</li>
<li><p>如果你有一个文件，现在没有任何 import 或者 export，但是你希望它被作为模块处理，添加这行代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这会把文件改成一个没有导出任何内容的模块，这个语法可以生效，无论你的模块目标是什么</p>
</li>
</ul>
<h2 id="内置类型声明"><a href="#内置类型声明" class="headerlink" title="内置类型声明"></a>内置类型声明</h2><ul>
<li>内置类型声明是typescript自带的、帮助我们内置了JavaScript运行时的一些标准化API的声明文件<ul>
<li>包括比如Function、String、Math、Date等内置类型</li>
<li>也包括运行环境中的DOM API，比如Window、Document等；</li>
</ul>
</li>
<li>TypeScript 使用模式命名这些声明文件lib.[something].d.ts。</li>
</ul>
<p><img src="https://chu-image-host.oss-cn-beijing.aliyuncs.com/typora/image-20230408114831943.png" alt="image-20230408114831943"></p>
<ul>
<li>内置类型声明通常在我们安装typescript的环境中会带有的 <code>npm i typescript -g</code></li>
</ul>
<h2 id="内置声明的环境"><a href="#内置声明的环境" class="headerlink" title="内置声明的环境"></a>内置声明的环境</h2><ul>
<li>我们可以通过target和lib来决定哪些内置类型声明是可以使用的<ul>
<li>例如，startsWith字符串方法只能从称为ECMAScript 6的 JavaScript 版本开始使用；</li>
</ul>
</li>
<li>我们可以通过target的编译选项来配置：TypeScript通过lib根据您的target设置更改默认包含的文件来帮助解决此问题<ul>
<li><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#lib">https://www.typescriptlang.org/tsconfig#lib</a></li>
</ul>
</li>
</ul>
<h2 id="外部定义类型声明"><a href="#外部定义类型声明" class="headerlink" title="外部定义类型声明"></a>外部定义类型声明</h2><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><ul>
<li>外部类型声明通常是我们使用一些库（比如第三方库）时，需要的一些类型声明。<ul>
<li>有些库下载完成后就带有类型声明(.d.ts文件)，比如axios</li>
<li>有些库在安装时没有带类型声明，在ts环境下使用，就会报错，此时就需要我们自己编写</li>
</ul>
</li>
<li>通常<font color='red'>通过社区的一个公有库DefinitelyTyped存放类型声明文件</font><ul>
<li>该库查找声明安装方式的地址：<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/dt/search?search=">https://www.typescriptlang.org/dt/search?search=</a></li>
<li>比如我们安装react的类型声明： <code>npm i @types/react --save-dev</code></li>
</ul>
</li>
</ul>
<h3 id="自定义声明"><a href="#自定义声明" class="headerlink" title="自定义声明"></a>自定义声明</h3><p>什么情况下需要自己来定义声明文件呢？</p>
<ul>
<li><p>我们使用的第三方库是一个纯的JavaScript库，没有对应的声明文件；比如lodash</p>
<ul>
<li>现在的库基本上都有类型声明文件，不需要我们自己编写</li>
</ul>
</li>
<li><p>我们给自己的代码中声明一些类型，方便在其他地方直接进行使用</p>
<ul>
<li><p>例如，在index.html中定义了一些全局变量，想要在别的文件中使用，此时可以使用类型声明</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> whyName = <span class="string">&quot;why&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> whyAge = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">const</span> whyHeight = <span class="number">1.88</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// types/why.d.ts 自定义类型声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">whyName</span>: <span class="built_in">string</span>; <span class="comment">// 注意，此时不能赋值</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">whyAge</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">whyHeight</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts 使用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(whyName, whyAge, whyHeight); <span class="comment">// 不声明时，找不到该变量，会报错</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="declare-声明模块"><a href="#declare-声明模块" class="headerlink" title="declare 声明模块"></a>declare 声明模块</h2><p>声明模块的语法: <code>declare module &#39;模块名&#39; &#123;&#125;</code></p>
<ul>
<li>在声明模块的内部，我们可以通过 export 导出对应库的类、函数等；</li>
</ul>
<blockquote>
<p><font color='red'>开发中，我们引入一些文件，ts不能识别，此时就需要声明一个模块</font></p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> testImg <span class="keyword">from</span> <span class="string">&quot;./img/test.png&quot;</span>;</span><br></pre></td></tr></table></figure>



<p><img src="https://chu-image-host.oss-cn-beijing.aliyuncs.com/typora/image-20230409143815592.png"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明文件模块</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;*.png&quot;</span>;</span><br><span class="line"><span class="comment">// 说明，如果模块里面内容很多，可以直接用一个&#123;&#125;</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> xxx别名 &#123;&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>开发中，如果我们引入了cdn相关文件，例如jQuery，我们不能直接使用<code>$</code>，此时需要声明命名空间</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明命名空间</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> $ &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">setting: <span class="built_in">any</span></span>): <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="认识tsconfig-json文件"><a href="#认识tsconfig-json文件" class="headerlink" title="认识tsconfig.json文件"></a>认识tsconfig.json文件</h2><p>1、tsconfig.json文件有两个作用：</p>
<ul>
<li><font color='orange'>作用一（主要的作用）</font>：让TypeScript Compiler在编译的时候，知道如何去编译TypeScript代码和进行类型检测；<ul>
<li>比如是否允许不明确的this选项，是否允许隐式的any类型；</li>
<li>将TypeScript代码编译成什么版本的JavaScript代码；</li>
</ul>
</li>
<li><font color='orange'>作用二</font>：让编辑器（比如VSCode）可以按照正确的方式识别TypeScript代码；<ul>
<li>对于哪些语法进行提示、类型错误检测等等；</li>
</ul>
</li>
</ul>
<blockquote>
<p>JavaScript 项目可以使用 jsconfig.json 文件，它的作用与 tsconfig.json 基本相同，只是默认启用了一些 JavaScript 相关的编译选项。</p>
</blockquote>
<p>2、tsconfig.json在编译时如何被使用呢?</p>
<p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig">官方文档</a></p>
<ul>
<li>在调用 tsc 命令并且没有其它输入文件参数时，编译器将由当前目录开始向父级目录寻找包含 tsconfig 文件的目录。</li>
<li>调用 tsc 命令并且没有其他输入文件参数，可以使用 --project （或者只是 -p）的命令行选项来指定包含了 tsconfig.json 的目录；</li>
<li>当命令行中指定了输入文件参数， tsconfig.json 文件会被忽略；</li>
<li><strong>webpack中使用ts-loader进行打包时，也会自动读取tsconfig文件，根据配置编译TypeScript代码。</strong></li>
</ul>
<h3 id="3、常见配置"><a href="#3、常见配置" class="headerlink" title="3、常见配置"></a>3、常见配置</h3><p><img src="https://chu-image-host.oss-cn-beijing.aliyuncs.com/typora/image-20230409171934119.png" alt="image-20230409171934119"></p>
<p><img src="https://chu-image-host.oss-cn-beijing.aliyuncs.com/typora/image-20230409171955895.png" alt="image-20230409171955895"></p>
<h1 id="TS与React项目"><a href="#TS与React项目" class="headerlink" title="TS与React项目"></a>TS与React项目</h1><h2 id="创建基于-TS-的-React-项目"><a href="#创建基于-TS-的-React-项目" class="headerlink" title="创建基于 TS 的 React 项目"></a>创建基于 TS 的 React 项目</h2><p><strong>目标</strong>：能够使用  create-react-app  创建基于 TS 的项目</p>
<p><strong>内容</strong>：</p>
<p>创建基于 TS 的 React 项目命令：<code>npx create-react-app react-ts --template typescript</code></p>
<p>说明：在命令行中，添加 <code>--template typescript</code> 表示创建支持 TS 的项目</p>
<p>相比 JS 的 React 项目，目录的变化：</p>
<ol>
<li>在项目根目录中多了一个文件：<code>tsconfig.json</code>（TS 的配置文件）</li>
<li>在 src 目录中，文件的后缀有变化，由原来的 <code>.js</code> 变为<code>.ts</code>或<code>.tsx</code><ul>
<li><code>.ts</code> ts 文件的后缀名</li>
<li><code>.tsx</code> 是在 TS 中使用 React 组件时的后缀。只要代码中出现 JSX 结构，就得使用该后缀</li>
</ul>
</li>
<li>在 src 目录中，多了<code>react-app-env.d.ts</code>文件<ul>
<li><code>.d.ts</code> 类型声明文件，用来指定类型</li>
<li>注意：不要动 src/react-app-env.d.ts 文件！！！</li>
</ul>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TS 中的 三斜线指令，作用类似于 import 用于指定对其他类型声明文件的依赖关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处，通过 types 来声明依赖于 react-scripts 包</span></span><br><span class="line"><span class="comment">// https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-types-</span></span><br><span class="line"><span class="comment">/// &lt;reference types=&quot;react-scripts&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="tsconfig-的介绍"><a href="#tsconfig-的介绍" class="headerlink" title="tsconfig 的介绍"></a>tsconfig 的介绍</h2><p><strong>目标</strong>：能够知道 tsconfig 的作用</p>
<p><strong>内容</strong>：</p>
<ul>
<li><p>tsconfig.json 是 TS 项目的配置文件，可以用来指定如何编译 TS 代码等</p>
</li>
<li><p>手动创建 tsconfig.json 配置文件的命令：<code>tsc --init</code></p>
</li>
<li><p>说明：所有的配置项都可以通过鼠标移入的方式，来查看配置项的解释说明</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig">tsconfig 文档链接</a></p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// 编译选项</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 生成代码的语言版本：将我们写的 TS 代码编译成哪个版本的 JS 代码</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 指定要包含在编译中的 library</span></span><br><span class="line">    <span class="comment">// https://github.com/microsoft/TypeScript/blob/90e83adb44/lib/lib.dom.iterable.d.ts</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;dom&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dom.iterable&quot;</span><span class="punctuation">,</span> <span class="string">&quot;esnext&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">//outDir 用来指定编译后文件所在的文件</span></span><br><span class="line">     <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span><span class="string">&quot;./dist&quot;</span></span><br><span class="line">    <span class="comment">// 允许 ts 编译器编译 js 文件</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 跳过类型声明文件的类型检查</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// es 模块 互操作，屏蔽 ESModule 和 CommonJS 之间的差异</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 允许通过 import x from &#x27;y&#x27; 即使模块没有显式指定 default 导出</span></span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 开启严格模式</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 对文件名称强制区分大小写</span></span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 为 switch 语句启用错误报告</span></span><br><span class="line">    <span class="attr">&quot;noFallthroughCasesInSwitch&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 生成代码的模块化标准</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esnext&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 模块解析（查找）策略</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 允许导入扩展名为.json的模块</span></span><br><span class="line">    <span class="attr">&quot;resolveJsonModule&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 是否将没有 import/export 的文件视为旧（全局而非模块化）脚本文件</span></span><br><span class="line">    <span class="attr">&quot;isolatedModules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 编译时不生成任何JS文件（只进行类型检查）</span></span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 指定将 JSX 编译成什么形式</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-jsx&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 指定允许 ts 处理的目录</span></span><br><span class="line">    ** 表示任意目录</span><br><span class="line">    *  表示任意文件</span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//&quot;exclude&quot;:&quot;./**/*&quot; //有默认值，一般不需要我们自己写</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="类型声明文件介绍"><a href="#类型声明文件介绍" class="headerlink" title="类型声明文件介绍"></a>类型声明文件介绍</h2><p>今天几乎所有的 JavaScript 应用都会引入许多第三方库来完成任务需求。</p>
<p>这些第三方库不管是否是用 TS 编写的，最终都要编译成 JS 代码，才能发布给开发者使用。</p>
<p>我们知道是 TS 提供了类型，才有了代码提示和类型保护等机制。</p>
<p>但在项目开发中使用第三方库时，你会发现它们几乎都有相应的 TS 类型，这些类型是怎么来的呢? <code>类型声明文件</code></p>
<ul>
<li><strong>类型声明文件：用来为已存在的 JS 提供类型信息</strong></li>
</ul>
<p>这样在 TS 项目中使用这些库时，就像用 TS 一样，都会有代码提示、类型保护等机制了。</p>
<h2 id="TS-的两种文件类型"><a href="#TS-的两种文件类型" class="headerlink" title="TS 的两种文件类型"></a>TS 的两种文件类型</h2><p><strong>目标</strong>：能够说出 TS 中的两种文件类型</p>
<p><strong>内容</strong>：</p>
<ul>
<li>TS 中有两种文件类型：1 <code>.ts</code> 文件 2 <code>.d.ts</code> 文件</li>
<li><code>.ts</code>文件:<ol>
<li><code> 既包含类型信息又包含可执行代码</code></li>
<li>可以被编译为 .js 文件，然后，执行代码</li>
<li>用途：编写程序代码的地方</li>
</ol>
</li>
<li><code>.d.ts</code>文件:<ol>
<li><code>只包含类型信息</code>的类型声明文件</li>
<li><strong>不会生成 .js 文件，仅用于提供类型信息，在.d.ts 文件中不允许出现可执行的代码，只用于提供类型</strong></li>
<li>用途：为 JS 提供类型信息</li>
</ol>
</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>.ts 是 implementation（代码实现文件）</li>
<li><strong>.d.ts 是 declaration（类型声明文件）</strong></li>
<li>如果要为 JS 提供类型信息，要使用 <code>.d.ts</code> 文件</li>
</ul>
<h2 id="类型声明文件-内置"><a href="#类型声明文件-内置" class="headerlink" title="类型声明文件-内置"></a>类型声明文件-内置</h2><p><strong>目标</strong>：能够知道数组的类型提示是由内置类型声明文件提供的类型</p>
<p><strong>内容</strong>：</p>
<p>TS 为 JS 运行时可用的所有标准化内置 API 都提供了声明文件</p>
<p>比如，在使用数组时，数组所有方法都会有相应的代码提示以及类型信息：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strs = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="comment">// 鼠标放在 forEach 上查看类型</span></span><br><span class="line"><span class="comment">// (method) Array&lt;string&gt;.forEach(callbackfn: (value: string, index: number, array: string[]) =&gt; void, thisArg?: any): void</span></span><br><span class="line">strs.<span class="property">forEach</span>;</span><br></pre></td></tr></table></figure>

<p>可以通过 Ctrl + 鼠标左键（Mac：Command + 鼠标左键）来查看内置类型声明文件内容</p>
<p>实际上，这就是 TS 提供的内置类型声明文件提供的类型信息</p>
<ul>
<li>比如，查看 forEach 方法的类型声明，在 VSCode 中会自动跳转到 <code>lib.es5.d.ts</code> 类型声明文件中</li>
<li>当然，像 window、document 等 BOM、DOM API 也都有相应的类型声明（<code>lib.dom.d.ts</code>）</li>
</ul>
<h2 id="类型声明文件-第三方库"><a href="#类型声明文件-第三方库" class="headerlink" title="类型声明文件-第三方库"></a>类型声明文件-第三方库</h2><p><strong>目标</strong>：能够安装第三方库的类型声明文件</p>
<p><strong>内容</strong>：</p>
<p>目前，几乎所有常用的第三方库都有相应的类型声明文件</p>
<p>第三方库的类型声明文件有两种存在形式：1. 库自带类型声明文件       2. 由 DefinitelyTyped 提供</p>
<ol>
<li>库自带类型声明文件：比如，axios<ul>
<li>查看 <code>node_modules/axios</code> 目录</li>
<li>解释：这种情况下，正常导入该库，<strong>TS 就会自动加载库自己的类型声明文件</strong>，以提供该库的类型声明</li>
<li>VSCode 中如何找到它的类型声明文件？就是在 import 导入包的时候，会读取 axios 的 package.json 中的 types 字段，来加载指定的类型声明文件</li>
</ul>
</li>
<li>由 DefinitelyTyped 提供<ul>
<li>DefinitelyTyped 是一个 github 仓库，用来提供高质量 TypeScript 类型声明，<a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped/">DefinitelyTyped 链接</a></li>
<li>可以通过 npm/yarn 来下载该仓库提供的 TS 类型声明包，这些包的名称格式为：<code>@types/*</code>，比如，@types/react、@types/lodash 等</li>
<li>在实际项目开发时，如果你使用的第三方库没有自带的声明文件，VSCode 会给出明确的提示</li>
</ul>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 VSCode 中，鼠标移上去，查看 &#x27;lodash&#x27; 前面的提示</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>解释：当安装 <code>@types/*</code> 类型声明包后，<strong>TS 也会自动加载该类声明包</strong>，以提供该库的类型声明</li>
<li>补充：TS 官方文档提供了一个页面，可以来查询 @types/_ 库，<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/dt">@types/_ 库</a></li>
</ul>
<h2 id="类型声明文件-自定义"><a href="#类型声明文件-自定义" class="headerlink" title="类型声明文件-自定义"></a>类型声明文件-自定义</h2><p><strong>目标</strong>：能够手动创建一个类型声明文件来提供类型</p>
<p><strong>内容</strong>：</p>
<p>在项目开发中，有两种常见情况，需要自己手动创建类型声明文件：1. 项目内共享类型       2. 为已有 JS 文件提供类型声明</p>
<ol>
<li>项目内共享类型<ul>
<li>如果多个 .ts 文件中都用到同一个类型，此时可以创建 .d.ts 文件提供该类型，实现类型共享</li>
<li>操作步骤:<ol>
<li>创建 index.d.ts 类型声明文件</li>
<li>创建需要共享的类型，并使用 export 导出（TS 中的类型也可以使用 import/export 实现模块化功能）</li>
<li>在需要使用共享类型的 .ts 文件中，通过 import 导入即可（.d.ts 后缀导入时，直接省略）</li>
</ol>
</li>
</ul>
</li>
<li>为已有 JS 文件提供类型声明<ol>
<li>在将 JS 项目迁移到 TS 项目时，为了让已有的 .js 文件有类型声明</li>
<li>成为库作者，创建库给其他人使用</li>
</ol>
</li>
</ol>
<h2 id="类型声明文件的使用说明"><a href="#类型声明文件的使用说明" class="headerlink" title="类型声明文件的使用说明"></a>类型声明文件的使用说明</h2><ul>
<li>说明 1：TS 项目中也可以使用 .js 文件</li>
<li>说明 2：在导入 .js 文件时，TS 会自动加载与 .js 同名的 .d.ts 文件，以提供类型声明<ul>
<li>比如，在 导入 index.js 时，会自动加载 index.d.ts 类型声明文件</li>
</ul>
</li>
<li><code>declare</code>关键字：用于类型声明，为其他地方（比如，.js 文件）已存在的变量声明类型，而不是创建一个新的变量<ol>
<li>对于 type、interface 等这些明确就是 TS 类型的（只能在 TS 中使用的)，可以省略 declare 关键字</li>
<li>对于 let、function 等具有双重含义（在 JS、TS 中都能用），应该使用 declare 关键字，明确指定此处用于类型声明</li>
</ol>
</li>
</ul>
<p>假设有以下 .js 文件需要在 TS 代码中使用：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js 文件：</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> songName = <span class="string">&#x27;痴心绝对&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> position = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeDirection</span>(<span class="params">direction</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(direction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fomartPoint</span> = (<span class="params">point</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前坐标：&#x27;</span>, point);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; count, songName, position, add, changeDirection, fomartPoint &#125;;</span><br></pre></td></tr></table></figure>

<p>创建上面 .js 文件的类型声明文件：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.d.ts 文件：</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">count</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">songName</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// position 变量</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Position</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">position</span>: <span class="title class_">Position</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add 函数</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// changeDirection 函数</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27;right&#x27;</span> | <span class="string">&#x27;top&#x27;</span> | <span class="string">&#x27;bottom&#x27;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">changeDirection</span>(<span class="params">direction: Direction</span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fomartPoint 函数</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FomartPoint</span> = <span class="function">(<span class="params">point: Position</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">fomartPoint</span>: <span class="title class_">FomartPoint</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  count,</span><br><span class="line">  songName,</span><br><span class="line">  position,</span><br><span class="line">  add,</span><br><span class="line">  changeDirection,</span><br><span class="line">  <span class="title class_">FomartPoint</span>,</span><br><span class="line">  fomartPoint,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在文件中导入上述 .js 文件，查看是否有类型提示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  count,</span><br><span class="line">  songName,</span><br><span class="line">  position,</span><br><span class="line">  add,</span><br><span class="line">  changeDirection,</span><br><span class="line">  <span class="title class_">FomartPoint</span>,</span><br><span class="line">  fomartPoint,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./utils&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="类型声明文件的总结"><a href="#类型声明文件的总结" class="headerlink" title="类型声明文件的总结"></a>类型声明文件的总结</h2><p>类型声明文件出现目的：为 JS 文件提供类型声明</p>
<p>类型声明文件的后缀：<code>.d.ts</code></p>
<p>类型声明文件中只应该出现类型，不要有任何的实现（区别于 .ts 文件）</p>
<p>使用类型声明文件：只需要关注一种情况，没有自带类型声明文件的第三方库，VSCode 在发现没有类型声明文件时，会给出提示，我们只需要按照提示来安装类型声明文件即可： <code>yarn add @types/*</code> 来安装即可。</p>
</script></li></ul></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://old-gang.github.io">Mr.储</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://old-gang.github.io/post/3a1358b6.html">https://old-gang.github.io/post/3a1358b6.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://old-gang.github.io" target="_blank">Mr.储</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/web%E5%89%8D%E7%AB%AF/">web前端</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/e6cdea91.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端导出Excel</div></div></a></div><div class="next-post pull-right"><a href="/post/68eafc88.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">bug的解决</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mr.储</div><div class="author-info__description">Fake it, until u make it~</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/old-gang"><i class="fab fa-github"></i><span>点个关注呗</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/old-gang" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p align="center"><img src="https://chu-image-host.oss-cn-beijing.aliyuncs.com/typora/f7384c88956d4378b72e47548e19c9f8.gif" width="50" alt="gou"></p> <p align="center">微信号：cr1710518304</p> <p align="center">QQ号：1710518304</p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript"><span class="toc-number">1.</span> <span class="toc-text">TypeScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.0.1.</span> <span class="toc-text">TypeScript 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%BA-JS-%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81"><span class="toc-number">1.0.2.</span> <span class="toc-text">TypeScript 为什么要为 JS 添加类型支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">1.2.</span> <span class="toc-text">优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="toc-number">2.</span> <span class="toc-text">快速上手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91-TS-%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="toc-number">2.0.1.</span> <span class="toc-text">安装编译 TS 的依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-ts-%E4%BB%A3%E7%A0%81"><span class="toc-number">2.0.2.</span> <span class="toc-text">编译运行 ts 代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-ts-node-%E7%AE%80%E5%8C%96%E8%BF%90%E8%A1%8C-TS-%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.0.3.</span> <span class="toc-text">使用 ts-node 简化运行 TS 的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%B8%A4%E4%B8%AA-ts-%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%8D%E5%86%B2%E7%AA%81"><span class="toc-number">2.0.4.</span> <span class="toc-text">解决两个 ts 文件之间的变量名冲突</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript-%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">TypeScript 常用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.1.</span> <span class="toc-text">类型注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">常用基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">原始类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">数组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.3.</span> <span class="toc-text">联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.4.</span> <span class="toc-text">交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.2.5.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.6.</span> <span class="toc-text">never类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unknown%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.7.</span> <span class="toc-text">unknown类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#any%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.8.</span> <span class="toc-text">any类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never%E7%B1%BB%E5%9E%8B%E5%92%8Cunknown%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.9.</span> <span class="toc-text">never类型和unknown类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.10.</span> <span class="toc-text">函数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#void-%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.10.1.</span> <span class="toc-text">void 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.10.2.</span> <span class="toc-text">函数可选参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%AD%BE%E5%90%8D"><span class="toc-number">3.2.10.3.</span> <span class="toc-text">调用签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%AD%BE%E5%90%8D"><span class="toc-number">3.2.10.4.</span> <span class="toc-text">构造签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">3.2.10.5.</span> <span class="toc-text">函数的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8"><span class="toc-number">3.2.10.6.</span> <span class="toc-text">this的内置工具使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.11.</span> <span class="toc-text">对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.2.11.1.</span> <span class="toc-text">使用类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.11.2.</span> <span class="toc-text">带有参数的方法的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.11.3.</span> <span class="toc-text">箭头形式的方法类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">3.2.11.4.</span> <span class="toc-text">对象可选属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-interface"><span class="toc-number">3.2.12.</span> <span class="toc-text">接口 interface</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.12.1.</span> <span class="toc-text">接口和自定义类型的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-number">3.2.12.2.</span> <span class="toc-text">接口继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-number">3.2.13.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA"><span class="toc-number">3.2.14.</span> <span class="toc-text">类型推论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.15.</span> <span class="toc-text">字面量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.15.1.</span> <span class="toc-text">使用场景和模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.2.16.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.2.16.1.</span> <span class="toc-text">数字枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.2.16.2.</span> <span class="toc-text">字符串枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.16.3.</span> <span class="toc-text">枚举实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#any-%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.17.</span> <span class="toc-text">any 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">3.2.18.</span> <span class="toc-text">类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E8%A8%80%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.19.</span> <span class="toc-text">断言总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.2.20.</span> <span class="toc-text">类型缩小</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81typeof"><span class="toc-number">3.2.20.1.</span> <span class="toc-text">1、typeof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%B9%B3%E7%AD%89%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.2.20.2.</span> <span class="toc-text">2、平等缩小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81instanceof"><span class="toc-number">3.2.20.3.</span> <span class="toc-text">3、instanceof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81in%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.20.4.</span> <span class="toc-text">4、in操作符 (索引类型)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">TypeScript 高级类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.</span> <span class="toc-text">TypeScript面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">4.1.2.</span> <span class="toc-text">类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.1.3.</span> <span class="toc-text">类的成员修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getters-x2F-setters"><span class="toc-number">4.1.4.</span> <span class="toc-text">getters&#x2F;setters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="toc-number">4.1.5.</span> <span class="toc-text">参数属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BBabstract"><span class="toc-number">4.1.6.</span> <span class="toc-text">抽象类abstract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.7.</span> <span class="toc-text">类的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-number">4.1.8.</span> <span class="toc-text">索引签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF-1"><span class="toc-number">4.1.9.</span> <span class="toc-text">接口继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.10.</span> <span class="toc-text">接口的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E5%AD%97%E9%9D%A2%E9%87%8F%E8%B5%8B%E5%80%BC%E6%A3%80%E6%B5%8B"><span class="toc-number">4.1.11.</span> <span class="toc-text">严格字面量赋值检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">TS 中的类型兼容性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-number">4.3.1.</span> <span class="toc-text">类型参数化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">泛型函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text">简化泛型函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.4.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">4.3.5.</span> <span class="toc-text">泛型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">4.3.6.</span> <span class="toc-text">添加泛型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E6%B3%9B%E5%9E%8B-keyof"><span class="toc-number">4.3.7.</span> <span class="toc-text">多个类型变量的泛型 (keyof)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">泛型工具类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial"><span class="toc-number">4.4.1.</span> <span class="toc-text">Partial</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Readonly"><span class="toc-number">4.4.2.</span> <span class="toc-text">Readonly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pick"><span class="toc-number">4.4.3.</span> <span class="toc-text">Pick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Record"><span class="toc-number">4.4.4.</span> <span class="toc-text">Record</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Required"><span class="toc-number">4.4.5.</span> <span class="toc-text">Required</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReturnType"><span class="toc-number">4.4.6.</span> <span class="toc-text">ReturnType</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Omit"><span class="toc-number">4.4.7.</span> <span class="toc-text">Omit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parameters"><span class="toc-number">4.4.8.</span> <span class="toc-text">Parameters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NonNullable"><span class="toc-number">4.4.9.</span> <span class="toc-text">NonNullable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exclude"><span class="toc-number">4.4.10.</span> <span class="toc-text">Exclude</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extract"><span class="toc-number">4.4.11.</span> <span class="toc-text">Extract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InstanceType"><span class="toc-number">4.4.12.</span> <span class="toc-text">InstanceType</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConstructorParameters"><span class="toc-number">4.4.13.</span> <span class="toc-text">ConstructorParameters</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.</span> <span class="toc-text">映射类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.5.1.</span> <span class="toc-text">映射修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95"><span class="toc-number">5.</span> <span class="toc-text">TypeScript知识扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">TypeScript模块化</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Mr.储</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-api-ten-lac.vercel.app',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-api-ten-lac.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>